// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: PUConfig.proto

#ifndef PROTOBUF_PUConfig_2eproto__INCLUDED
#define PROTOBUF_PUConfig_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
// @@protoc_insertion_point(includes)

namespace BVCU {
namespace PUConfig {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_PUConfig_2eproto();
void protobuf_AssignDesc_PUConfig_2eproto();
void protobuf_ShutdownFile_PUConfig_2eproto();

class ImageSize;
class ImageRect;
class DayTimeSlice;
class WeekTimeSlice;
class WeekTimeSlice_DayTimeSlices;
class WallTime;
class VideoFormat;
class ImagePos;
class PUOneChannelInfo;
class PUChannelInfo;
class DeviceInfo;
class UpdateStatus;
class Upgrade;
class GroupInfo;
class Power;
class VideoColorCtl;
class MotionDetect;
class VideoShelter;
class VideoOcclusionDetect;
class VideoIn;
class AudioIn;
class AudioDecoderParam;
class AudioOut;
class AlertIn;
class AlertOut;
class GPSParam;
class GPSData;
class SnapshotParam;
class AudioEncoderParam;
class EncoderParam;
class EncoderStreamParam;
class EncoderChannel;
class RS232;
class SerialPort;
class Preset;
class CruisePoint;
class Cruise;
class PTZControl;
class PTZAttr;
class Ethernet;
class WifiHotSpot;
class WifiGeneral;
class Wifi;
class RadioNetwork;
class RadioNetworkAll;
class RegisterServer;
class UpdateServer;
class EmailServer;
class NTPServer;
class TimeSource;
class DDNS;
class Servers;
class Storage_Schedule;
class Storage_Media;
class Storage_Rule;
class Storage_Format;
class OnlineControlOne;
class OnlineEventSMS;
class OnlineControl;
class OnlineControl_TimeSliceOnlineCtrl;
class OnlineControl_TimeSliceOnlineCtrls;

// ===================================================================

class ImageSize : public ::google::protobuf::Message {
 public:
  ImageSize();
  virtual ~ImageSize();
  
  ImageSize(const ImageSize& from);
  
  inline ImageSize& operator=(const ImageSize& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ImageSize& default_instance();
  
  void Swap(ImageSize* other);
  
  // implements Message ----------------------------------------------
  
  ImageSize* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ImageSize& from);
  void MergeFrom(const ImageSize& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional uint32 iWidth = 1;
  inline bool has_iwidth() const;
  inline void clear_iwidth();
  static const int kIWidthFieldNumber = 1;
  inline ::google::protobuf::uint32 iwidth() const;
  inline void set_iwidth(::google::protobuf::uint32 value);
  
  // optional uint32 iHeight = 2;
  inline bool has_iheight() const;
  inline void clear_iheight();
  static const int kIHeightFieldNumber = 2;
  inline ::google::protobuf::uint32 iheight() const;
  inline void set_iheight(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:BVCU.PUConfig.ImageSize)
 private:
  inline void set_has_iwidth();
  inline void clear_has_iwidth();
  inline void set_has_iheight();
  inline void clear_has_iheight();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint32 iwidth_;
  ::google::protobuf::uint32 iheight_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_PUConfig_2eproto();
  friend void protobuf_AssignDesc_PUConfig_2eproto();
  friend void protobuf_ShutdownFile_PUConfig_2eproto();
  
  void InitAsDefaultInstance();
  static ImageSize* default_instance_;
};
// -------------------------------------------------------------------

class ImageRect : public ::google::protobuf::Message {
 public:
  ImageRect();
  virtual ~ImageRect();
  
  ImageRect(const ImageRect& from);
  
  inline ImageRect& operator=(const ImageRect& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ImageRect& default_instance();
  
  void Swap(ImageRect* other);
  
  // implements Message ----------------------------------------------
  
  ImageRect* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ImageRect& from);
  void MergeFrom(const ImageRect& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional uint32 iLeft = 1;
  inline bool has_ileft() const;
  inline void clear_ileft();
  static const int kILeftFieldNumber = 1;
  inline ::google::protobuf::uint32 ileft() const;
  inline void set_ileft(::google::protobuf::uint32 value);
  
  // optional uint32 iTop = 2;
  inline bool has_itop() const;
  inline void clear_itop();
  static const int kITopFieldNumber = 2;
  inline ::google::protobuf::uint32 itop() const;
  inline void set_itop(::google::protobuf::uint32 value);
  
  // optional uint32 iWidth = 3;
  inline bool has_iwidth() const;
  inline void clear_iwidth();
  static const int kIWidthFieldNumber = 3;
  inline ::google::protobuf::uint32 iwidth() const;
  inline void set_iwidth(::google::protobuf::uint32 value);
  
  // optional uint32 iHeight = 4;
  inline bool has_iheight() const;
  inline void clear_iheight();
  static const int kIHeightFieldNumber = 4;
  inline ::google::protobuf::uint32 iheight() const;
  inline void set_iheight(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:BVCU.PUConfig.ImageRect)
 private:
  inline void set_has_ileft();
  inline void clear_has_ileft();
  inline void set_has_itop();
  inline void clear_has_itop();
  inline void set_has_iwidth();
  inline void clear_has_iwidth();
  inline void set_has_iheight();
  inline void clear_has_iheight();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint32 ileft_;
  ::google::protobuf::uint32 itop_;
  ::google::protobuf::uint32 iwidth_;
  ::google::protobuf::uint32 iheight_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_PUConfig_2eproto();
  friend void protobuf_AssignDesc_PUConfig_2eproto();
  friend void protobuf_ShutdownFile_PUConfig_2eproto();
  
  void InitAsDefaultInstance();
  static ImageRect* default_instance_;
};
// -------------------------------------------------------------------

class DayTimeSlice : public ::google::protobuf::Message {
 public:
  DayTimeSlice();
  virtual ~DayTimeSlice();
  
  DayTimeSlice(const DayTimeSlice& from);
  
  inline DayTimeSlice& operator=(const DayTimeSlice& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const DayTimeSlice& default_instance();
  
  void Swap(DayTimeSlice* other);
  
  // implements Message ----------------------------------------------
  
  DayTimeSlice* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DayTimeSlice& from);
  void MergeFrom(const DayTimeSlice& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional uint32 cHourBegin = 1;
  inline bool has_chourbegin() const;
  inline void clear_chourbegin();
  static const int kCHourBeginFieldNumber = 1;
  inline ::google::protobuf::uint32 chourbegin() const;
  inline void set_chourbegin(::google::protobuf::uint32 value);
  
  // optional uint32 cMinuteBegin = 2;
  inline bool has_cminutebegin() const;
  inline void clear_cminutebegin();
  static const int kCMinuteBeginFieldNumber = 2;
  inline ::google::protobuf::uint32 cminutebegin() const;
  inline void set_cminutebegin(::google::protobuf::uint32 value);
  
  // optional uint32 cSecondBegin = 3;
  inline bool has_csecondbegin() const;
  inline void clear_csecondbegin();
  static const int kCSecondBeginFieldNumber = 3;
  inline ::google::protobuf::uint32 csecondbegin() const;
  inline void set_csecondbegin(::google::protobuf::uint32 value);
  
  // optional uint32 cHourEnd = 4 [default = 24];
  inline bool has_chourend() const;
  inline void clear_chourend();
  static const int kCHourEndFieldNumber = 4;
  inline ::google::protobuf::uint32 chourend() const;
  inline void set_chourend(::google::protobuf::uint32 value);
  
  // optional uint32 cMinuteEnd = 5;
  inline bool has_cminuteend() const;
  inline void clear_cminuteend();
  static const int kCMinuteEndFieldNumber = 5;
  inline ::google::protobuf::uint32 cminuteend() const;
  inline void set_cminuteend(::google::protobuf::uint32 value);
  
  // optional uint32 cSecondEnd = 6;
  inline bool has_csecondend() const;
  inline void clear_csecondend();
  static const int kCSecondEndFieldNumber = 6;
  inline ::google::protobuf::uint32 csecondend() const;
  inline void set_csecondend(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:BVCU.PUConfig.DayTimeSlice)
 private:
  inline void set_has_chourbegin();
  inline void clear_has_chourbegin();
  inline void set_has_cminutebegin();
  inline void clear_has_cminutebegin();
  inline void set_has_csecondbegin();
  inline void clear_has_csecondbegin();
  inline void set_has_chourend();
  inline void clear_has_chourend();
  inline void set_has_cminuteend();
  inline void clear_has_cminuteend();
  inline void set_has_csecondend();
  inline void clear_has_csecondend();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint32 chourbegin_;
  ::google::protobuf::uint32 cminutebegin_;
  ::google::protobuf::uint32 csecondbegin_;
  ::google::protobuf::uint32 chourend_;
  ::google::protobuf::uint32 cminuteend_;
  ::google::protobuf::uint32 csecondend_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  friend void  protobuf_AddDesc_PUConfig_2eproto();
  friend void protobuf_AssignDesc_PUConfig_2eproto();
  friend void protobuf_ShutdownFile_PUConfig_2eproto();
  
  void InitAsDefaultInstance();
  static DayTimeSlice* default_instance_;
};
// -------------------------------------------------------------------

class WeekTimeSlice_DayTimeSlices : public ::google::protobuf::Message {
 public:
  WeekTimeSlice_DayTimeSlices();
  virtual ~WeekTimeSlice_DayTimeSlices();
  
  WeekTimeSlice_DayTimeSlices(const WeekTimeSlice_DayTimeSlices& from);
  
  inline WeekTimeSlice_DayTimeSlices& operator=(const WeekTimeSlice_DayTimeSlices& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const WeekTimeSlice_DayTimeSlices& default_instance();
  
  void Swap(WeekTimeSlice_DayTimeSlices* other);
  
  // implements Message ----------------------------------------------
  
  WeekTimeSlice_DayTimeSlices* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const WeekTimeSlice_DayTimeSlices& from);
  void MergeFrom(const WeekTimeSlice_DayTimeSlices& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .BVCU.PUConfig.DayTimeSlice stDay = 1;
  inline int stday_size() const;
  inline void clear_stday();
  static const int kStDayFieldNumber = 1;
  inline const ::BVCU::PUConfig::DayTimeSlice& stday(int index) const;
  inline ::BVCU::PUConfig::DayTimeSlice* mutable_stday(int index);
  inline ::BVCU::PUConfig::DayTimeSlice* add_stday();
  inline const ::google::protobuf::RepeatedPtrField< ::BVCU::PUConfig::DayTimeSlice >&
      stday() const;
  inline ::google::protobuf::RepeatedPtrField< ::BVCU::PUConfig::DayTimeSlice >*
      mutable_stday();
  
  // @@protoc_insertion_point(class_scope:BVCU.PUConfig.WeekTimeSlice.DayTimeSlices)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::BVCU::PUConfig::DayTimeSlice > stday_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_PUConfig_2eproto();
  friend void protobuf_AssignDesc_PUConfig_2eproto();
  friend void protobuf_ShutdownFile_PUConfig_2eproto();
  
  void InitAsDefaultInstance();
  static WeekTimeSlice_DayTimeSlices* default_instance_;
};
// -------------------------------------------------------------------

class WeekTimeSlice : public ::google::protobuf::Message {
 public:
  WeekTimeSlice();
  virtual ~WeekTimeSlice();
  
  WeekTimeSlice(const WeekTimeSlice& from);
  
  inline WeekTimeSlice& operator=(const WeekTimeSlice& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const WeekTimeSlice& default_instance();
  
  void Swap(WeekTimeSlice* other);
  
  // implements Message ----------------------------------------------
  
  WeekTimeSlice* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const WeekTimeSlice& from);
  void MergeFrom(const WeekTimeSlice& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef WeekTimeSlice_DayTimeSlices DayTimeSlices;
  
  // accessors -------------------------------------------------------
  
  // repeated .BVCU.PUConfig.WeekTimeSlice.DayTimeSlices stWeek = 1;
  inline int stweek_size() const;
  inline void clear_stweek();
  static const int kStWeekFieldNumber = 1;
  inline const ::BVCU::PUConfig::WeekTimeSlice_DayTimeSlices& stweek(int index) const;
  inline ::BVCU::PUConfig::WeekTimeSlice_DayTimeSlices* mutable_stweek(int index);
  inline ::BVCU::PUConfig::WeekTimeSlice_DayTimeSlices* add_stweek();
  inline const ::google::protobuf::RepeatedPtrField< ::BVCU::PUConfig::WeekTimeSlice_DayTimeSlices >&
      stweek() const;
  inline ::google::protobuf::RepeatedPtrField< ::BVCU::PUConfig::WeekTimeSlice_DayTimeSlices >*
      mutable_stweek();
  
  // @@protoc_insertion_point(class_scope:BVCU.PUConfig.WeekTimeSlice)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::BVCU::PUConfig::WeekTimeSlice_DayTimeSlices > stweek_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_PUConfig_2eproto();
  friend void protobuf_AssignDesc_PUConfig_2eproto();
  friend void protobuf_ShutdownFile_PUConfig_2eproto();
  
  void InitAsDefaultInstance();
  static WeekTimeSlice* default_instance_;
};
// -------------------------------------------------------------------

class WallTime : public ::google::protobuf::Message {
 public:
  WallTime();
  virtual ~WallTime();
  
  WallTime(const WallTime& from);
  
  inline WallTime& operator=(const WallTime& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const WallTime& default_instance();
  
  void Swap(WallTime* other);
  
  // implements Message ----------------------------------------------
  
  WallTime* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const WallTime& from);
  void MergeFrom(const WallTime& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional uint32 iYear = 1;
  inline bool has_iyear() const;
  inline void clear_iyear();
  static const int kIYearFieldNumber = 1;
  inline ::google::protobuf::uint32 iyear() const;
  inline void set_iyear(::google::protobuf::uint32 value);
  
  // optional uint32 iMonth = 2;
  inline bool has_imonth() const;
  inline void clear_imonth();
  static const int kIMonthFieldNumber = 2;
  inline ::google::protobuf::uint32 imonth() const;
  inline void set_imonth(::google::protobuf::uint32 value);
  
  // optional uint32 iDay = 3;
  inline bool has_iday() const;
  inline void clear_iday();
  static const int kIDayFieldNumber = 3;
  inline ::google::protobuf::uint32 iday() const;
  inline void set_iday(::google::protobuf::uint32 value);
  
  // optional uint32 iHour = 4;
  inline bool has_ihour() const;
  inline void clear_ihour();
  static const int kIHourFieldNumber = 4;
  inline ::google::protobuf::uint32 ihour() const;
  inline void set_ihour(::google::protobuf::uint32 value);
  
  // optional uint32 iMinute = 5;
  inline bool has_iminute() const;
  inline void clear_iminute();
  static const int kIMinuteFieldNumber = 5;
  inline ::google::protobuf::uint32 iminute() const;
  inline void set_iminute(::google::protobuf::uint32 value);
  
  // optional uint32 iSecond = 6;
  inline bool has_isecond() const;
  inline void clear_isecond();
  static const int kISecondFieldNumber = 6;
  inline ::google::protobuf::uint32 isecond() const;
  inline void set_isecond(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:BVCU.PUConfig.WallTime)
 private:
  inline void set_has_iyear();
  inline void clear_has_iyear();
  inline void set_has_imonth();
  inline void clear_has_imonth();
  inline void set_has_iday();
  inline void clear_has_iday();
  inline void set_has_ihour();
  inline void clear_has_ihour();
  inline void set_has_iminute();
  inline void clear_has_iminute();
  inline void set_has_isecond();
  inline void clear_has_isecond();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint32 iyear_;
  ::google::protobuf::uint32 imonth_;
  ::google::protobuf::uint32 iday_;
  ::google::protobuf::uint32 ihour_;
  ::google::protobuf::uint32 iminute_;
  ::google::protobuf::uint32 isecond_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  friend void  protobuf_AddDesc_PUConfig_2eproto();
  friend void protobuf_AssignDesc_PUConfig_2eproto();
  friend void protobuf_ShutdownFile_PUConfig_2eproto();
  
  void InitAsDefaultInstance();
  static WallTime* default_instance_;
};
// -------------------------------------------------------------------

class VideoFormat : public ::google::protobuf::Message {
 public:
  VideoFormat();
  virtual ~VideoFormat();
  
  VideoFormat(const VideoFormat& from);
  
  inline VideoFormat& operator=(const VideoFormat& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const VideoFormat& default_instance();
  
  void Swap(VideoFormat* other);
  
  // implements Message ----------------------------------------------
  
  VideoFormat* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const VideoFormat& from);
  void MergeFrom(const VideoFormat& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional uint32 iVideoForamt = 1;
  inline bool has_ivideoforamt() const;
  inline void clear_ivideoforamt();
  static const int kIVideoForamtFieldNumber = 1;
  inline ::google::protobuf::uint32 ivideoforamt() const;
  inline void set_ivideoforamt(::google::protobuf::uint32 value);
  
  // repeated .BVCU.PUConfig.ImageSize stImageSize = 2;
  inline int stimagesize_size() const;
  inline void clear_stimagesize();
  static const int kStImageSizeFieldNumber = 2;
  inline const ::BVCU::PUConfig::ImageSize& stimagesize(int index) const;
  inline ::BVCU::PUConfig::ImageSize* mutable_stimagesize(int index);
  inline ::BVCU::PUConfig::ImageSize* add_stimagesize();
  inline const ::google::protobuf::RepeatedPtrField< ::BVCU::PUConfig::ImageSize >&
      stimagesize() const;
  inline ::google::protobuf::RepeatedPtrField< ::BVCU::PUConfig::ImageSize >*
      mutable_stimagesize();
  
  // repeated uint32 iFPSMax = 3;
  inline int ifpsmax_size() const;
  inline void clear_ifpsmax();
  static const int kIFPSMaxFieldNumber = 3;
  inline ::google::protobuf::uint32 ifpsmax(int index) const;
  inline void set_ifpsmax(int index, ::google::protobuf::uint32 value);
  inline void add_ifpsmax(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      ifpsmax() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_ifpsmax();
  
  // optional uint32 iIndex = 4;
  inline bool has_iindex() const;
  inline void clear_iindex();
  static const int kIIndexFieldNumber = 4;
  inline ::google::protobuf::uint32 iindex() const;
  inline void set_iindex(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:BVCU.PUConfig.VideoFormat)
 private:
  inline void set_has_ivideoforamt();
  inline void clear_has_ivideoforamt();
  inline void set_has_iindex();
  inline void clear_has_iindex();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::BVCU::PUConfig::ImageSize > stimagesize_;
  ::google::protobuf::uint32 ivideoforamt_;
  ::google::protobuf::uint32 iindex_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > ifpsmax_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_PUConfig_2eproto();
  friend void protobuf_AssignDesc_PUConfig_2eproto();
  friend void protobuf_ShutdownFile_PUConfig_2eproto();
  
  void InitAsDefaultInstance();
  static VideoFormat* default_instance_;
};
// -------------------------------------------------------------------

class ImagePos : public ::google::protobuf::Message {
 public:
  ImagePos();
  virtual ~ImagePos();
  
  ImagePos(const ImagePos& from);
  
  inline ImagePos& operator=(const ImagePos& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ImagePos& default_instance();
  
  void Swap(ImagePos* other);
  
  // implements Message ----------------------------------------------
  
  ImagePos* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ImagePos& from);
  void MergeFrom(const ImagePos& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional uint32 iLeft = 1;
  inline bool has_ileft() const;
  inline void clear_ileft();
  static const int kILeftFieldNumber = 1;
  inline ::google::protobuf::uint32 ileft() const;
  inline void set_ileft(::google::protobuf::uint32 value);
  
  // optional uint32 iTop = 2;
  inline bool has_itop() const;
  inline void clear_itop();
  static const int kITopFieldNumber = 2;
  inline ::google::protobuf::uint32 itop() const;
  inline void set_itop(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:BVCU.PUConfig.ImagePos)
 private:
  inline void set_has_ileft();
  inline void clear_has_ileft();
  inline void set_has_itop();
  inline void clear_has_itop();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint32 ileft_;
  ::google::protobuf::uint32 itop_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_PUConfig_2eproto();
  friend void protobuf_AssignDesc_PUConfig_2eproto();
  friend void protobuf_ShutdownFile_PUConfig_2eproto();
  
  void InitAsDefaultInstance();
  static ImagePos* default_instance_;
};
// -------------------------------------------------------------------

class PUOneChannelInfo : public ::google::protobuf::Message {
 public:
  PUOneChannelInfo();
  virtual ~PUOneChannelInfo();
  
  PUOneChannelInfo(const PUOneChannelInfo& from);
  
  inline PUOneChannelInfo& operator=(const PUOneChannelInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const PUOneChannelInfo& default_instance();
  
  void Swap(PUOneChannelInfo* other);
  
  // implements Message ----------------------------------------------
  
  PUOneChannelInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PUOneChannelInfo& from);
  void MergeFrom(const PUOneChannelInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional uint32 iChannelIndex = 4;
  inline bool has_ichannelindex() const;
  inline void clear_ichannelindex();
  static const int kIChannelIndexFieldNumber = 4;
  inline ::google::protobuf::uint32 ichannelindex() const;
  inline void set_ichannelindex(::google::protobuf::uint32 value);
  
  // required uint32 iMediaDir = 1;
  inline bool has_imediadir() const;
  inline void clear_imediadir();
  static const int kIMediaDirFieldNumber = 1;
  inline ::google::protobuf::uint32 imediadir() const;
  inline void set_imediadir(::google::protobuf::uint32 value);
  
  // required int32 iPTZ = 2;
  inline bool has_iptz() const;
  inline void clear_iptz();
  static const int kIPTZFieldNumber = 2;
  inline ::google::protobuf::int32 iptz() const;
  inline void set_iptz(::google::protobuf::int32 value);
  
  // optional string szName = 3;
  inline bool has_szname() const;
  inline void clear_szname();
  static const int kSzNameFieldNumber = 3;
  inline const ::std::string& szname() const;
  inline void set_szname(const ::std::string& value);
  inline void set_szname(const char* value);
  inline void set_szname(const char* value, size_t size);
  inline ::std::string* mutable_szname();
  inline ::std::string* release_szname();
  
  // @@protoc_insertion_point(class_scope:BVCU.PUConfig.PUOneChannelInfo)
 private:
  inline void set_has_ichannelindex();
  inline void clear_has_ichannelindex();
  inline void set_has_imediadir();
  inline void clear_has_imediadir();
  inline void set_has_iptz();
  inline void clear_has_iptz();
  inline void set_has_szname();
  inline void clear_has_szname();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint32 ichannelindex_;
  ::google::protobuf::uint32 imediadir_;
  ::std::string* szname_;
  ::google::protobuf::int32 iptz_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_PUConfig_2eproto();
  friend void protobuf_AssignDesc_PUConfig_2eproto();
  friend void protobuf_ShutdownFile_PUConfig_2eproto();
  
  void InitAsDefaultInstance();
  static PUOneChannelInfo* default_instance_;
};
// -------------------------------------------------------------------

class PUChannelInfo : public ::google::protobuf::Message {
 public:
  PUChannelInfo();
  virtual ~PUChannelInfo();
  
  PUChannelInfo(const PUChannelInfo& from);
  
  inline PUChannelInfo& operator=(const PUChannelInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const PUChannelInfo& default_instance();
  
  void Swap(PUChannelInfo* other);
  
  // implements Message ----------------------------------------------
  
  PUChannelInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PUChannelInfo& from);
  void MergeFrom(const PUChannelInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string szID = 1;
  inline bool has_szid() const;
  inline void clear_szid();
  static const int kSzIDFieldNumber = 1;
  inline const ::std::string& szid() const;
  inline void set_szid(const ::std::string& value);
  inline void set_szid(const char* value);
  inline void set_szid(const char* value, size_t size);
  inline ::std::string* mutable_szid();
  inline ::std::string* release_szid();
  
  // required string szPUName = 2;
  inline bool has_szpuname() const;
  inline void clear_szpuname();
  static const int kSzPUNameFieldNumber = 2;
  inline const ::std::string& szpuname() const;
  inline void set_szpuname(const ::std::string& value);
  inline void set_szpuname(const char* value);
  inline void set_szpuname(const char* value, size_t size);
  inline ::std::string* mutable_szpuname();
  inline ::std::string* release_szpuname();
  
  // repeated .BVCU.PUConfig.PUOneChannelInfo pChannel = 4;
  inline int pchannel_size() const;
  inline void clear_pchannel();
  static const int kPChannelFieldNumber = 4;
  inline const ::BVCU::PUConfig::PUOneChannelInfo& pchannel(int index) const;
  inline ::BVCU::PUConfig::PUOneChannelInfo* mutable_pchannel(int index);
  inline ::BVCU::PUConfig::PUOneChannelInfo* add_pchannel();
  inline const ::google::protobuf::RepeatedPtrField< ::BVCU::PUConfig::PUOneChannelInfo >&
      pchannel() const;
  inline ::google::protobuf::RepeatedPtrField< ::BVCU::PUConfig::PUOneChannelInfo >*
      mutable_pchannel();
  
  // required uint32 iOnlineStatus = 5;
  inline bool has_ionlinestatus() const;
  inline void clear_ionlinestatus();
  static const int kIOnlineStatusFieldNumber = 5;
  inline ::google::protobuf::uint32 ionlinestatus() const;
  inline void set_ionlinestatus(::google::protobuf::uint32 value);
  
  // optional uint32 iGPSCount = 6;
  inline bool has_igpscount() const;
  inline void clear_igpscount();
  static const int kIGPSCountFieldNumber = 6;
  inline ::google::protobuf::uint32 igpscount() const;
  inline void set_igpscount(::google::protobuf::uint32 value);
  
  // optional uint32 iLongitude = 7 [default = 2000000000];
  inline bool has_ilongitude() const;
  inline void clear_ilongitude();
  static const int kILongitudeFieldNumber = 7;
  inline ::google::protobuf::uint32 ilongitude() const;
  inline void set_ilongitude(::google::protobuf::uint32 value);
  
  // optional uint32 iLatitude = 8 [default = 2000000000];
  inline bool has_ilatitude() const;
  inline void clear_ilatitude();
  static const int kILatitudeFieldNumber = 8;
  inline ::google::protobuf::uint32 ilatitude() const;
  inline void set_ilatitude(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:BVCU.PUConfig.PUChannelInfo)
 private:
  inline void set_has_szid();
  inline void clear_has_szid();
  inline void set_has_szpuname();
  inline void clear_has_szpuname();
  inline void set_has_ionlinestatus();
  inline void clear_has_ionlinestatus();
  inline void set_has_igpscount();
  inline void clear_has_igpscount();
  inline void set_has_ilongitude();
  inline void clear_has_ilongitude();
  inline void set_has_ilatitude();
  inline void clear_has_ilatitude();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* szid_;
  ::std::string* szpuname_;
  ::google::protobuf::RepeatedPtrField< ::BVCU::PUConfig::PUOneChannelInfo > pchannel_;
  ::google::protobuf::uint32 ionlinestatus_;
  ::google::protobuf::uint32 igpscount_;
  ::google::protobuf::uint32 ilongitude_;
  ::google::protobuf::uint32 ilatitude_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];
  
  friend void  protobuf_AddDesc_PUConfig_2eproto();
  friend void protobuf_AssignDesc_PUConfig_2eproto();
  friend void protobuf_ShutdownFile_PUConfig_2eproto();
  
  void InitAsDefaultInstance();
  static PUChannelInfo* default_instance_;
};
// -------------------------------------------------------------------

class DeviceInfo : public ::google::protobuf::Message {
 public:
  DeviceInfo();
  virtual ~DeviceInfo();
  
  DeviceInfo(const DeviceInfo& from);
  
  inline DeviceInfo& operator=(const DeviceInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const DeviceInfo& default_instance();
  
  void Swap(DeviceInfo* other);
  
  // implements Message ----------------------------------------------
  
  DeviceInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DeviceInfo& from);
  void MergeFrom(const DeviceInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string szID = 1;
  inline bool has_szid() const;
  inline void clear_szid();
  static const int kSzIDFieldNumber = 1;
  inline const ::std::string& szid() const;
  inline void set_szid(const ::std::string& value);
  inline void set_szid(const char* value);
  inline void set_szid(const char* value, size_t size);
  inline ::std::string* mutable_szid();
  inline ::std::string* release_szid();
  
  // optional string szManufacturer = 25;
  inline bool has_szmanufacturer() const;
  inline void clear_szmanufacturer();
  static const int kSzManufacturerFieldNumber = 25;
  inline const ::std::string& szmanufacturer() const;
  inline void set_szmanufacturer(const ::std::string& value);
  inline void set_szmanufacturer(const char* value);
  inline void set_szmanufacturer(const char* value, size_t size);
  inline ::std::string* mutable_szmanufacturer();
  inline ::std::string* release_szmanufacturer();
  
  // optional string szProductName = 2 [default = "NULL"];
  inline bool has_szproductname() const;
  inline void clear_szproductname();
  static const int kSzProductNameFieldNumber = 2;
  inline const ::std::string& szproductname() const;
  inline void set_szproductname(const ::std::string& value);
  inline void set_szproductname(const char* value);
  inline void set_szproductname(const char* value, size_t size);
  inline ::std::string* mutable_szproductname();
  inline ::std::string* release_szproductname();
  
  // optional string szSoftwareVersion = 3 [default = "NULL"];
  inline bool has_szsoftwareversion() const;
  inline void clear_szsoftwareversion();
  static const int kSzSoftwareVersionFieldNumber = 3;
  inline const ::std::string& szsoftwareversion() const;
  inline void set_szsoftwareversion(const ::std::string& value);
  inline void set_szsoftwareversion(const char* value);
  inline void set_szsoftwareversion(const char* value, size_t size);
  inline ::std::string* mutable_szsoftwareversion();
  inline ::std::string* release_szsoftwareversion();
  
  // optional string szHardwareVersion = 4 [default = "NULL"];
  inline bool has_szhardwareversion() const;
  inline void clear_szhardwareversion();
  static const int kSzHardwareVersionFieldNumber = 4;
  inline const ::std::string& szhardwareversion() const;
  inline void set_szhardwareversion(const ::std::string& value);
  inline void set_szhardwareversion(const char* value);
  inline void set_szhardwareversion(const char* value, size_t size);
  inline ::std::string* mutable_szhardwareversion();
  inline ::std::string* release_szhardwareversion();
  
  // required uint32 iPUType = 5;
  inline bool has_iputype() const;
  inline void clear_iputype();
  static const int kIPUTypeFieldNumber = 5;
  inline ::google::protobuf::uint32 iputype() const;
  inline void set_iputype(::google::protobuf::uint32 value);
  
  // repeated uint32 iLanguage = 6;
  inline int ilanguage_size() const;
  inline void clear_ilanguage();
  static const int kILanguageFieldNumber = 6;
  inline ::google::protobuf::uint32 ilanguage(int index) const;
  inline void set_ilanguage(int index, ::google::protobuf::uint32 value);
  inline void add_ilanguage(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      ilanguage() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_ilanguage();
  
  // optional uint32 iLanguageIndex = 7;
  inline bool has_ilanguageindex() const;
  inline void clear_ilanguageindex();
  static const int kILanguageIndexFieldNumber = 7;
  inline ::google::protobuf::uint32 ilanguageindex() const;
  inline void set_ilanguageindex(::google::protobuf::uint32 value);
  
  // optional string szName = 8;
  inline bool has_szname() const;
  inline void clear_szname();
  static const int kSzNameFieldNumber = 8;
  inline const ::std::string& szname() const;
  inline void set_szname(const ::std::string& value);
  inline void set_szname(const char* value);
  inline void set_szname(const char* value, size_t size);
  inline ::std::string* mutable_szname();
  inline ::std::string* release_szname();
  
  // optional uint32 iWIFICount = 9;
  inline bool has_iwificount() const;
  inline void clear_iwificount();
  static const int kIWIFICountFieldNumber = 9;
  inline ::google::protobuf::uint32 iwificount() const;
  inline void set_iwificount(::google::protobuf::uint32 value);
  
  // optional uint32 iRadioCount = 10;
  inline bool has_iradiocount() const;
  inline void clear_iradiocount();
  static const int kIRadioCountFieldNumber = 10;
  inline ::google::protobuf::uint32 iradiocount() const;
  inline void set_iradiocount(::google::protobuf::uint32 value);
  
  // optional uint32 iChannelCount = 11;
  inline bool has_ichannelcount() const;
  inline void clear_ichannelcount();
  static const int kIChannelCountFieldNumber = 11;
  inline ::google::protobuf::uint32 ichannelcount() const;
  inline void set_ichannelcount(::google::protobuf::uint32 value);
  
  // optional uint32 iVideoInCount = 12;
  inline bool has_ivideoincount() const;
  inline void clear_ivideoincount();
  static const int kIVideoInCountFieldNumber = 12;
  inline ::google::protobuf::uint32 ivideoincount() const;
  inline void set_ivideoincount(::google::protobuf::uint32 value);
  
  // optional uint32 iAudioInCount = 13;
  inline bool has_iaudioincount() const;
  inline void clear_iaudioincount();
  static const int kIAudioInCountFieldNumber = 13;
  inline ::google::protobuf::uint32 iaudioincount() const;
  inline void set_iaudioincount(::google::protobuf::uint32 value);
  
  // optional uint32 iAudioOutCount = 14;
  inline bool has_iaudiooutcount() const;
  inline void clear_iaudiooutcount();
  static const int kIAudioOutCountFieldNumber = 14;
  inline ::google::protobuf::uint32 iaudiooutcount() const;
  inline void set_iaudiooutcount(::google::protobuf::uint32 value);
  
  // optional uint32 iPTZCount = 15;
  inline bool has_iptzcount() const;
  inline void clear_iptzcount();
  static const int kIPTZCountFieldNumber = 15;
  inline ::google::protobuf::uint32 iptzcount() const;
  inline void set_iptzcount(::google::protobuf::uint32 value);
  
  // optional uint32 iSerialPortCount = 16;
  inline bool has_iserialportcount() const;
  inline void clear_iserialportcount();
  static const int kISerialPortCountFieldNumber = 16;
  inline ::google::protobuf::uint32 iserialportcount() const;
  inline void set_iserialportcount(::google::protobuf::uint32 value);
  
  // optional uint32 iAlertInCount = 17;
  inline bool has_ialertincount() const;
  inline void clear_ialertincount();
  static const int kIAlertInCountFieldNumber = 17;
  inline ::google::protobuf::uint32 ialertincount() const;
  inline void set_ialertincount(::google::protobuf::uint32 value);
  
  // optional uint32 iAlertOutCount = 18;
  inline bool has_ialertoutcount() const;
  inline void clear_ialertoutcount();
  static const int kIAlertOutCountFieldNumber = 18;
  inline ::google::protobuf::uint32 ialertoutcount() const;
  inline void set_ialertoutcount(::google::protobuf::uint32 value);
  
  // optional uint32 iStorageCount = 19;
  inline bool has_istoragecount() const;
  inline void clear_istoragecount();
  static const int kIStorageCountFieldNumber = 19;
  inline ::google::protobuf::uint32 istoragecount() const;
  inline void set_istoragecount(::google::protobuf::uint32 value);
  
  // optional uint32 iGPSCount = 20;
  inline bool has_igpscount() const;
  inline void clear_igpscount();
  static const int kIGPSCountFieldNumber = 20;
  inline ::google::protobuf::uint32 igpscount() const;
  inline void set_igpscount(::google::protobuf::uint32 value);
  
  // optional uint32 bSupportSMS = 21;
  inline bool has_bsupportsms() const;
  inline void clear_bsupportsms();
  static const int kBSupportSMSFieldNumber = 21;
  inline ::google::protobuf::uint32 bsupportsms() const;
  inline void set_bsupportsms(::google::protobuf::uint32 value);
  
  // optional uint32 iPresetCount = 22;
  inline bool has_ipresetcount() const;
  inline void clear_ipresetcount();
  static const int kIPresetCountFieldNumber = 22;
  inline ::google::protobuf::uint32 ipresetcount() const;
  inline void set_ipresetcount(::google::protobuf::uint32 value);
  
  // optional uint32 iCruiseCount = 23;
  inline bool has_icruisecount() const;
  inline void clear_icruisecount();
  static const int kICruiseCountFieldNumber = 23;
  inline ::google::protobuf::uint32 icruisecount() const;
  inline void set_icruisecount(::google::protobuf::uint32 value);
  
  // optional uint32 iAlarmLinkActionCount = 24;
  inline bool has_ialarmlinkactioncount() const;
  inline void clear_ialarmlinkactioncount();
  static const int kIAlarmLinkActionCountFieldNumber = 24;
  inline ::google::protobuf::uint32 ialarmlinkactioncount() const;
  inline void set_ialarmlinkactioncount(::google::protobuf::uint32 value);
  
  // optional int32 iLongitude = 26;
  inline bool has_ilongitude() const;
  inline void clear_ilongitude();
  static const int kILongitudeFieldNumber = 26;
  inline ::google::protobuf::int32 ilongitude() const;
  inline void set_ilongitude(::google::protobuf::int32 value);
  
  // optional int32 iLatitude = 27;
  inline bool has_ilatitude() const;
  inline void clear_ilatitude();
  static const int kILatitudeFieldNumber = 27;
  inline ::google::protobuf::int32 ilatitude() const;
  inline void set_ilatitude(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:BVCU.PUConfig.DeviceInfo)
 private:
  inline void set_has_szid();
  inline void clear_has_szid();
  inline void set_has_szmanufacturer();
  inline void clear_has_szmanufacturer();
  inline void set_has_szproductname();
  inline void clear_has_szproductname();
  inline void set_has_szsoftwareversion();
  inline void clear_has_szsoftwareversion();
  inline void set_has_szhardwareversion();
  inline void clear_has_szhardwareversion();
  inline void set_has_iputype();
  inline void clear_has_iputype();
  inline void set_has_ilanguageindex();
  inline void clear_has_ilanguageindex();
  inline void set_has_szname();
  inline void clear_has_szname();
  inline void set_has_iwificount();
  inline void clear_has_iwificount();
  inline void set_has_iradiocount();
  inline void clear_has_iradiocount();
  inline void set_has_ichannelcount();
  inline void clear_has_ichannelcount();
  inline void set_has_ivideoincount();
  inline void clear_has_ivideoincount();
  inline void set_has_iaudioincount();
  inline void clear_has_iaudioincount();
  inline void set_has_iaudiooutcount();
  inline void clear_has_iaudiooutcount();
  inline void set_has_iptzcount();
  inline void clear_has_iptzcount();
  inline void set_has_iserialportcount();
  inline void clear_has_iserialportcount();
  inline void set_has_ialertincount();
  inline void clear_has_ialertincount();
  inline void set_has_ialertoutcount();
  inline void clear_has_ialertoutcount();
  inline void set_has_istoragecount();
  inline void clear_has_istoragecount();
  inline void set_has_igpscount();
  inline void clear_has_igpscount();
  inline void set_has_bsupportsms();
  inline void clear_has_bsupportsms();
  inline void set_has_ipresetcount();
  inline void clear_has_ipresetcount();
  inline void set_has_icruisecount();
  inline void clear_has_icruisecount();
  inline void set_has_ialarmlinkactioncount();
  inline void clear_has_ialarmlinkactioncount();
  inline void set_has_ilongitude();
  inline void clear_has_ilongitude();
  inline void set_has_ilatitude();
  inline void clear_has_ilatitude();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* szid_;
  ::std::string* szmanufacturer_;
  ::std::string* szproductname_;
  static const ::std::string _default_szproductname_;
  ::std::string* szsoftwareversion_;
  static const ::std::string _default_szsoftwareversion_;
  ::std::string* szhardwareversion_;
  static const ::std::string _default_szhardwareversion_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > ilanguage_;
  ::google::protobuf::uint32 iputype_;
  ::google::protobuf::uint32 ilanguageindex_;
  ::std::string* szname_;
  ::google::protobuf::uint32 iwificount_;
  ::google::protobuf::uint32 iradiocount_;
  ::google::protobuf::uint32 ichannelcount_;
  ::google::protobuf::uint32 ivideoincount_;
  ::google::protobuf::uint32 iaudioincount_;
  ::google::protobuf::uint32 iaudiooutcount_;
  ::google::protobuf::uint32 iptzcount_;
  ::google::protobuf::uint32 iserialportcount_;
  ::google::protobuf::uint32 ialertincount_;
  ::google::protobuf::uint32 ialertoutcount_;
  ::google::protobuf::uint32 istoragecount_;
  ::google::protobuf::uint32 igpscount_;
  ::google::protobuf::uint32 bsupportsms_;
  ::google::protobuf::uint32 ipresetcount_;
  ::google::protobuf::uint32 icruisecount_;
  ::google::protobuf::uint32 ialarmlinkactioncount_;
  ::google::protobuf::int32 ilongitude_;
  ::google::protobuf::int32 ilatitude_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(27 + 31) / 32];
  
  friend void  protobuf_AddDesc_PUConfig_2eproto();
  friend void protobuf_AssignDesc_PUConfig_2eproto();
  friend void protobuf_ShutdownFile_PUConfig_2eproto();
  
  void InitAsDefaultInstance();
  static DeviceInfo* default_instance_;
};
// -------------------------------------------------------------------

class UpdateStatus : public ::google::protobuf::Message {
 public:
  UpdateStatus();
  virtual ~UpdateStatus();
  
  UpdateStatus(const UpdateStatus& from);
  
  inline UpdateStatus& operator=(const UpdateStatus& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const UpdateStatus& default_instance();
  
  void Swap(UpdateStatus* other);
  
  // implements Message ----------------------------------------------
  
  UpdateStatus* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UpdateStatus& from);
  void MergeFrom(const UpdateStatus& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional uint32 iDownloadPercent = 1;
  inline bool has_idownloadpercent() const;
  inline void clear_idownloadpercent();
  static const int kIDownloadPercentFieldNumber = 1;
  inline ::google::protobuf::uint32 idownloadpercent() const;
  inline void set_idownloadpercent(::google::protobuf::uint32 value);
  
  // optional uint32 iSpeed = 2;
  inline bool has_ispeed() const;
  inline void clear_ispeed();
  static const int kISpeedFieldNumber = 2;
  inline ::google::protobuf::uint32 ispeed() const;
  inline void set_ispeed(::google::protobuf::uint32 value);
  
  // optional string szSoftwareVersion = 3;
  inline bool has_szsoftwareversion() const;
  inline void clear_szsoftwareversion();
  static const int kSzSoftwareVersionFieldNumber = 3;
  inline const ::std::string& szsoftwareversion() const;
  inline void set_szsoftwareversion(const ::std::string& value);
  inline void set_szsoftwareversion(const char* value);
  inline void set_szsoftwareversion(const char* value, size_t size);
  inline ::std::string* mutable_szsoftwareversion();
  inline ::std::string* release_szsoftwareversion();
  
  // optional .BVCU.PUConfig.WallTime stUpdateFinishTime = 4;
  inline bool has_stupdatefinishtime() const;
  inline void clear_stupdatefinishtime();
  static const int kStUpdateFinishTimeFieldNumber = 4;
  inline const ::BVCU::PUConfig::WallTime& stupdatefinishtime() const;
  inline ::BVCU::PUConfig::WallTime* mutable_stupdatefinishtime();
  inline ::BVCU::PUConfig::WallTime* release_stupdatefinishtime();
  
  // @@protoc_insertion_point(class_scope:BVCU.PUConfig.UpdateStatus)
 private:
  inline void set_has_idownloadpercent();
  inline void clear_has_idownloadpercent();
  inline void set_has_ispeed();
  inline void clear_has_ispeed();
  inline void set_has_szsoftwareversion();
  inline void clear_has_szsoftwareversion();
  inline void set_has_stupdatefinishtime();
  inline void clear_has_stupdatefinishtime();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint32 idownloadpercent_;
  ::google::protobuf::uint32 ispeed_;
  ::std::string* szsoftwareversion_;
  ::BVCU::PUConfig::WallTime* stupdatefinishtime_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_PUConfig_2eproto();
  friend void protobuf_AssignDesc_PUConfig_2eproto();
  friend void protobuf_ShutdownFile_PUConfig_2eproto();
  
  void InitAsDefaultInstance();
  static UpdateStatus* default_instance_;
};
// -------------------------------------------------------------------

class Upgrade : public ::google::protobuf::Message {
 public:
  Upgrade();
  virtual ~Upgrade();
  
  Upgrade(const Upgrade& from);
  
  inline Upgrade& operator=(const Upgrade& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Upgrade& default_instance();
  
  void Swap(Upgrade* other);
  
  // implements Message ----------------------------------------------
  
  Upgrade* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Upgrade& from);
  void MergeFrom(const Upgrade& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string szFTPID = 1;
  inline bool has_szftpid() const;
  inline void clear_szftpid();
  static const int kSzFTPIDFieldNumber = 1;
  inline const ::std::string& szftpid() const;
  inline void set_szftpid(const ::std::string& value);
  inline void set_szftpid(const char* value);
  inline void set_szftpid(const char* value, size_t size);
  inline ::std::string* mutable_szftpid();
  inline ::std::string* release_szftpid();
  
  // optional string szFilePath = 2;
  inline bool has_szfilepath() const;
  inline void clear_szfilepath();
  static const int kSzFilePathFieldNumber = 2;
  inline const ::std::string& szfilepath() const;
  inline void set_szfilepath(const ::std::string& value);
  inline void set_szfilepath(const char* value);
  inline void set_szfilepath(const char* value, size_t size);
  inline ::std::string* mutable_szfilepath();
  inline ::std::string* release_szfilepath();
  
  // optional string szFileName = 3;
  inline bool has_szfilename() const;
  inline void clear_szfilename();
  static const int kSzFileNameFieldNumber = 3;
  inline const ::std::string& szfilename() const;
  inline void set_szfilename(const ::std::string& value);
  inline void set_szfilename(const char* value);
  inline void set_szfilename(const char* value, size_t size);
  inline ::std::string* mutable_szfilename();
  inline ::std::string* release_szfilename();
  
  // optional uint32 bPromptly = 4;
  inline bool has_bpromptly() const;
  inline void clear_bpromptly();
  static const int kBPromptlyFieldNumber = 4;
  inline ::google::protobuf::uint32 bpromptly() const;
  inline void set_bpromptly(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:BVCU.PUConfig.Upgrade)
 private:
  inline void set_has_szftpid();
  inline void clear_has_szftpid();
  inline void set_has_szfilepath();
  inline void clear_has_szfilepath();
  inline void set_has_szfilename();
  inline void clear_has_szfilename();
  inline void set_has_bpromptly();
  inline void clear_has_bpromptly();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* szftpid_;
  ::std::string* szfilepath_;
  ::std::string* szfilename_;
  ::google::protobuf::uint32 bpromptly_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_PUConfig_2eproto();
  friend void protobuf_AssignDesc_PUConfig_2eproto();
  friend void protobuf_ShutdownFile_PUConfig_2eproto();
  
  void InitAsDefaultInstance();
  static Upgrade* default_instance_;
};
// -------------------------------------------------------------------

class GroupInfo : public ::google::protobuf::Message {
 public:
  GroupInfo();
  virtual ~GroupInfo();
  
  GroupInfo(const GroupInfo& from);
  
  inline GroupInfo& operator=(const GroupInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GroupInfo& default_instance();
  
  void Swap(GroupInfo* other);
  
  // implements Message ----------------------------------------------
  
  GroupInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GroupInfo& from);
  void MergeFrom(const GroupInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string szID = 1;
  inline bool has_szid() const;
  inline void clear_szid();
  static const int kSzIDFieldNumber = 1;
  inline const ::std::string& szid() const;
  inline void set_szid(const ::std::string& value);
  inline void set_szid(const char* value);
  inline void set_szid(const char* value, size_t size);
  inline ::std::string* mutable_szid();
  inline ::std::string* release_szid();
  
  // optional string szName = 2;
  inline bool has_szname() const;
  inline void clear_szname();
  static const int kSzNameFieldNumber = 2;
  inline const ::std::string& szname() const;
  inline void set_szname(const ::std::string& value);
  inline void set_szname(const char* value);
  inline void set_szname(const char* value, size_t size);
  inline ::std::string* mutable_szname();
  inline ::std::string* release_szname();
  
  // optional string szParentID = 3;
  inline bool has_szparentid() const;
  inline void clear_szparentid();
  static const int kSzParentIDFieldNumber = 3;
  inline const ::std::string& szparentid() const;
  inline void set_szparentid(const ::std::string& value);
  inline void set_szparentid(const char* value);
  inline void set_szparentid(const char* value, size_t size);
  inline ::std::string* mutable_szparentid();
  inline ::std::string* release_szparentid();
  
  // optional string szDescription = 4;
  inline bool has_szdescription() const;
  inline void clear_szdescription();
  static const int kSzDescriptionFieldNumber = 4;
  inline const ::std::string& szdescription() const;
  inline void set_szdescription(const ::std::string& value);
  inline void set_szdescription(const char* value);
  inline void set_szdescription(const char* value, size_t size);
  inline ::std::string* mutable_szdescription();
  inline ::std::string* release_szdescription();
  
  // repeated string pPUID = 5;
  inline int ppuid_size() const;
  inline void clear_ppuid();
  static const int kPPUIDFieldNumber = 5;
  inline const ::std::string& ppuid(int index) const;
  inline ::std::string* mutable_ppuid(int index);
  inline void set_ppuid(int index, const ::std::string& value);
  inline void set_ppuid(int index, const char* value);
  inline void set_ppuid(int index, const char* value, size_t size);
  inline ::std::string* add_ppuid();
  inline void add_ppuid(const ::std::string& value);
  inline void add_ppuid(const char* value);
  inline void add_ppuid(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& ppuid() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_ppuid();
  
  // @@protoc_insertion_point(class_scope:BVCU.PUConfig.GroupInfo)
 private:
  inline void set_has_szid();
  inline void clear_has_szid();
  inline void set_has_szname();
  inline void clear_has_szname();
  inline void set_has_szparentid();
  inline void clear_has_szparentid();
  inline void set_has_szdescription();
  inline void clear_has_szdescription();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* szid_;
  ::std::string* szname_;
  ::std::string* szparentid_;
  ::std::string* szdescription_;
  ::google::protobuf::RepeatedPtrField< ::std::string> ppuid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_PUConfig_2eproto();
  friend void protobuf_AssignDesc_PUConfig_2eproto();
  friend void protobuf_ShutdownFile_PUConfig_2eproto();
  
  void InitAsDefaultInstance();
  static GroupInfo* default_instance_;
};
// -------------------------------------------------------------------

class Power : public ::google::protobuf::Message {
 public:
  Power();
  virtual ~Power();
  
  Power(const Power& from);
  
  inline Power& operator=(const Power& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Power& default_instance();
  
  void Swap(Power* other);
  
  // implements Message ----------------------------------------------
  
  Power* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Power& from);
  void MergeFrom(const Power& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional uint32 iTurnOffDelay = 1;
  inline bool has_iturnoffdelay() const;
  inline void clear_iturnoffdelay();
  static const int kITurnOffDelayFieldNumber = 1;
  inline ::google::protobuf::uint32 iturnoffdelay() const;
  inline void set_iturnoffdelay(::google::protobuf::uint32 value);
  
  // optional uint32 bEnableTimer = 2;
  inline bool has_benabletimer() const;
  inline void clear_benabletimer();
  static const int kBEnableTimerFieldNumber = 2;
  inline ::google::protobuf::uint32 benabletimer() const;
  inline void set_benabletimer(::google::protobuf::uint32 value);
  
  // optional .BVCU.PUConfig.WeekTimeSlice stTurnOn = 3;
  inline bool has_stturnon() const;
  inline void clear_stturnon();
  static const int kStTurnOnFieldNumber = 3;
  inline const ::BVCU::PUConfig::WeekTimeSlice& stturnon() const;
  inline ::BVCU::PUConfig::WeekTimeSlice* mutable_stturnon();
  inline ::BVCU::PUConfig::WeekTimeSlice* release_stturnon();
  
  // @@protoc_insertion_point(class_scope:BVCU.PUConfig.Power)
 private:
  inline void set_has_iturnoffdelay();
  inline void clear_has_iturnoffdelay();
  inline void set_has_benabletimer();
  inline void clear_has_benabletimer();
  inline void set_has_stturnon();
  inline void clear_has_stturnon();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint32 iturnoffdelay_;
  ::google::protobuf::uint32 benabletimer_;
  ::BVCU::PUConfig::WeekTimeSlice* stturnon_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_PUConfig_2eproto();
  friend void protobuf_AssignDesc_PUConfig_2eproto();
  friend void protobuf_ShutdownFile_PUConfig_2eproto();
  
  void InitAsDefaultInstance();
  static Power* default_instance_;
};
// -------------------------------------------------------------------

class VideoColorCtl : public ::google::protobuf::Message {
 public:
  VideoColorCtl();
  virtual ~VideoColorCtl();
  
  VideoColorCtl(const VideoColorCtl& from);
  
  inline VideoColorCtl& operator=(const VideoColorCtl& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const VideoColorCtl& default_instance();
  
  void Swap(VideoColorCtl* other);
  
  // implements Message ----------------------------------------------
  
  VideoColorCtl* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const VideoColorCtl& from);
  void MergeFrom(const VideoColorCtl& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional .BVCU.PUConfig.DayTimeSlice stTime = 1;
  inline bool has_sttime() const;
  inline void clear_sttime();
  static const int kStTimeFieldNumber = 1;
  inline const ::BVCU::PUConfig::DayTimeSlice& sttime() const;
  inline ::BVCU::PUConfig::DayTimeSlice* mutable_sttime();
  inline ::BVCU::PUConfig::DayTimeSlice* release_sttime();
  
  // optional uint32 cBrightness = 2;
  inline bool has_cbrightness() const;
  inline void clear_cbrightness();
  static const int kCBrightnessFieldNumber = 2;
  inline ::google::protobuf::uint32 cbrightness() const;
  inline void set_cbrightness(::google::protobuf::uint32 value);
  
  // optional uint32 cContrast = 3;
  inline bool has_ccontrast() const;
  inline void clear_ccontrast();
  static const int kCContrastFieldNumber = 3;
  inline ::google::protobuf::uint32 ccontrast() const;
  inline void set_ccontrast(::google::protobuf::uint32 value);
  
  // optional uint32 cSaturation = 4;
  inline bool has_csaturation() const;
  inline void clear_csaturation();
  static const int kCSaturationFieldNumber = 4;
  inline ::google::protobuf::uint32 csaturation() const;
  inline void set_csaturation(::google::protobuf::uint32 value);
  
  // optional uint32 cHue = 5;
  inline bool has_chue() const;
  inline void clear_chue();
  static const int kCHueFieldNumber = 5;
  inline ::google::protobuf::uint32 chue() const;
  inline void set_chue(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:BVCU.PUConfig.VideoColorCtl)
 private:
  inline void set_has_sttime();
  inline void clear_has_sttime();
  inline void set_has_cbrightness();
  inline void clear_has_cbrightness();
  inline void set_has_ccontrast();
  inline void clear_has_ccontrast();
  inline void set_has_csaturation();
  inline void clear_has_csaturation();
  inline void set_has_chue();
  inline void clear_has_chue();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::BVCU::PUConfig::DayTimeSlice* sttime_;
  ::google::protobuf::uint32 cbrightness_;
  ::google::protobuf::uint32 ccontrast_;
  ::google::protobuf::uint32 csaturation_;
  ::google::protobuf::uint32 chue_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_PUConfig_2eproto();
  friend void protobuf_AssignDesc_PUConfig_2eproto();
  friend void protobuf_ShutdownFile_PUConfig_2eproto();
  
  void InitAsDefaultInstance();
  static VideoColorCtl* default_instance_;
};
// -------------------------------------------------------------------

class MotionDetect : public ::google::protobuf::Message {
 public:
  MotionDetect();
  virtual ~MotionDetect();
  
  MotionDetect(const MotionDetect& from);
  
  inline MotionDetect& operator=(const MotionDetect& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MotionDetect& default_instance();
  
  void Swap(MotionDetect* other);
  
  // implements Message ----------------------------------------------
  
  MotionDetect* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MotionDetect& from);
  void MergeFrom(const MotionDetect& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional uint32 bSupport = 1;
  inline bool has_bsupport() const;
  inline void clear_bsupport();
  static const int kBSupportFieldNumber = 1;
  inline ::google::protobuf::uint32 bsupport() const;
  inline void set_bsupport(::google::protobuf::uint32 value);
  
  // repeated .BVCU.PUConfig.ImageRect rcROI = 2;
  inline int rcroi_size() const;
  inline void clear_rcroi();
  static const int kRcROIFieldNumber = 2;
  inline const ::BVCU::PUConfig::ImageRect& rcroi(int index) const;
  inline ::BVCU::PUConfig::ImageRect* mutable_rcroi(int index);
  inline ::BVCU::PUConfig::ImageRect* add_rcroi();
  inline const ::google::protobuf::RepeatedPtrField< ::BVCU::PUConfig::ImageRect >&
      rcroi() const;
  inline ::google::protobuf::RepeatedPtrField< ::BVCU::PUConfig::ImageRect >*
      mutable_rcroi();
  
  // optional uint32 iSensitivity = 3;
  inline bool has_isensitivity() const;
  inline void clear_isensitivity();
  static const int kISensitivityFieldNumber = 3;
  inline ::google::protobuf::uint32 isensitivity() const;
  inline void set_isensitivity(::google::protobuf::uint32 value);
  
  // optional uint32 iInterval = 4;
  inline bool has_iinterval() const;
  inline void clear_iinterval();
  static const int kIIntervalFieldNumber = 4;
  inline ::google::protobuf::uint32 iinterval() const;
  inline void set_iinterval(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:BVCU.PUConfig.MotionDetect)
 private:
  inline void set_has_bsupport();
  inline void clear_has_bsupport();
  inline void set_has_isensitivity();
  inline void clear_has_isensitivity();
  inline void set_has_iinterval();
  inline void clear_has_iinterval();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::BVCU::PUConfig::ImageRect > rcroi_;
  ::google::protobuf::uint32 bsupport_;
  ::google::protobuf::uint32 isensitivity_;
  ::google::protobuf::uint32 iinterval_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_PUConfig_2eproto();
  friend void protobuf_AssignDesc_PUConfig_2eproto();
  friend void protobuf_ShutdownFile_PUConfig_2eproto();
  
  void InitAsDefaultInstance();
  static MotionDetect* default_instance_;
};
// -------------------------------------------------------------------

class VideoShelter : public ::google::protobuf::Message {
 public:
  VideoShelter();
  virtual ~VideoShelter();
  
  VideoShelter(const VideoShelter& from);
  
  inline VideoShelter& operator=(const VideoShelter& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const VideoShelter& default_instance();
  
  void Swap(VideoShelter* other);
  
  // implements Message ----------------------------------------------
  
  VideoShelter* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const VideoShelter& from);
  void MergeFrom(const VideoShelter& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional uint32 bSupport = 1;
  inline bool has_bsupport() const;
  inline void clear_bsupport();
  static const int kBSupportFieldNumber = 1;
  inline ::google::protobuf::uint32 bsupport() const;
  inline void set_bsupport(::google::protobuf::uint32 value);
  
  // repeated .BVCU.PUConfig.ImageRect rcROI = 2;
  inline int rcroi_size() const;
  inline void clear_rcroi();
  static const int kRcROIFieldNumber = 2;
  inline const ::BVCU::PUConfig::ImageRect& rcroi(int index) const;
  inline ::BVCU::PUConfig::ImageRect* mutable_rcroi(int index);
  inline ::BVCU::PUConfig::ImageRect* add_rcroi();
  inline const ::google::protobuf::RepeatedPtrField< ::BVCU::PUConfig::ImageRect >&
      rcroi() const;
  inline ::google::protobuf::RepeatedPtrField< ::BVCU::PUConfig::ImageRect >*
      mutable_rcroi();
  
  // @@protoc_insertion_point(class_scope:BVCU.PUConfig.VideoShelter)
 private:
  inline void set_has_bsupport();
  inline void clear_has_bsupport();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::BVCU::PUConfig::ImageRect > rcroi_;
  ::google::protobuf::uint32 bsupport_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_PUConfig_2eproto();
  friend void protobuf_AssignDesc_PUConfig_2eproto();
  friend void protobuf_ShutdownFile_PUConfig_2eproto();
  
  void InitAsDefaultInstance();
  static VideoShelter* default_instance_;
};
// -------------------------------------------------------------------

class VideoOcclusionDetect : public ::google::protobuf::Message {
 public:
  VideoOcclusionDetect();
  virtual ~VideoOcclusionDetect();
  
  VideoOcclusionDetect(const VideoOcclusionDetect& from);
  
  inline VideoOcclusionDetect& operator=(const VideoOcclusionDetect& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const VideoOcclusionDetect& default_instance();
  
  void Swap(VideoOcclusionDetect* other);
  
  // implements Message ----------------------------------------------
  
  VideoOcclusionDetect* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const VideoOcclusionDetect& from);
  void MergeFrom(const VideoOcclusionDetect& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional uint32 bSupport = 1;
  inline bool has_bsupport() const;
  inline void clear_bsupport();
  static const int kBSupportFieldNumber = 1;
  inline ::google::protobuf::uint32 bsupport() const;
  inline void set_bsupport(::google::protobuf::uint32 value);
  
  // repeated .BVCU.PUConfig.ImageRect rcROI = 2;
  inline int rcroi_size() const;
  inline void clear_rcroi();
  static const int kRcROIFieldNumber = 2;
  inline const ::BVCU::PUConfig::ImageRect& rcroi(int index) const;
  inline ::BVCU::PUConfig::ImageRect* mutable_rcroi(int index);
  inline ::BVCU::PUConfig::ImageRect* add_rcroi();
  inline const ::google::protobuf::RepeatedPtrField< ::BVCU::PUConfig::ImageRect >&
      rcroi() const;
  inline ::google::protobuf::RepeatedPtrField< ::BVCU::PUConfig::ImageRect >*
      mutable_rcroi();
  
  // @@protoc_insertion_point(class_scope:BVCU.PUConfig.VideoOcclusionDetect)
 private:
  inline void set_has_bsupport();
  inline void clear_has_bsupport();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::BVCU::PUConfig::ImageRect > rcroi_;
  ::google::protobuf::uint32 bsupport_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_PUConfig_2eproto();
  friend void protobuf_AssignDesc_PUConfig_2eproto();
  friend void protobuf_ShutdownFile_PUConfig_2eproto();
  
  void InitAsDefaultInstance();
  static VideoOcclusionDetect* default_instance_;
};
// -------------------------------------------------------------------

class VideoIn : public ::google::protobuf::Message {
 public:
  VideoIn();
  virtual ~VideoIn();
  
  VideoIn(const VideoIn& from);
  
  inline VideoIn& operator=(const VideoIn& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const VideoIn& default_instance();
  
  void Swap(VideoIn* other);
  
  // implements Message ----------------------------------------------
  
  VideoIn* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const VideoIn& from);
  void MergeFrom(const VideoIn& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .BVCU.PUConfig.VideoColorCtl stVCC = 1;
  inline int stvcc_size() const;
  inline void clear_stvcc();
  static const int kStVCCFieldNumber = 1;
  inline const ::BVCU::PUConfig::VideoColorCtl& stvcc(int index) const;
  inline ::BVCU::PUConfig::VideoColorCtl* mutable_stvcc(int index);
  inline ::BVCU::PUConfig::VideoColorCtl* add_stvcc();
  inline const ::google::protobuf::RepeatedPtrField< ::BVCU::PUConfig::VideoColorCtl >&
      stvcc() const;
  inline ::google::protobuf::RepeatedPtrField< ::BVCU::PUConfig::VideoColorCtl >*
      mutable_stvcc();
  
  // optional .BVCU.PUConfig.MotionDetect stMD = 2;
  inline bool has_stmd() const;
  inline void clear_stmd();
  static const int kStMDFieldNumber = 2;
  inline const ::BVCU::PUConfig::MotionDetect& stmd() const;
  inline ::BVCU::PUConfig::MotionDetect* mutable_stmd();
  inline ::BVCU::PUConfig::MotionDetect* release_stmd();
  
  // optional .BVCU.PUConfig.VideoShelter stShelter = 3;
  inline bool has_stshelter() const;
  inline void clear_stshelter();
  static const int kStShelterFieldNumber = 3;
  inline const ::BVCU::PUConfig::VideoShelter& stshelter() const;
  inline ::BVCU::PUConfig::VideoShelter* mutable_stshelter();
  inline ::BVCU::PUConfig::VideoShelter* release_stshelter();
  
  // optional .BVCU.PUConfig.VideoOcclusionDetect stOcclusion = 4;
  inline bool has_stocclusion() const;
  inline void clear_stocclusion();
  static const int kStOcclusionFieldNumber = 4;
  inline const ::BVCU::PUConfig::VideoOcclusionDetect& stocclusion() const;
  inline ::BVCU::PUConfig::VideoOcclusionDetect* mutable_stocclusion();
  inline ::BVCU::PUConfig::VideoOcclusionDetect* release_stocclusion();
  
  // repeated .BVCU.PUConfig.VideoFormat stVideoFormat = 5;
  inline int stvideoformat_size() const;
  inline void clear_stvideoformat();
  static const int kStVideoFormatFieldNumber = 5;
  inline const ::BVCU::PUConfig::VideoFormat& stvideoformat(int index) const;
  inline ::BVCU::PUConfig::VideoFormat* mutable_stvideoformat(int index);
  inline ::BVCU::PUConfig::VideoFormat* add_stvideoformat();
  inline const ::google::protobuf::RepeatedPtrField< ::BVCU::PUConfig::VideoFormat >&
      stvideoformat() const;
  inline ::google::protobuf::RepeatedPtrField< ::BVCU::PUConfig::VideoFormat >*
      mutable_stvideoformat();
  
  // optional uint32 iVideoFormatIndex = 6;
  inline bool has_ivideoformatindex() const;
  inline void clear_ivideoformatindex();
  static const int kIVideoFormatIndexFieldNumber = 6;
  inline ::google::protobuf::uint32 ivideoformatindex() const;
  inline void set_ivideoformatindex(::google::protobuf::uint32 value);
  
  // optional int32 iOSDIcon = 7;
  inline bool has_iosdicon() const;
  inline void clear_iosdicon();
  static const int kIOSDIconFieldNumber = 7;
  inline ::google::protobuf::int32 iosdicon() const;
  inline void set_iosdicon(::google::protobuf::int32 value);
  
  // optional string szOSDIcon = 8;
  inline bool has_szosdicon() const;
  inline void clear_szosdicon();
  static const int kSzOSDIconFieldNumber = 8;
  inline const ::std::string& szosdicon() const;
  inline void set_szosdicon(const ::std::string& value);
  inline void set_szosdicon(const char* value);
  inline void set_szosdicon(const char* value, size_t size);
  inline ::std::string* mutable_szosdicon();
  inline ::std::string* release_szosdicon();
  
  // optional .BVCU.PUConfig.ImagePos stOSDIconPos = 9;
  inline bool has_stosdiconpos() const;
  inline void clear_stosdiconpos();
  static const int kStOSDIconPosFieldNumber = 9;
  inline const ::BVCU::PUConfig::ImagePos& stosdiconpos() const;
  inline ::BVCU::PUConfig::ImagePos* mutable_stosdiconpos();
  inline ::BVCU::PUConfig::ImagePos* release_stosdiconpos();
  
  // optional string szOSDTitle = 10;
  inline bool has_szosdtitle() const;
  inline void clear_szosdtitle();
  static const int kSzOSDTitleFieldNumber = 10;
  inline const ::std::string& szosdtitle() const;
  inline void set_szosdtitle(const ::std::string& value);
  inline void set_szosdtitle(const char* value);
  inline void set_szosdtitle(const char* value, size_t size);
  inline ::std::string* mutable_szosdtitle();
  inline ::std::string* release_szosdtitle();
  
  // optional .BVCU.PUConfig.ImagePos stOSDTitlePos = 11;
  inline bool has_stosdtitlepos() const;
  inline void clear_stosdtitlepos();
  static const int kStOSDTitlePosFieldNumber = 11;
  inline const ::BVCU::PUConfig::ImagePos& stosdtitlepos() const;
  inline ::BVCU::PUConfig::ImagePos* mutable_stosdtitlepos();
  inline ::BVCU::PUConfig::ImagePos* release_stosdtitlepos();
  
  // optional uint32 iOSDTitleFontSize = 12;
  inline bool has_iosdtitlefontsize() const;
  inline void clear_iosdtitlefontsize();
  static const int kIOSDTitleFontSizeFieldNumber = 12;
  inline ::google::protobuf::uint32 iosdtitlefontsize() const;
  inline void set_iosdtitlefontsize(::google::protobuf::uint32 value);
  
  // optional uint32 cOSDTime = 13;
  inline bool has_cosdtime() const;
  inline void clear_cosdtime();
  static const int kCOSDTimeFieldNumber = 13;
  inline ::google::protobuf::uint32 cosdtime() const;
  inline void set_cosdtime(::google::protobuf::uint32 value);
  
  // optional uint32 cOSDTimeSplitChar = 14;
  inline bool has_cosdtimesplitchar() const;
  inline void clear_cosdtimesplitchar();
  static const int kCOSDTimeSplitCharFieldNumber = 14;
  inline ::google::protobuf::uint32 cosdtimesplitchar() const;
  inline void set_cosdtimesplitchar(::google::protobuf::uint32 value);
  
  // optional uint32 iOSDTimeFontSize = 15;
  inline bool has_iosdtimefontsize() const;
  inline void clear_iosdtimefontsize();
  static const int kIOSDTimeFontSizeFieldNumber = 15;
  inline ::google::protobuf::uint32 iosdtimefontsize() const;
  inline void set_iosdtimefontsize(::google::protobuf::uint32 value);
  
  // optional .BVCU.PUConfig.ImagePos stOSDTimePos = 16;
  inline bool has_stosdtimepos() const;
  inline void clear_stosdtimepos();
  static const int kStOSDTimePosFieldNumber = 16;
  inline const ::BVCU::PUConfig::ImagePos& stosdtimepos() const;
  inline ::BVCU::PUConfig::ImagePos* mutable_stosdtimepos();
  inline ::BVCU::PUConfig::ImagePos* release_stosdtimepos();
  
  // @@protoc_insertion_point(class_scope:BVCU.PUConfig.VideoIn)
 private:
  inline void set_has_stmd();
  inline void clear_has_stmd();
  inline void set_has_stshelter();
  inline void clear_has_stshelter();
  inline void set_has_stocclusion();
  inline void clear_has_stocclusion();
  inline void set_has_ivideoformatindex();
  inline void clear_has_ivideoformatindex();
  inline void set_has_iosdicon();
  inline void clear_has_iosdicon();
  inline void set_has_szosdicon();
  inline void clear_has_szosdicon();
  inline void set_has_stosdiconpos();
  inline void clear_has_stosdiconpos();
  inline void set_has_szosdtitle();
  inline void clear_has_szosdtitle();
  inline void set_has_stosdtitlepos();
  inline void clear_has_stosdtitlepos();
  inline void set_has_iosdtitlefontsize();
  inline void clear_has_iosdtitlefontsize();
  inline void set_has_cosdtime();
  inline void clear_has_cosdtime();
  inline void set_has_cosdtimesplitchar();
  inline void clear_has_cosdtimesplitchar();
  inline void set_has_iosdtimefontsize();
  inline void clear_has_iosdtimefontsize();
  inline void set_has_stosdtimepos();
  inline void clear_has_stosdtimepos();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::BVCU::PUConfig::VideoColorCtl > stvcc_;
  ::BVCU::PUConfig::MotionDetect* stmd_;
  ::BVCU::PUConfig::VideoShelter* stshelter_;
  ::BVCU::PUConfig::VideoOcclusionDetect* stocclusion_;
  ::google::protobuf::RepeatedPtrField< ::BVCU::PUConfig::VideoFormat > stvideoformat_;
  ::google::protobuf::uint32 ivideoformatindex_;
  ::google::protobuf::int32 iosdicon_;
  ::std::string* szosdicon_;
  ::BVCU::PUConfig::ImagePos* stosdiconpos_;
  ::std::string* szosdtitle_;
  ::BVCU::PUConfig::ImagePos* stosdtitlepos_;
  ::google::protobuf::uint32 iosdtitlefontsize_;
  ::google::protobuf::uint32 cosdtime_;
  ::google::protobuf::uint32 cosdtimesplitchar_;
  ::google::protobuf::uint32 iosdtimefontsize_;
  ::BVCU::PUConfig::ImagePos* stosdtimepos_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(16 + 31) / 32];
  
  friend void  protobuf_AddDesc_PUConfig_2eproto();
  friend void protobuf_AssignDesc_PUConfig_2eproto();
  friend void protobuf_ShutdownFile_PUConfig_2eproto();
  
  void InitAsDefaultInstance();
  static VideoIn* default_instance_;
};
// -------------------------------------------------------------------

class AudioIn : public ::google::protobuf::Message {
 public:
  AudioIn();
  virtual ~AudioIn();
  
  AudioIn(const AudioIn& from);
  
  inline AudioIn& operator=(const AudioIn& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const AudioIn& default_instance();
  
  void Swap(AudioIn* other);
  
  // implements Message ----------------------------------------------
  
  AudioIn* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AudioIn& from);
  void MergeFrom(const AudioIn& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional uint32 iInput = 1;
  inline bool has_iinput() const;
  inline void clear_iinput();
  static const int kIInputFieldNumber = 1;
  inline ::google::protobuf::uint32 iinput() const;
  inline void set_iinput(::google::protobuf::uint32 value);
  
  // optional uint32 iChannelCount = 2;
  inline bool has_ichannelcount() const;
  inline void clear_ichannelcount();
  static const int kIChannelCountFieldNumber = 2;
  inline ::google::protobuf::uint32 ichannelcount() const;
  inline void set_ichannelcount(::google::protobuf::uint32 value);
  
  // optional uint32 iSamplesPerSec = 3;
  inline bool has_isamplespersec() const;
  inline void clear_isamplespersec();
  static const int kISamplesPerSecFieldNumber = 3;
  inline ::google::protobuf::uint32 isamplespersec() const;
  inline void set_isamplespersec(::google::protobuf::uint32 value);
  
  // optional uint32 iBitsPerSample = 4;
  inline bool has_ibitspersample() const;
  inline void clear_ibitspersample();
  static const int kIBitsPerSampleFieldNumber = 4;
  inline ::google::protobuf::uint32 ibitspersample() const;
  inline void set_ibitspersample(::google::protobuf::uint32 value);
  
  // optional uint32 iVolume = 5;
  inline bool has_ivolume() const;
  inline void clear_ivolume();
  static const int kIVolumeFieldNumber = 5;
  inline ::google::protobuf::uint32 ivolume() const;
  inline void set_ivolume(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:BVCU.PUConfig.AudioIn)
 private:
  inline void set_has_iinput();
  inline void clear_has_iinput();
  inline void set_has_ichannelcount();
  inline void clear_has_ichannelcount();
  inline void set_has_isamplespersec();
  inline void clear_has_isamplespersec();
  inline void set_has_ibitspersample();
  inline void clear_has_ibitspersample();
  inline void set_has_ivolume();
  inline void clear_has_ivolume();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint32 iinput_;
  ::google::protobuf::uint32 ichannelcount_;
  ::google::protobuf::uint32 isamplespersec_;
  ::google::protobuf::uint32 ibitspersample_;
  ::google::protobuf::uint32 ivolume_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_PUConfig_2eproto();
  friend void protobuf_AssignDesc_PUConfig_2eproto();
  friend void protobuf_ShutdownFile_PUConfig_2eproto();
  
  void InitAsDefaultInstance();
  static AudioIn* default_instance_;
};
// -------------------------------------------------------------------

class AudioDecoderParam : public ::google::protobuf::Message {
 public:
  AudioDecoderParam();
  virtual ~AudioDecoderParam();
  
  AudioDecoderParam(const AudioDecoderParam& from);
  
  inline AudioDecoderParam& operator=(const AudioDecoderParam& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const AudioDecoderParam& default_instance();
  
  void Swap(AudioDecoderParam* other);
  
  // implements Message ----------------------------------------------
  
  AudioDecoderParam* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AudioDecoderParam& from);
  void MergeFrom(const AudioDecoderParam& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional uint32 bEnable = 1;
  inline bool has_benable() const;
  inline void clear_benable();
  static const int kBEnableFieldNumber = 1;
  inline ::google::protobuf::uint32 benable() const;
  inline void set_benable(::google::protobuf::uint32 value);
  
  // repeated uint32 iAudioCodecAll = 2;
  inline int iaudiocodecall_size() const;
  inline void clear_iaudiocodecall();
  static const int kIAudioCodecAllFieldNumber = 2;
  inline ::google::protobuf::uint32 iaudiocodecall(int index) const;
  inline void set_iaudiocodecall(int index, ::google::protobuf::uint32 value);
  inline void add_iaudiocodecall(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      iaudiocodecall() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_iaudiocodecall();
  
  // optional uint32 iAudioCodecIndex = 3;
  inline bool has_iaudiocodecindex() const;
  inline void clear_iaudiocodecindex();
  static const int kIAudioCodecIndexFieldNumber = 3;
  inline ::google::protobuf::uint32 iaudiocodecindex() const;
  inline void set_iaudiocodecindex(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:BVCU.PUConfig.AudioDecoderParam)
 private:
  inline void set_has_benable();
  inline void clear_has_benable();
  inline void set_has_iaudiocodecindex();
  inline void clear_has_iaudiocodecindex();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > iaudiocodecall_;
  ::google::protobuf::uint32 benable_;
  ::google::protobuf::uint32 iaudiocodecindex_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_PUConfig_2eproto();
  friend void protobuf_AssignDesc_PUConfig_2eproto();
  friend void protobuf_ShutdownFile_PUConfig_2eproto();
  
  void InitAsDefaultInstance();
  static AudioDecoderParam* default_instance_;
};
// -------------------------------------------------------------------

class AudioOut : public ::google::protobuf::Message {
 public:
  AudioOut();
  virtual ~AudioOut();
  
  AudioOut(const AudioOut& from);
  
  inline AudioOut& operator=(const AudioOut& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const AudioOut& default_instance();
  
  void Swap(AudioOut* other);
  
  // implements Message ----------------------------------------------
  
  AudioOut* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AudioOut& from);
  void MergeFrom(const AudioOut& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional .BVCU.PUConfig.AudioDecoderParam stADParam = 1;
  inline bool has_stadparam() const;
  inline void clear_stadparam();
  static const int kStADParamFieldNumber = 1;
  inline const ::BVCU::PUConfig::AudioDecoderParam& stadparam() const;
  inline ::BVCU::PUConfig::AudioDecoderParam* mutable_stadparam();
  inline ::BVCU::PUConfig::AudioDecoderParam* release_stadparam();
  
  // optional uint32 iChannelCount = 2;
  inline bool has_ichannelcount() const;
  inline void clear_ichannelcount();
  static const int kIChannelCountFieldNumber = 2;
  inline ::google::protobuf::uint32 ichannelcount() const;
  inline void set_ichannelcount(::google::protobuf::uint32 value);
  
  // optional uint32 iSamplesPerSec = 3;
  inline bool has_isamplespersec() const;
  inline void clear_isamplespersec();
  static const int kISamplesPerSecFieldNumber = 3;
  inline ::google::protobuf::uint32 isamplespersec() const;
  inline void set_isamplespersec(::google::protobuf::uint32 value);
  
  // optional uint32 iBitsPerSample = 4;
  inline bool has_ibitspersample() const;
  inline void clear_ibitspersample();
  static const int kIBitsPerSampleFieldNumber = 4;
  inline ::google::protobuf::uint32 ibitspersample() const;
  inline void set_ibitspersample(::google::protobuf::uint32 value);
  
  // optional uint32 iVolume = 5;
  inline bool has_ivolume() const;
  inline void clear_ivolume();
  static const int kIVolumeFieldNumber = 5;
  inline ::google::protobuf::uint32 ivolume() const;
  inline void set_ivolume(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:BVCU.PUConfig.AudioOut)
 private:
  inline void set_has_stadparam();
  inline void clear_has_stadparam();
  inline void set_has_ichannelcount();
  inline void clear_has_ichannelcount();
  inline void set_has_isamplespersec();
  inline void clear_has_isamplespersec();
  inline void set_has_ibitspersample();
  inline void clear_has_ibitspersample();
  inline void set_has_ivolume();
  inline void clear_has_ivolume();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::BVCU::PUConfig::AudioDecoderParam* stadparam_;
  ::google::protobuf::uint32 ichannelcount_;
  ::google::protobuf::uint32 isamplespersec_;
  ::google::protobuf::uint32 ibitspersample_;
  ::google::protobuf::uint32 ivolume_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_PUConfig_2eproto();
  friend void protobuf_AssignDesc_PUConfig_2eproto();
  friend void protobuf_ShutdownFile_PUConfig_2eproto();
  
  void InitAsDefaultInstance();
  static AudioOut* default_instance_;
};
// -------------------------------------------------------------------

class AlertIn : public ::google::protobuf::Message {
 public:
  AlertIn();
  virtual ~AlertIn();
  
  AlertIn(const AlertIn& from);
  
  inline AlertIn& operator=(const AlertIn& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const AlertIn& default_instance();
  
  void Swap(AlertIn* other);
  
  // implements Message ----------------------------------------------
  
  AlertIn* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AlertIn& from);
  void MergeFrom(const AlertIn& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional uint32 bType = 1;
  inline bool has_btype() const;
  inline void clear_btype();
  static const int kBTypeFieldNumber = 1;
  inline ::google::protobuf::uint32 btype() const;
  inline void set_btype(::google::protobuf::uint32 value);
  
  // optional uint32 iInterval = 2;
  inline bool has_iinterval() const;
  inline void clear_iinterval();
  static const int kIIntervalFieldNumber = 2;
  inline ::google::protobuf::uint32 iinterval() const;
  inline void set_iinterval(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:BVCU.PUConfig.AlertIn)
 private:
  inline void set_has_btype();
  inline void clear_has_btype();
  inline void set_has_iinterval();
  inline void clear_has_iinterval();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint32 btype_;
  ::google::protobuf::uint32 iinterval_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_PUConfig_2eproto();
  friend void protobuf_AssignDesc_PUConfig_2eproto();
  friend void protobuf_ShutdownFile_PUConfig_2eproto();
  
  void InitAsDefaultInstance();
  static AlertIn* default_instance_;
};
// -------------------------------------------------------------------

class AlertOut : public ::google::protobuf::Message {
 public:
  AlertOut();
  virtual ~AlertOut();
  
  AlertOut(const AlertOut& from);
  
  inline AlertOut& operator=(const AlertOut& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const AlertOut& default_instance();
  
  void Swap(AlertOut* other);
  
  // implements Message ----------------------------------------------
  
  AlertOut* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AlertOut& from);
  void MergeFrom(const AlertOut& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional uint32 bAction = 1;
  inline bool has_baction() const;
  inline void clear_baction();
  static const int kBActionFieldNumber = 1;
  inline ::google::protobuf::uint32 baction() const;
  inline void set_baction(::google::protobuf::uint32 value);
  
  // optional uint32 iDuration = 2;
  inline bool has_iduration() const;
  inline void clear_iduration();
  static const int kIDurationFieldNumber = 2;
  inline ::google::protobuf::uint32 iduration() const;
  inline void set_iduration(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:BVCU.PUConfig.AlertOut)
 private:
  inline void set_has_baction();
  inline void clear_has_baction();
  inline void set_has_iduration();
  inline void clear_has_iduration();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint32 baction_;
  ::google::protobuf::uint32 iduration_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_PUConfig_2eproto();
  friend void protobuf_AssignDesc_PUConfig_2eproto();
  friend void protobuf_ShutdownFile_PUConfig_2eproto();
  
  void InitAsDefaultInstance();
  static AlertOut* default_instance_;
};
// -------------------------------------------------------------------

class GPSParam : public ::google::protobuf::Message {
 public:
  GPSParam();
  virtual ~GPSParam();
  
  GPSParam(const GPSParam& from);
  
  inline GPSParam& operator=(const GPSParam& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GPSParam& default_instance();
  
  void Swap(GPSParam* other);
  
  // implements Message ----------------------------------------------
  
  GPSParam* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GPSParam& from);
  void MergeFrom(const GPSParam& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional uint32 bEnable = 1;
  inline bool has_benable() const;
  inline void clear_benable();
  static const int kBEnableFieldNumber = 1;
  inline ::google::protobuf::uint32 benable() const;
  inline void set_benable(::google::protobuf::uint32 value);
  
  // optional uint32 iReportInterval = 2;
  inline bool has_ireportinterval() const;
  inline void clear_ireportinterval();
  static const int kIReportIntervalFieldNumber = 2;
  inline ::google::protobuf::uint32 ireportinterval() const;
  inline void set_ireportinterval(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:BVCU.PUConfig.GPSParam)
 private:
  inline void set_has_benable();
  inline void clear_has_benable();
  inline void set_has_ireportinterval();
  inline void clear_has_ireportinterval();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint32 benable_;
  ::google::protobuf::uint32 ireportinterval_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_PUConfig_2eproto();
  friend void protobuf_AssignDesc_PUConfig_2eproto();
  friend void protobuf_ShutdownFile_PUConfig_2eproto();
  
  void InitAsDefaultInstance();
  static GPSParam* default_instance_;
};
// -------------------------------------------------------------------

class GPSData : public ::google::protobuf::Message {
 public:
  GPSData();
  virtual ~GPSData();
  
  GPSData(const GPSData& from);
  
  inline GPSData& operator=(const GPSData& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GPSData& default_instance();
  
  void Swap(GPSData* other);
  
  // implements Message ----------------------------------------------
  
  GPSData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GPSData& from);
  void MergeFrom(const GPSData& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional .BVCU.PUConfig.WallTime stTime = 1;
  inline bool has_sttime() const;
  inline void clear_sttime();
  static const int kStTimeFieldNumber = 1;
  inline const ::BVCU::PUConfig::WallTime& sttime() const;
  inline ::BVCU::PUConfig::WallTime* mutable_sttime();
  inline ::BVCU::PUConfig::WallTime* release_sttime();
  
  // optional uint32 iLongitude = 2;
  inline bool has_ilongitude() const;
  inline void clear_ilongitude();
  static const int kILongitudeFieldNumber = 2;
  inline ::google::protobuf::uint32 ilongitude() const;
  inline void set_ilongitude(::google::protobuf::uint32 value);
  
  // optional uint32 iLatitude = 3;
  inline bool has_ilatitude() const;
  inline void clear_ilatitude();
  static const int kILatitudeFieldNumber = 3;
  inline ::google::protobuf::uint32 ilatitude() const;
  inline void set_ilatitude(::google::protobuf::uint32 value);
  
  // optional uint32 iHeight = 4;
  inline bool has_iheight() const;
  inline void clear_iheight();
  static const int kIHeightFieldNumber = 4;
  inline ::google::protobuf::uint32 iheight() const;
  inline void set_iheight(::google::protobuf::uint32 value);
  
  // optional uint32 iAngle = 5;
  inline bool has_iangle() const;
  inline void clear_iangle();
  static const int kIAngleFieldNumber = 5;
  inline ::google::protobuf::uint32 iangle() const;
  inline void set_iangle(::google::protobuf::uint32 value);
  
  // optional uint32 iSpeed = 6;
  inline bool has_ispeed() const;
  inline void clear_ispeed();
  static const int kISpeedFieldNumber = 6;
  inline ::google::protobuf::uint32 ispeed() const;
  inline void set_ispeed(::google::protobuf::uint32 value);
  
  // optional uint32 iStarCount = 7;
  inline bool has_istarcount() const;
  inline void clear_istarcount();
  static const int kIStarCountFieldNumber = 7;
  inline ::google::protobuf::uint32 istarcount() const;
  inline void set_istarcount(::google::protobuf::uint32 value);
  
  // optional uint32 bAntennaState = 8;
  inline bool has_bantennastate() const;
  inline void clear_bantennastate();
  static const int kBAntennaStateFieldNumber = 8;
  inline ::google::protobuf::uint32 bantennastate() const;
  inline void set_bantennastate(::google::protobuf::uint32 value);
  
  // optional uint32 bOrientationState = 9;
  inline bool has_borientationstate() const;
  inline void clear_borientationstate();
  static const int kBOrientationStateFieldNumber = 9;
  inline ::google::protobuf::uint32 borientationstate() const;
  inline void set_borientationstate(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:BVCU.PUConfig.GPSData)
 private:
  inline void set_has_sttime();
  inline void clear_has_sttime();
  inline void set_has_ilongitude();
  inline void clear_has_ilongitude();
  inline void set_has_ilatitude();
  inline void clear_has_ilatitude();
  inline void set_has_iheight();
  inline void clear_has_iheight();
  inline void set_has_iangle();
  inline void clear_has_iangle();
  inline void set_has_ispeed();
  inline void clear_has_ispeed();
  inline void set_has_istarcount();
  inline void clear_has_istarcount();
  inline void set_has_bantennastate();
  inline void clear_has_bantennastate();
  inline void set_has_borientationstate();
  inline void clear_has_borientationstate();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::BVCU::PUConfig::WallTime* sttime_;
  ::google::protobuf::uint32 ilongitude_;
  ::google::protobuf::uint32 ilatitude_;
  ::google::protobuf::uint32 iheight_;
  ::google::protobuf::uint32 iangle_;
  ::google::protobuf::uint32 ispeed_;
  ::google::protobuf::uint32 istarcount_;
  ::google::protobuf::uint32 bantennastate_;
  ::google::protobuf::uint32 borientationstate_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];
  
  friend void  protobuf_AddDesc_PUConfig_2eproto();
  friend void protobuf_AssignDesc_PUConfig_2eproto();
  friend void protobuf_ShutdownFile_PUConfig_2eproto();
  
  void InitAsDefaultInstance();
  static GPSData* default_instance_;
};
// -------------------------------------------------------------------

class SnapshotParam : public ::google::protobuf::Message {
 public:
  SnapshotParam();
  virtual ~SnapshotParam();
  
  SnapshotParam(const SnapshotParam& from);
  
  inline SnapshotParam& operator=(const SnapshotParam& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const SnapshotParam& default_instance();
  
  void Swap(SnapshotParam* other);
  
  // implements Message ----------------------------------------------
  
  SnapshotParam* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SnapshotParam& from);
  void MergeFrom(const SnapshotParam& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional .BVCU.PUConfig.ImageSize iImageSize = 1;
  inline bool has_iimagesize() const;
  inline void clear_iimagesize();
  static const int kIImageSizeFieldNumber = 1;
  inline const ::BVCU::PUConfig::ImageSize& iimagesize() const;
  inline ::BVCU::PUConfig::ImageSize* mutable_iimagesize();
  inline ::BVCU::PUConfig::ImageSize* release_iimagesize();
  
  // optional uint32 iQuality = 2;
  inline bool has_iquality() const;
  inline void clear_iquality();
  static const int kIQualityFieldNumber = 2;
  inline ::google::protobuf::uint32 iquality() const;
  inline void set_iquality(::google::protobuf::uint32 value);
  
  // optional uint32 iSequencePicCount = 3;
  inline bool has_isequencepiccount() const;
  inline void clear_isequencepiccount();
  static const int kISequencePicCountFieldNumber = 3;
  inline ::google::protobuf::uint32 isequencepiccount() const;
  inline void set_isequencepiccount(::google::protobuf::uint32 value);
  
  // optional uint32 iSequenceInterval = 4;
  inline bool has_isequenceinterval() const;
  inline void clear_isequenceinterval();
  static const int kISequenceIntervalFieldNumber = 4;
  inline ::google::protobuf::uint32 isequenceinterval() const;
  inline void set_isequenceinterval(::google::protobuf::uint32 value);
  
  // optional uint32 iSequenceDelay = 5;
  inline bool has_isequencedelay() const;
  inline void clear_isequencedelay();
  static const int kISequenceDelayFieldNumber = 5;
  inline ::google::protobuf::uint32 isequencedelay() const;
  inline void set_isequencedelay(::google::protobuf::uint32 value);
  
  // optional uint32 iOverlay = 6;
  inline bool has_ioverlay() const;
  inline void clear_ioverlay();
  static const int kIOverlayFieldNumber = 6;
  inline ::google::protobuf::uint32 ioverlay() const;
  inline void set_ioverlay(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:BVCU.PUConfig.SnapshotParam)
 private:
  inline void set_has_iimagesize();
  inline void clear_has_iimagesize();
  inline void set_has_iquality();
  inline void clear_has_iquality();
  inline void set_has_isequencepiccount();
  inline void clear_has_isequencepiccount();
  inline void set_has_isequenceinterval();
  inline void clear_has_isequenceinterval();
  inline void set_has_isequencedelay();
  inline void clear_has_isequencedelay();
  inline void set_has_ioverlay();
  inline void clear_has_ioverlay();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::BVCU::PUConfig::ImageSize* iimagesize_;
  ::google::protobuf::uint32 iquality_;
  ::google::protobuf::uint32 isequencepiccount_;
  ::google::protobuf::uint32 isequenceinterval_;
  ::google::protobuf::uint32 isequencedelay_;
  ::google::protobuf::uint32 ioverlay_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  friend void  protobuf_AddDesc_PUConfig_2eproto();
  friend void protobuf_AssignDesc_PUConfig_2eproto();
  friend void protobuf_ShutdownFile_PUConfig_2eproto();
  
  void InitAsDefaultInstance();
  static SnapshotParam* default_instance_;
};
// -------------------------------------------------------------------

class AudioEncoderParam : public ::google::protobuf::Message {
 public:
  AudioEncoderParam();
  virtual ~AudioEncoderParam();
  
  AudioEncoderParam(const AudioEncoderParam& from);
  
  inline AudioEncoderParam& operator=(const AudioEncoderParam& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const AudioEncoderParam& default_instance();
  
  void Swap(AudioEncoderParam* other);
  
  // implements Message ----------------------------------------------
  
  AudioEncoderParam* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AudioEncoderParam& from);
  void MergeFrom(const AudioEncoderParam& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional uint32 iCodecID = 1;
  inline bool has_icodecid() const;
  inline void clear_icodecid();
  static const int kICodecIDFieldNumber = 1;
  inline ::google::protobuf::uint32 icodecid() const;
  inline void set_icodecid(::google::protobuf::uint32 value);
  
  // repeated uint32 iChannelCount = 2;
  inline int ichannelcount_size() const;
  inline void clear_ichannelcount();
  static const int kIChannelCountFieldNumber = 2;
  inline ::google::protobuf::uint32 ichannelcount(int index) const;
  inline void set_ichannelcount(int index, ::google::protobuf::uint32 value);
  inline void add_ichannelcount(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      ichannelcount() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_ichannelcount();
  
  // repeated uint32 iBitsPerSample = 3;
  inline int ibitspersample_size() const;
  inline void clear_ibitspersample();
  static const int kIBitsPerSampleFieldNumber = 3;
  inline ::google::protobuf::uint32 ibitspersample(int index) const;
  inline void set_ibitspersample(int index, ::google::protobuf::uint32 value);
  inline void add_ibitspersample(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      ibitspersample() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_ibitspersample();
  
  // repeated uint32 iSamplesPerSec = 4;
  inline int isamplespersec_size() const;
  inline void clear_isamplespersec();
  static const int kISamplesPerSecFieldNumber = 4;
  inline ::google::protobuf::uint32 isamplespersec(int index) const;
  inline void set_isamplespersec(int index, ::google::protobuf::uint32 value);
  inline void add_isamplespersec(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      isamplespersec() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_isamplespersec();
  
  // repeated uint32 iBitRate = 5;
  inline int ibitrate_size() const;
  inline void clear_ibitrate();
  static const int kIBitRateFieldNumber = 5;
  inline ::google::protobuf::uint32 ibitrate(int index) const;
  inline void set_ibitrate(int index, ::google::protobuf::uint32 value);
  inline void add_ibitrate(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      ibitrate() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_ibitrate();
  
  // optional uint32 iChannelCountIndex = 6;
  inline bool has_ichannelcountindex() const;
  inline void clear_ichannelcountindex();
  static const int kIChannelCountIndexFieldNumber = 6;
  inline ::google::protobuf::uint32 ichannelcountindex() const;
  inline void set_ichannelcountindex(::google::protobuf::uint32 value);
  
  // optional uint32 iBitsPerSampleIndex = 7;
  inline bool has_ibitspersampleindex() const;
  inline void clear_ibitspersampleindex();
  static const int kIBitsPerSampleIndexFieldNumber = 7;
  inline ::google::protobuf::uint32 ibitspersampleindex() const;
  inline void set_ibitspersampleindex(::google::protobuf::uint32 value);
  
  // optional uint32 iSamplesPerSecIndex = 8;
  inline bool has_isamplespersecindex() const;
  inline void clear_isamplespersecindex();
  static const int kISamplesPerSecIndexFieldNumber = 8;
  inline ::google::protobuf::uint32 isamplespersecindex() const;
  inline void set_isamplespersecindex(::google::protobuf::uint32 value);
  
  // optional uint32 iBitRateIndex = 9;
  inline bool has_ibitrateindex() const;
  inline void clear_ibitrateindex();
  static const int kIBitRateIndexFieldNumber = 9;
  inline ::google::protobuf::uint32 ibitrateindex() const;
  inline void set_ibitrateindex(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:BVCU.PUConfig.AudioEncoderParam)
 private:
  inline void set_has_icodecid();
  inline void clear_has_icodecid();
  inline void set_has_ichannelcountindex();
  inline void clear_has_ichannelcountindex();
  inline void set_has_ibitspersampleindex();
  inline void clear_has_ibitspersampleindex();
  inline void set_has_isamplespersecindex();
  inline void clear_has_isamplespersecindex();
  inline void set_has_ibitrateindex();
  inline void clear_has_ibitrateindex();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > ichannelcount_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > ibitspersample_;
  ::google::protobuf::uint32 icodecid_;
  ::google::protobuf::uint32 ichannelcountindex_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > isamplespersec_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > ibitrate_;
  ::google::protobuf::uint32 ibitspersampleindex_;
  ::google::protobuf::uint32 isamplespersecindex_;
  ::google::protobuf::uint32 ibitrateindex_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];
  
  friend void  protobuf_AddDesc_PUConfig_2eproto();
  friend void protobuf_AssignDesc_PUConfig_2eproto();
  friend void protobuf_ShutdownFile_PUConfig_2eproto();
  
  void InitAsDefaultInstance();
  static AudioEncoderParam* default_instance_;
};
// -------------------------------------------------------------------

class EncoderParam : public ::google::protobuf::Message {
 public:
  EncoderParam();
  virtual ~EncoderParam();
  
  EncoderParam(const EncoderParam& from);
  
  inline EncoderParam& operator=(const EncoderParam& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const EncoderParam& default_instance();
  
  void Swap(EncoderParam* other);
  
  // implements Message ----------------------------------------------
  
  EncoderParam* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EncoderParam& from);
  void MergeFrom(const EncoderParam& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional .BVCU.PUConfig.DayTimeSlice stTime = 1;
  inline bool has_sttime() const;
  inline void clear_sttime();
  static const int kStTimeFieldNumber = 1;
  inline const ::BVCU::PUConfig::DayTimeSlice& sttime() const;
  inline ::BVCU::PUConfig::DayTimeSlice* mutable_sttime();
  inline ::BVCU::PUConfig::DayTimeSlice* release_sttime();
  
  // optional uint32 bVideoEnable = 2 [default = 1];
  inline bool has_bvideoenable() const;
  inline void clear_bvideoenable();
  static const int kBVideoEnableFieldNumber = 2;
  inline ::google::protobuf::uint32 bvideoenable() const;
  inline void set_bvideoenable(::google::protobuf::uint32 value);
  
  // repeated uint32 iVideoCodecAll = 3;
  inline int ivideocodecall_size() const;
  inline void clear_ivideocodecall();
  static const int kIVideoCodecAllFieldNumber = 3;
  inline ::google::protobuf::uint32 ivideocodecall(int index) const;
  inline void set_ivideocodecall(int index, ::google::protobuf::uint32 value);
  inline void add_ivideocodecall(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      ivideocodecall() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_ivideocodecall();
  
  // optional uint32 iVideoCodecIndex = 4;
  inline bool has_ivideocodecindex() const;
  inline void clear_ivideocodecindex();
  static const int kIVideoCodecIndexFieldNumber = 4;
  inline ::google::protobuf::uint32 ivideocodecindex() const;
  inline void set_ivideocodecindex(::google::protobuf::uint32 value);
  
  // optional uint32 iRateControl = 5;
  inline bool has_iratecontrol() const;
  inline void clear_iratecontrol();
  static const int kIRateControlFieldNumber = 5;
  inline ::google::protobuf::uint32 iratecontrol() const;
  inline void set_iratecontrol(::google::protobuf::uint32 value);
  
  // repeated .BVCU.PUConfig.ImageRect iImageRectAll = 6;
  inline int iimagerectall_size() const;
  inline void clear_iimagerectall();
  static const int kIImageRectAllFieldNumber = 6;
  inline const ::BVCU::PUConfig::ImageRect& iimagerectall(int index) const;
  inline ::BVCU::PUConfig::ImageRect* mutable_iimagerectall(int index);
  inline ::BVCU::PUConfig::ImageRect* add_iimagerectall();
  inline const ::google::protobuf::RepeatedPtrField< ::BVCU::PUConfig::ImageRect >&
      iimagerectall() const;
  inline ::google::protobuf::RepeatedPtrField< ::BVCU::PUConfig::ImageRect >*
      mutable_iimagerectall();
  
  // optional uint32 iImageRectIndex = 7;
  inline bool has_iimagerectindex() const;
  inline void clear_iimagerectindex();
  static const int kIImageRectIndexFieldNumber = 7;
  inline ::google::protobuf::uint32 iimagerectindex() const;
  inline void set_iimagerectindex(::google::protobuf::uint32 value);
  
  // optional uint32 iFramesPerSec = 8 [default = 25000];
  inline bool has_iframespersec() const;
  inline void clear_iframespersec();
  static const int kIFramesPerSecFieldNumber = 8;
  inline ::google::protobuf::uint32 iframespersec() const;
  inline void set_iframespersec(::google::protobuf::uint32 value);
  
  // optional uint32 iKeyFrameInterval = 9 [default = 125];
  inline bool has_ikeyframeinterval() const;
  inline void clear_ikeyframeinterval();
  static const int kIKeyFrameIntervalFieldNumber = 9;
  inline ::google::protobuf::uint32 ikeyframeinterval() const;
  inline void set_ikeyframeinterval(::google::protobuf::uint32 value);
  
  // optional uint32 iImageQuality = 10 [default = 1];
  inline bool has_iimagequality() const;
  inline void clear_iimagequality();
  static const int kIImageQualityFieldNumber = 10;
  inline ::google::protobuf::uint32 iimagequality() const;
  inline void set_iimagequality(::google::protobuf::uint32 value);
  
  // repeated uint32 iKbpsLimitMin = 11;
  inline int ikbpslimitmin_size() const;
  inline void clear_ikbpslimitmin();
  static const int kIKbpsLimitMinFieldNumber = 11;
  inline ::google::protobuf::uint32 ikbpslimitmin(int index) const;
  inline void set_ikbpslimitmin(int index, ::google::protobuf::uint32 value);
  inline void add_ikbpslimitmin(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      ikbpslimitmin() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_ikbpslimitmin();
  
  // optional uint32 iKbpsLimitMax = 12;
  inline bool has_ikbpslimitmax() const;
  inline void clear_ikbpslimitmax();
  static const int kIKbpsLimitMaxFieldNumber = 12;
  inline ::google::protobuf::uint32 ikbpslimitmax() const;
  inline void set_ikbpslimitmax(::google::protobuf::uint32 value);
  
  // optional uint32 iKbpsLimitCurrent = 13;
  inline bool has_ikbpslimitcurrent() const;
  inline void clear_ikbpslimitcurrent();
  static const int kIKbpsLimitCurrentFieldNumber = 13;
  inline ::google::protobuf::uint32 ikbpslimitcurrent() const;
  inline void set_ikbpslimitcurrent(::google::protobuf::uint32 value);
  
  // optional uint32 bAudioEnable = 14 [default = 1];
  inline bool has_baudioenable() const;
  inline void clear_baudioenable();
  static const int kBAudioEnableFieldNumber = 14;
  inline ::google::protobuf::uint32 baudioenable() const;
  inline void set_baudioenable(::google::protobuf::uint32 value);
  
  // repeated .BVCU.PUConfig.AudioEncoderParam iAudioCodecAll = 15;
  inline int iaudiocodecall_size() const;
  inline void clear_iaudiocodecall();
  static const int kIAudioCodecAllFieldNumber = 15;
  inline const ::BVCU::PUConfig::AudioEncoderParam& iaudiocodecall(int index) const;
  inline ::BVCU::PUConfig::AudioEncoderParam* mutable_iaudiocodecall(int index);
  inline ::BVCU::PUConfig::AudioEncoderParam* add_iaudiocodecall();
  inline const ::google::protobuf::RepeatedPtrField< ::BVCU::PUConfig::AudioEncoderParam >&
      iaudiocodecall() const;
  inline ::google::protobuf::RepeatedPtrField< ::BVCU::PUConfig::AudioEncoderParam >*
      mutable_iaudiocodecall();
  
  // optional uint32 iAudioCodecIndex = 16;
  inline bool has_iaudiocodecindex() const;
  inline void clear_iaudiocodecindex();
  static const int kIAudioCodecIndexFieldNumber = 16;
  inline ::google::protobuf::uint32 iaudiocodecindex() const;
  inline void set_iaudiocodecindex(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:BVCU.PUConfig.EncoderParam)
 private:
  inline void set_has_sttime();
  inline void clear_has_sttime();
  inline void set_has_bvideoenable();
  inline void clear_has_bvideoenable();
  inline void set_has_ivideocodecindex();
  inline void clear_has_ivideocodecindex();
  inline void set_has_iratecontrol();
  inline void clear_has_iratecontrol();
  inline void set_has_iimagerectindex();
  inline void clear_has_iimagerectindex();
  inline void set_has_iframespersec();
  inline void clear_has_iframespersec();
  inline void set_has_ikeyframeinterval();
  inline void clear_has_ikeyframeinterval();
  inline void set_has_iimagequality();
  inline void clear_has_iimagequality();
  inline void set_has_ikbpslimitmax();
  inline void clear_has_ikbpslimitmax();
  inline void set_has_ikbpslimitcurrent();
  inline void clear_has_ikbpslimitcurrent();
  inline void set_has_baudioenable();
  inline void clear_has_baudioenable();
  inline void set_has_iaudiocodecindex();
  inline void clear_has_iaudiocodecindex();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::BVCU::PUConfig::DayTimeSlice* sttime_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > ivideocodecall_;
  ::google::protobuf::uint32 bvideoenable_;
  ::google::protobuf::uint32 ivideocodecindex_;
  ::google::protobuf::RepeatedPtrField< ::BVCU::PUConfig::ImageRect > iimagerectall_;
  ::google::protobuf::uint32 iratecontrol_;
  ::google::protobuf::uint32 iimagerectindex_;
  ::google::protobuf::uint32 iframespersec_;
  ::google::protobuf::uint32 ikeyframeinterval_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > ikbpslimitmin_;
  ::google::protobuf::uint32 iimagequality_;
  ::google::protobuf::uint32 ikbpslimitmax_;
  ::google::protobuf::uint32 ikbpslimitcurrent_;
  ::google::protobuf::uint32 baudioenable_;
  ::google::protobuf::RepeatedPtrField< ::BVCU::PUConfig::AudioEncoderParam > iaudiocodecall_;
  ::google::protobuf::uint32 iaudiocodecindex_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(16 + 31) / 32];
  
  friend void  protobuf_AddDesc_PUConfig_2eproto();
  friend void protobuf_AssignDesc_PUConfig_2eproto();
  friend void protobuf_ShutdownFile_PUConfig_2eproto();
  
  void InitAsDefaultInstance();
  static EncoderParam* default_instance_;
};
// -------------------------------------------------------------------

class EncoderStreamParam : public ::google::protobuf::Message {
 public:
  EncoderStreamParam();
  virtual ~EncoderStreamParam();
  
  EncoderStreamParam(const EncoderStreamParam& from);
  
  inline EncoderStreamParam& operator=(const EncoderStreamParam& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const EncoderStreamParam& default_instance();
  
  void Swap(EncoderStreamParam* other);
  
  // implements Message ----------------------------------------------
  
  EncoderStreamParam* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EncoderStreamParam& from);
  void MergeFrom(const EncoderStreamParam& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional uint32 bEnableTransfer = 1 [default = 1];
  inline bool has_benabletransfer() const;
  inline void clear_benabletransfer();
  static const int kBEnableTransferFieldNumber = 1;
  inline ::google::protobuf::uint32 benabletransfer() const;
  inline void set_benabletransfer(::google::protobuf::uint32 value);
  
  // optional uint32 iStreamType = 2;
  inline bool has_istreamtype() const;
  inline void clear_istreamtype();
  static const int kIStreamTypeFieldNumber = 2;
  inline ::google::protobuf::uint32 istreamtype() const;
  inline void set_istreamtype(::google::protobuf::uint32 value);
  
  // repeated .BVCU.PUConfig.EncoderParam pstParams = 3;
  inline int pstparams_size() const;
  inline void clear_pstparams();
  static const int kPstParamsFieldNumber = 3;
  inline const ::BVCU::PUConfig::EncoderParam& pstparams(int index) const;
  inline ::BVCU::PUConfig::EncoderParam* mutable_pstparams(int index);
  inline ::BVCU::PUConfig::EncoderParam* add_pstparams();
  inline const ::google::protobuf::RepeatedPtrField< ::BVCU::PUConfig::EncoderParam >&
      pstparams() const;
  inline ::google::protobuf::RepeatedPtrField< ::BVCU::PUConfig::EncoderParam >*
      mutable_pstparams();
  
  // @@protoc_insertion_point(class_scope:BVCU.PUConfig.EncoderStreamParam)
 private:
  inline void set_has_benabletransfer();
  inline void clear_has_benabletransfer();
  inline void set_has_istreamtype();
  inline void clear_has_istreamtype();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint32 benabletransfer_;
  ::google::protobuf::uint32 istreamtype_;
  ::google::protobuf::RepeatedPtrField< ::BVCU::PUConfig::EncoderParam > pstparams_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_PUConfig_2eproto();
  friend void protobuf_AssignDesc_PUConfig_2eproto();
  friend void protobuf_ShutdownFile_PUConfig_2eproto();
  
  void InitAsDefaultInstance();
  static EncoderStreamParam* default_instance_;
};
// -------------------------------------------------------------------

class EncoderChannel : public ::google::protobuf::Message {
 public:
  EncoderChannel();
  virtual ~EncoderChannel();
  
  EncoderChannel(const EncoderChannel& from);
  
  inline EncoderChannel& operator=(const EncoderChannel& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const EncoderChannel& default_instance();
  
  void Swap(EncoderChannel* other);
  
  // implements Message ----------------------------------------------
  
  EncoderChannel* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EncoderChannel& from);
  void MergeFrom(const EncoderChannel& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string szName = 1;
  inline bool has_szname() const;
  inline void clear_szname();
  static const int kSzNameFieldNumber = 1;
  inline const ::std::string& szname() const;
  inline void set_szname(const ::std::string& value);
  inline void set_szname(const char* value);
  inline void set_szname(const char* value, size_t size);
  inline ::std::string* mutable_szname();
  inline ::std::string* release_szname();
  
  // repeated .BVCU.PUConfig.EncoderStreamParam stParam = 2;
  inline int stparam_size() const;
  inline void clear_stparam();
  static const int kStParamFieldNumber = 2;
  inline const ::BVCU::PUConfig::EncoderStreamParam& stparam(int index) const;
  inline ::BVCU::PUConfig::EncoderStreamParam* mutable_stparam(int index);
  inline ::BVCU::PUConfig::EncoderStreamParam* add_stparam();
  inline const ::google::protobuf::RepeatedPtrField< ::BVCU::PUConfig::EncoderStreamParam >&
      stparam() const;
  inline ::google::protobuf::RepeatedPtrField< ::BVCU::PUConfig::EncoderStreamParam >*
      mutable_stparam();
  
  // optional int32 iVideoInIndex = 3;
  inline bool has_ivideoinindex() const;
  inline void clear_ivideoinindex();
  static const int kIVideoInIndexFieldNumber = 3;
  inline ::google::protobuf::int32 ivideoinindex() const;
  inline void set_ivideoinindex(::google::protobuf::int32 value);
  
  // optional int32 iAudioInIndex = 4;
  inline bool has_iaudioinindex() const;
  inline void clear_iaudioinindex();
  static const int kIAudioInIndexFieldNumber = 4;
  inline ::google::protobuf::int32 iaudioinindex() const;
  inline void set_iaudioinindex(::google::protobuf::int32 value);
  
  // optional int32 iAudioOutIndex = 5;
  inline bool has_iaudiooutindex() const;
  inline void clear_iaudiooutindex();
  static const int kIAudioOutIndexFieldNumber = 5;
  inline ::google::protobuf::int32 iaudiooutindex() const;
  inline void set_iaudiooutindex(::google::protobuf::int32 value);
  
  // optional int32 iPTZIndex = 6;
  inline bool has_iptzindex() const;
  inline void clear_iptzindex();
  static const int kIPTZIndexFieldNumber = 6;
  inline ::google::protobuf::int32 iptzindex() const;
  inline void set_iptzindex(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:BVCU.PUConfig.EncoderChannel)
 private:
  inline void set_has_szname();
  inline void clear_has_szname();
  inline void set_has_ivideoinindex();
  inline void clear_has_ivideoinindex();
  inline void set_has_iaudioinindex();
  inline void clear_has_iaudioinindex();
  inline void set_has_iaudiooutindex();
  inline void clear_has_iaudiooutindex();
  inline void set_has_iptzindex();
  inline void clear_has_iptzindex();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* szname_;
  ::google::protobuf::RepeatedPtrField< ::BVCU::PUConfig::EncoderStreamParam > stparam_;
  ::google::protobuf::int32 ivideoinindex_;
  ::google::protobuf::int32 iaudioinindex_;
  ::google::protobuf::int32 iaudiooutindex_;
  ::google::protobuf::int32 iptzindex_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  friend void  protobuf_AddDesc_PUConfig_2eproto();
  friend void protobuf_AssignDesc_PUConfig_2eproto();
  friend void protobuf_ShutdownFile_PUConfig_2eproto();
  
  void InitAsDefaultInstance();
  static EncoderChannel* default_instance_;
};
// -------------------------------------------------------------------

class RS232 : public ::google::protobuf::Message {
 public:
  RS232();
  virtual ~RS232();
  
  RS232(const RS232& from);
  
  inline RS232& operator=(const RS232& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RS232& default_instance();
  
  void Swap(RS232* other);
  
  // implements Message ----------------------------------------------
  
  RS232* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RS232& from);
  void MergeFrom(const RS232& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 iBaudRate = 1;
  inline bool has_ibaudrate() const;
  inline void clear_ibaudrate();
  static const int kIBaudRateFieldNumber = 1;
  inline ::google::protobuf::uint32 ibaudrate() const;
  inline void set_ibaudrate(::google::protobuf::uint32 value);
  
  // required uint32 iDataBit = 2;
  inline bool has_idatabit() const;
  inline void clear_idatabit();
  static const int kIDataBitFieldNumber = 2;
  inline ::google::protobuf::uint32 idatabit() const;
  inline void set_idatabit(::google::protobuf::uint32 value);
  
  // required uint32 iStopBit = 3;
  inline bool has_istopbit() const;
  inline void clear_istopbit();
  static const int kIStopBitFieldNumber = 3;
  inline ::google::protobuf::uint32 istopbit() const;
  inline void set_istopbit(::google::protobuf::uint32 value);
  
  // optional uint32 iParity = 4;
  inline bool has_iparity() const;
  inline void clear_iparity();
  static const int kIParityFieldNumber = 4;
  inline ::google::protobuf::uint32 iparity() const;
  inline void set_iparity(::google::protobuf::uint32 value);
  
  // optional uint32 iFlowControl = 5;
  inline bool has_iflowcontrol() const;
  inline void clear_iflowcontrol();
  static const int kIFlowControlFieldNumber = 5;
  inline ::google::protobuf::uint32 iflowcontrol() const;
  inline void set_iflowcontrol(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:BVCU.PUConfig.RS232)
 private:
  inline void set_has_ibaudrate();
  inline void clear_has_ibaudrate();
  inline void set_has_idatabit();
  inline void clear_has_idatabit();
  inline void set_has_istopbit();
  inline void clear_has_istopbit();
  inline void set_has_iparity();
  inline void clear_has_iparity();
  inline void set_has_iflowcontrol();
  inline void clear_has_iflowcontrol();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint32 ibaudrate_;
  ::google::protobuf::uint32 idatabit_;
  ::google::protobuf::uint32 istopbit_;
  ::google::protobuf::uint32 iparity_;
  ::google::protobuf::uint32 iflowcontrol_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_PUConfig_2eproto();
  friend void protobuf_AssignDesc_PUConfig_2eproto();
  friend void protobuf_ShutdownFile_PUConfig_2eproto();
  
  void InitAsDefaultInstance();
  static RS232* default_instance_;
};
// -------------------------------------------------------------------

class SerialPort : public ::google::protobuf::Message {
 public:
  SerialPort();
  virtual ~SerialPort();
  
  SerialPort(const SerialPort& from);
  
  inline SerialPort& operator=(const SerialPort& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const SerialPort& default_instance();
  
  void Swap(SerialPort* other);
  
  // implements Message ----------------------------------------------
  
  SerialPort* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SerialPort& from);
  void MergeFrom(const SerialPort& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .BVCU.PUConfig.RS232 stRS232 = 1;
  inline bool has_strs232() const;
  inline void clear_strs232();
  static const int kStRS232FieldNumber = 1;
  inline const ::BVCU::PUConfig::RS232& strs232() const;
  inline ::BVCU::PUConfig::RS232* mutable_strs232();
  inline ::BVCU::PUConfig::RS232* release_strs232();
  
  // required int32 iAddress = 2;
  inline bool has_iaddress() const;
  inline void clear_iaddress();
  static const int kIAddressFieldNumber = 2;
  inline ::google::protobuf::int32 iaddress() const;
  inline void set_iaddress(::google::protobuf::int32 value);
  
  // required int32 iType = 3;
  inline bool has_itype() const;
  inline void clear_itype();
  static const int kITypeFieldNumber = 3;
  inline ::google::protobuf::int32 itype() const;
  inline void set_itype(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:BVCU.PUConfig.SerialPort)
 private:
  inline void set_has_strs232();
  inline void clear_has_strs232();
  inline void set_has_iaddress();
  inline void clear_has_iaddress();
  inline void set_has_itype();
  inline void clear_has_itype();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::BVCU::PUConfig::RS232* strs232_;
  ::google::protobuf::int32 iaddress_;
  ::google::protobuf::int32 itype_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_PUConfig_2eproto();
  friend void protobuf_AssignDesc_PUConfig_2eproto();
  friend void protobuf_ShutdownFile_PUConfig_2eproto();
  
  void InitAsDefaultInstance();
  static SerialPort* default_instance_;
};
// -------------------------------------------------------------------

class Preset : public ::google::protobuf::Message {
 public:
  Preset();
  virtual ~Preset();
  
  Preset(const Preset& from);
  
  inline Preset& operator=(const Preset& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Preset& default_instance();
  
  void Swap(Preset* other);
  
  // implements Message ----------------------------------------------
  
  Preset* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Preset& from);
  void MergeFrom(const Preset& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 iID = 1;
  inline bool has_iid() const;
  inline void clear_iid();
  static const int kIIDFieldNumber = 1;
  inline ::google::protobuf::int32 iid() const;
  inline void set_iid(::google::protobuf::int32 value);
  
  // optional string szPreset = 2;
  inline bool has_szpreset() const;
  inline void clear_szpreset();
  static const int kSzPresetFieldNumber = 2;
  inline const ::std::string& szpreset() const;
  inline void set_szpreset(const ::std::string& value);
  inline void set_szpreset(const char* value);
  inline void set_szpreset(const char* value, size_t size);
  inline ::std::string* mutable_szpreset();
  inline ::std::string* release_szpreset();
  
  // @@protoc_insertion_point(class_scope:BVCU.PUConfig.Preset)
 private:
  inline void set_has_iid();
  inline void clear_has_iid();
  inline void set_has_szpreset();
  inline void clear_has_szpreset();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* szpreset_;
  ::google::protobuf::int32 iid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_PUConfig_2eproto();
  friend void protobuf_AssignDesc_PUConfig_2eproto();
  friend void protobuf_ShutdownFile_PUConfig_2eproto();
  
  void InitAsDefaultInstance();
  static Preset* default_instance_;
};
// -------------------------------------------------------------------

class CruisePoint : public ::google::protobuf::Message {
 public:
  CruisePoint();
  virtual ~CruisePoint();
  
  CruisePoint(const CruisePoint& from);
  
  inline CruisePoint& operator=(const CruisePoint& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const CruisePoint& default_instance();
  
  void Swap(CruisePoint* other);
  
  // implements Message ----------------------------------------------
  
  CruisePoint* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CruisePoint& from);
  void MergeFrom(const CruisePoint& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 iPreset = 1;
  inline bool has_ipreset() const;
  inline void clear_ipreset();
  static const int kIPresetFieldNumber = 1;
  inline ::google::protobuf::uint32 ipreset() const;
  inline void set_ipreset(::google::protobuf::uint32 value);
  
  // optional uint32 iSpeed = 2 [default = 5];
  inline bool has_ispeed() const;
  inline void clear_ispeed();
  static const int kISpeedFieldNumber = 2;
  inline ::google::protobuf::uint32 ispeed() const;
  inline void set_ispeed(::google::protobuf::uint32 value);
  
  // optional uint32 iDuration = 3 [default = 5];
  inline bool has_iduration() const;
  inline void clear_iduration();
  static const int kIDurationFieldNumber = 3;
  inline ::google::protobuf::uint32 iduration() const;
  inline void set_iduration(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:BVCU.PUConfig.CruisePoint)
 private:
  inline void set_has_ipreset();
  inline void clear_has_ipreset();
  inline void set_has_ispeed();
  inline void clear_has_ispeed();
  inline void set_has_iduration();
  inline void clear_has_iduration();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint32 ipreset_;
  ::google::protobuf::uint32 ispeed_;
  ::google::protobuf::uint32 iduration_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_PUConfig_2eproto();
  friend void protobuf_AssignDesc_PUConfig_2eproto();
  friend void protobuf_ShutdownFile_PUConfig_2eproto();
  
  void InitAsDefaultInstance();
  static CruisePoint* default_instance_;
};
// -------------------------------------------------------------------

class Cruise : public ::google::protobuf::Message {
 public:
  Cruise();
  virtual ~Cruise();
  
  Cruise(const Cruise& from);
  
  inline Cruise& operator=(const Cruise& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Cruise& default_instance();
  
  void Swap(Cruise* other);
  
  // implements Message ----------------------------------------------
  
  Cruise* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Cruise& from);
  void MergeFrom(const Cruise& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 iID = 1;
  inline bool has_iid() const;
  inline void clear_iid();
  static const int kIIDFieldNumber = 1;
  inline ::google::protobuf::int32 iid() const;
  inline void set_iid(::google::protobuf::int32 value);
  
  // optional string szName = 2;
  inline bool has_szname() const;
  inline void clear_szname();
  static const int kSzNameFieldNumber = 2;
  inline const ::std::string& szname() const;
  inline void set_szname(const ::std::string& value);
  inline void set_szname(const char* value);
  inline void set_szname(const char* value, size_t size);
  inline ::std::string* mutable_szname();
  inline ::std::string* release_szname();
  
  // repeated .BVCU.PUConfig.CruisePoint stPoints = 3;
  inline int stpoints_size() const;
  inline void clear_stpoints();
  static const int kStPointsFieldNumber = 3;
  inline const ::BVCU::PUConfig::CruisePoint& stpoints(int index) const;
  inline ::BVCU::PUConfig::CruisePoint* mutable_stpoints(int index);
  inline ::BVCU::PUConfig::CruisePoint* add_stpoints();
  inline const ::google::protobuf::RepeatedPtrField< ::BVCU::PUConfig::CruisePoint >&
      stpoints() const;
  inline ::google::protobuf::RepeatedPtrField< ::BVCU::PUConfig::CruisePoint >*
      mutable_stpoints();
  
  // @@protoc_insertion_point(class_scope:BVCU.PUConfig.Cruise)
 private:
  inline void set_has_iid();
  inline void clear_has_iid();
  inline void set_has_szname();
  inline void clear_has_szname();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* szname_;
  ::google::protobuf::RepeatedPtrField< ::BVCU::PUConfig::CruisePoint > stpoints_;
  ::google::protobuf::int32 iid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_PUConfig_2eproto();
  friend void protobuf_AssignDesc_PUConfig_2eproto();
  friend void protobuf_ShutdownFile_PUConfig_2eproto();
  
  void InitAsDefaultInstance();
  static Cruise* default_instance_;
};
// -------------------------------------------------------------------

class PTZControl : public ::google::protobuf::Message {
 public:
  PTZControl();
  virtual ~PTZControl();
  
  PTZControl(const PTZControl& from);
  
  inline PTZControl& operator=(const PTZControl& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const PTZControl& default_instance();
  
  void Swap(PTZControl* other);
  
  // implements Message ----------------------------------------------
  
  PTZControl* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PTZControl& from);
  void MergeFrom(const PTZControl& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 iPTZCommand = 1;
  inline bool has_iptzcommand() const;
  inline void clear_iptzcommand();
  static const int kIPTZCommandFieldNumber = 1;
  inline ::google::protobuf::uint32 iptzcommand() const;
  inline void set_iptzcommand(::google::protobuf::uint32 value);
  
  // optional uint32 bStop = 2;
  inline bool has_bstop() const;
  inline void clear_bstop();
  static const int kBStopFieldNumber = 2;
  inline ::google::protobuf::uint32 bstop() const;
  inline void set_bstop(::google::protobuf::uint32 value);
  
  // optional uint32 iParam1 = 3;
  inline bool has_iparam1() const;
  inline void clear_iparam1();
  static const int kIParam1FieldNumber = 3;
  inline ::google::protobuf::uint32 iparam1() const;
  inline void set_iparam1(::google::protobuf::uint32 value);
  
  // optional uint32 iParam2 = 4;
  inline bool has_iparam2() const;
  inline void clear_iparam2();
  static const int kIParam2FieldNumber = 4;
  inline ::google::protobuf::uint32 iparam2() const;
  inline void set_iparam2(::google::protobuf::uint32 value);
  
  // optional uint32 iParam3 = 5;
  inline bool has_iparam3() const;
  inline void clear_iparam3();
  static const int kIParam3FieldNumber = 5;
  inline ::google::protobuf::uint32 iparam3() const;
  inline void set_iparam3(::google::protobuf::uint32 value);
  
  // optional string szPresetName = 6;
  inline bool has_szpresetname() const;
  inline void clear_szpresetname();
  static const int kSzPresetNameFieldNumber = 6;
  inline const ::std::string& szpresetname() const;
  inline void set_szpresetname(const ::std::string& value);
  inline void set_szpresetname(const char* value);
  inline void set_szpresetname(const char* value, size_t size);
  inline ::std::string* mutable_szpresetname();
  inline ::std::string* release_szpresetname();
  
  // optional .BVCU.PUConfig.Cruise ggCruise = 7;
  inline bool has_ggcruise() const;
  inline void clear_ggcruise();
  static const int kGgCruiseFieldNumber = 7;
  inline const ::BVCU::PUConfig::Cruise& ggcruise() const;
  inline ::BVCU::PUConfig::Cruise* mutable_ggcruise();
  inline ::BVCU::PUConfig::Cruise* release_ggcruise();
  
  // @@protoc_insertion_point(class_scope:BVCU.PUConfig.PTZControl)
 private:
  inline void set_has_iptzcommand();
  inline void clear_has_iptzcommand();
  inline void set_has_bstop();
  inline void clear_has_bstop();
  inline void set_has_iparam1();
  inline void clear_has_iparam1();
  inline void set_has_iparam2();
  inline void clear_has_iparam2();
  inline void set_has_iparam3();
  inline void clear_has_iparam3();
  inline void set_has_szpresetname();
  inline void clear_has_szpresetname();
  inline void set_has_ggcruise();
  inline void clear_has_ggcruise();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint32 iptzcommand_;
  ::google::protobuf::uint32 bstop_;
  ::google::protobuf::uint32 iparam1_;
  ::google::protobuf::uint32 iparam2_;
  ::std::string* szpresetname_;
  ::BVCU::PUConfig::Cruise* ggcruise_;
  ::google::protobuf::uint32 iparam3_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];
  
  friend void  protobuf_AddDesc_PUConfig_2eproto();
  friend void protobuf_AssignDesc_PUConfig_2eproto();
  friend void protobuf_ShutdownFile_PUConfig_2eproto();
  
  void InitAsDefaultInstance();
  static PTZControl* default_instance_;
};
// -------------------------------------------------------------------

class PTZAttr : public ::google::protobuf::Message {
 public:
  PTZAttr();
  virtual ~PTZAttr();
  
  PTZAttr(const PTZAttr& from);
  
  inline PTZAttr& operator=(const PTZAttr& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const PTZAttr& default_instance();
  
  void Swap(PTZAttr* other);
  
  // implements Message ----------------------------------------------
  
  PTZAttr* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PTZAttr& from);
  void MergeFrom(const PTZAttr& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated uint32 iPTZProtocolAll = 1;
  inline int iptzprotocolall_size() const;
  inline void clear_iptzprotocolall();
  static const int kIPTZProtocolAllFieldNumber = 1;
  inline ::google::protobuf::uint32 iptzprotocolall(int index) const;
  inline void set_iptzprotocolall(int index, ::google::protobuf::uint32 value);
  inline void add_iptzprotocolall(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      iptzprotocolall() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_iptzprotocolall();
  
  // required uint32 iPTZProtocolIndex = 2;
  inline bool has_iptzprotocolindex() const;
  inline void clear_iptzprotocolindex();
  static const int kIPTZProtocolIndexFieldNumber = 2;
  inline ::google::protobuf::uint32 iptzprotocolindex() const;
  inline void set_iptzprotocolindex(::google::protobuf::uint32 value);
  
  // required uint32 iAddress = 3;
  inline bool has_iaddress() const;
  inline void clear_iaddress();
  static const int kIAddressFieldNumber = 3;
  inline ::google::protobuf::uint32 iaddress() const;
  inline void set_iaddress(::google::protobuf::uint32 value);
  
  // optional .BVCU.PUConfig.RS232 stRS232 = 4;
  inline bool has_strs232() const;
  inline void clear_strs232();
  static const int kStRS232FieldNumber = 4;
  inline const ::BVCU::PUConfig::RS232& strs232() const;
  inline ::BVCU::PUConfig::RS232* mutable_strs232();
  inline ::BVCU::PUConfig::RS232* release_strs232();
  
  // optional uint32 bChangePreset = 5;
  inline bool has_bchangepreset() const;
  inline void clear_bchangepreset();
  static const int kBChangePresetFieldNumber = 5;
  inline ::google::protobuf::uint32 bchangepreset() const;
  inline void set_bchangepreset(::google::protobuf::uint32 value);
  
  // optional uint32 bChangeCruise = 6;
  inline bool has_bchangecruise() const;
  inline void clear_bchangecruise();
  static const int kBChangeCruiseFieldNumber = 6;
  inline ::google::protobuf::uint32 bchangecruise() const;
  inline void set_bchangecruise(::google::protobuf::uint32 value);
  
  // repeated .BVCU.PUConfig.Preset stPreset = 7;
  inline int stpreset_size() const;
  inline void clear_stpreset();
  static const int kStPresetFieldNumber = 7;
  inline const ::BVCU::PUConfig::Preset& stpreset(int index) const;
  inline ::BVCU::PUConfig::Preset* mutable_stpreset(int index);
  inline ::BVCU::PUConfig::Preset* add_stpreset();
  inline const ::google::protobuf::RepeatedPtrField< ::BVCU::PUConfig::Preset >&
      stpreset() const;
  inline ::google::protobuf::RepeatedPtrField< ::BVCU::PUConfig::Preset >*
      mutable_stpreset();
  
  // repeated .BVCU.PUConfig.Cruise stCruise = 8;
  inline int stcruise_size() const;
  inline void clear_stcruise();
  static const int kStCruiseFieldNumber = 8;
  inline const ::BVCU::PUConfig::Cruise& stcruise(int index) const;
  inline ::BVCU::PUConfig::Cruise* mutable_stcruise(int index);
  inline ::BVCU::PUConfig::Cruise* add_stcruise();
  inline const ::google::protobuf::RepeatedPtrField< ::BVCU::PUConfig::Cruise >&
      stcruise() const;
  inline ::google::protobuf::RepeatedPtrField< ::BVCU::PUConfig::Cruise >*
      mutable_stcruise();
  
  // optional int32 iActiveCruiseID = 9 [default = -1];
  inline bool has_iactivecruiseid() const;
  inline void clear_iactivecruiseid();
  static const int kIActiveCruiseIDFieldNumber = 9;
  inline ::google::protobuf::int32 iactivecruiseid() const;
  inline void set_iactivecruiseid(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:BVCU.PUConfig.PTZAttr)
 private:
  inline void set_has_iptzprotocolindex();
  inline void clear_has_iptzprotocolindex();
  inline void set_has_iaddress();
  inline void clear_has_iaddress();
  inline void set_has_strs232();
  inline void clear_has_strs232();
  inline void set_has_bchangepreset();
  inline void clear_has_bchangepreset();
  inline void set_has_bchangecruise();
  inline void clear_has_bchangecruise();
  inline void set_has_iactivecruiseid();
  inline void clear_has_iactivecruiseid();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > iptzprotocolall_;
  ::google::protobuf::uint32 iptzprotocolindex_;
  ::google::protobuf::uint32 iaddress_;
  ::BVCU::PUConfig::RS232* strs232_;
  ::google::protobuf::uint32 bchangepreset_;
  ::google::protobuf::uint32 bchangecruise_;
  ::google::protobuf::RepeatedPtrField< ::BVCU::PUConfig::Preset > stpreset_;
  ::google::protobuf::RepeatedPtrField< ::BVCU::PUConfig::Cruise > stcruise_;
  ::google::protobuf::int32 iactivecruiseid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];
  
  friend void  protobuf_AddDesc_PUConfig_2eproto();
  friend void protobuf_AssignDesc_PUConfig_2eproto();
  friend void protobuf_ShutdownFile_PUConfig_2eproto();
  
  void InitAsDefaultInstance();
  static PTZAttr* default_instance_;
};
// -------------------------------------------------------------------

class Ethernet : public ::google::protobuf::Message {
 public:
  Ethernet();
  virtual ~Ethernet();
  
  Ethernet(const Ethernet& from);
  
  inline Ethernet& operator=(const Ethernet& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Ethernet& default_instance();
  
  void Swap(Ethernet* other);
  
  // implements Message ----------------------------------------------
  
  Ethernet* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Ethernet& from);
  void MergeFrom(const Ethernet& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 bDHCP = 1;
  inline bool has_bdhcp() const;
  inline void clear_bdhcp();
  static const int kBDHCPFieldNumber = 1;
  inline ::google::protobuf::int32 bdhcp() const;
  inline void set_bdhcp(::google::protobuf::int32 value);
  
  // optional int32 bPPPoE = 2;
  inline bool has_bpppoe() const;
  inline void clear_bpppoe();
  static const int kBPPPoEFieldNumber = 2;
  inline ::google::protobuf::int32 bpppoe() const;
  inline void set_bpppoe(::google::protobuf::int32 value);
  
  // optional uint32 bAutoDNS = 3;
  inline bool has_bautodns() const;
  inline void clear_bautodns();
  static const int kBAutoDNSFieldNumber = 3;
  inline ::google::protobuf::uint32 bautodns() const;
  inline void set_bautodns(::google::protobuf::uint32 value);
  
  // optional string szIP = 4;
  inline bool has_szip() const;
  inline void clear_szip();
  static const int kSzIPFieldNumber = 4;
  inline const ::std::string& szip() const;
  inline void set_szip(const ::std::string& value);
  inline void set_szip(const char* value);
  inline void set_szip(const char* value, size_t size);
  inline ::std::string* mutable_szip();
  inline ::std::string* release_szip();
  
  // optional string szNetMask = 5;
  inline bool has_sznetmask() const;
  inline void clear_sznetmask();
  static const int kSzNetMaskFieldNumber = 5;
  inline const ::std::string& sznetmask() const;
  inline void set_sznetmask(const ::std::string& value);
  inline void set_sznetmask(const char* value);
  inline void set_sznetmask(const char* value, size_t size);
  inline ::std::string* mutable_sznetmask();
  inline ::std::string* release_sznetmask();
  
  // optional string szGateway = 6;
  inline bool has_szgateway() const;
  inline void clear_szgateway();
  static const int kSzGatewayFieldNumber = 6;
  inline const ::std::string& szgateway() const;
  inline void set_szgateway(const ::std::string& value);
  inline void set_szgateway(const char* value);
  inline void set_szgateway(const char* value, size_t size);
  inline ::std::string* mutable_szgateway();
  inline ::std::string* release_szgateway();
  
  // repeated string szDNS = 7;
  inline int szdns_size() const;
  inline void clear_szdns();
  static const int kSzDNSFieldNumber = 7;
  inline const ::std::string& szdns(int index) const;
  inline ::std::string* mutable_szdns(int index);
  inline void set_szdns(int index, const ::std::string& value);
  inline void set_szdns(int index, const char* value);
  inline void set_szdns(int index, const char* value, size_t size);
  inline ::std::string* add_szdns();
  inline void add_szdns(const ::std::string& value);
  inline void add_szdns(const char* value);
  inline void add_szdns(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& szdns() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_szdns();
  
  // optional string szPPPoEUserName = 8;
  inline bool has_szpppoeusername() const;
  inline void clear_szpppoeusername();
  static const int kSzPPPoEUserNameFieldNumber = 8;
  inline const ::std::string& szpppoeusername() const;
  inline void set_szpppoeusername(const ::std::string& value);
  inline void set_szpppoeusername(const char* value);
  inline void set_szpppoeusername(const char* value, size_t size);
  inline ::std::string* mutable_szpppoeusername();
  inline ::std::string* release_szpppoeusername();
  
  // optional string szPPPoEPassword = 9;
  inline bool has_szpppoepassword() const;
  inline void clear_szpppoepassword();
  static const int kSzPPPoEPasswordFieldNumber = 9;
  inline const ::std::string& szpppoepassword() const;
  inline void set_szpppoepassword(const ::std::string& value);
  inline void set_szpppoepassword(const char* value);
  inline void set_szpppoepassword(const char* value, size_t size);
  inline ::std::string* mutable_szpppoepassword();
  inline ::std::string* release_szpppoepassword();
  
  // @@protoc_insertion_point(class_scope:BVCU.PUConfig.Ethernet)
 private:
  inline void set_has_bdhcp();
  inline void clear_has_bdhcp();
  inline void set_has_bpppoe();
  inline void clear_has_bpppoe();
  inline void set_has_bautodns();
  inline void clear_has_bautodns();
  inline void set_has_szip();
  inline void clear_has_szip();
  inline void set_has_sznetmask();
  inline void clear_has_sznetmask();
  inline void set_has_szgateway();
  inline void clear_has_szgateway();
  inline void set_has_szpppoeusername();
  inline void clear_has_szpppoeusername();
  inline void set_has_szpppoepassword();
  inline void clear_has_szpppoepassword();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 bdhcp_;
  ::google::protobuf::int32 bpppoe_;
  ::std::string* szip_;
  ::std::string* sznetmask_;
  ::std::string* szgateway_;
  ::google::protobuf::RepeatedPtrField< ::std::string> szdns_;
  ::std::string* szpppoeusername_;
  ::std::string* szpppoepassword_;
  ::google::protobuf::uint32 bautodns_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];
  
  friend void  protobuf_AddDesc_PUConfig_2eproto();
  friend void protobuf_AssignDesc_PUConfig_2eproto();
  friend void protobuf_ShutdownFile_PUConfig_2eproto();
  
  void InitAsDefaultInstance();
  static Ethernet* default_instance_;
};
// -------------------------------------------------------------------

class WifiHotSpot : public ::google::protobuf::Message {
 public:
  WifiHotSpot();
  virtual ~WifiHotSpot();
  
  WifiHotSpot(const WifiHotSpot& from);
  
  inline WifiHotSpot& operator=(const WifiHotSpot& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const WifiHotSpot& default_instance();
  
  void Swap(WifiHotSpot* other);
  
  // implements Message ----------------------------------------------
  
  WifiHotSpot* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const WifiHotSpot& from);
  void MergeFrom(const WifiHotSpot& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated string szProviderAll = 1;
  inline int szproviderall_size() const;
  inline void clear_szproviderall();
  static const int kSzProviderAllFieldNumber = 1;
  inline const ::std::string& szproviderall(int index) const;
  inline ::std::string* mutable_szproviderall(int index);
  inline void set_szproviderall(int index, const ::std::string& value);
  inline void set_szproviderall(int index, const char* value);
  inline void set_szproviderall(int index, const char* value, size_t size);
  inline ::std::string* add_szproviderall();
  inline void add_szproviderall(const ::std::string& value);
  inline void add_szproviderall(const char* value);
  inline void add_szproviderall(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& szproviderall() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_szproviderall();
  
  // optional uint32 iProviderIndex = 2;
  inline bool has_iproviderindex() const;
  inline void clear_iproviderindex();
  static const int kIProviderIndexFieldNumber = 2;
  inline ::google::protobuf::uint32 iproviderindex() const;
  inline void set_iproviderindex(::google::protobuf::uint32 value);
  
  // repeated string szAreaAll = 3;
  inline int szareaall_size() const;
  inline void clear_szareaall();
  static const int kSzAreaAllFieldNumber = 3;
  inline const ::std::string& szareaall(int index) const;
  inline ::std::string* mutable_szareaall(int index);
  inline void set_szareaall(int index, const ::std::string& value);
  inline void set_szareaall(int index, const char* value);
  inline void set_szareaall(int index, const char* value, size_t size);
  inline ::std::string* add_szareaall();
  inline void add_szareaall(const ::std::string& value);
  inline void add_szareaall(const char* value);
  inline void add_szareaall(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& szareaall() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_szareaall();
  
  // optional uint32 iAreaIndex = 4;
  inline bool has_iareaindex() const;
  inline void clear_iareaindex();
  static const int kIAreaIndexFieldNumber = 4;
  inline ::google::protobuf::uint32 iareaindex() const;
  inline void set_iareaindex(::google::protobuf::uint32 value);
  
  // optional string szUserName = 5;
  inline bool has_szusername() const;
  inline void clear_szusername();
  static const int kSzUserNameFieldNumber = 5;
  inline const ::std::string& szusername() const;
  inline void set_szusername(const ::std::string& value);
  inline void set_szusername(const char* value);
  inline void set_szusername(const char* value, size_t size);
  inline ::std::string* mutable_szusername();
  inline ::std::string* release_szusername();
  
  // optional bytes szPassword = 6;
  inline bool has_szpassword() const;
  inline void clear_szpassword();
  static const int kSzPasswordFieldNumber = 6;
  inline const ::std::string& szpassword() const;
  inline void set_szpassword(const ::std::string& value);
  inline void set_szpassword(const char* value);
  inline void set_szpassword(const void* value, size_t size);
  inline ::std::string* mutable_szpassword();
  inline ::std::string* release_szpassword();
  
  // @@protoc_insertion_point(class_scope:BVCU.PUConfig.WifiHotSpot)
 private:
  inline void set_has_iproviderindex();
  inline void clear_has_iproviderindex();
  inline void set_has_iareaindex();
  inline void clear_has_iareaindex();
  inline void set_has_szusername();
  inline void clear_has_szusername();
  inline void set_has_szpassword();
  inline void clear_has_szpassword();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::std::string> szproviderall_;
  ::google::protobuf::RepeatedPtrField< ::std::string> szareaall_;
  ::google::protobuf::uint32 iproviderindex_;
  ::google::protobuf::uint32 iareaindex_;
  ::std::string* szusername_;
  ::std::string* szpassword_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  friend void  protobuf_AddDesc_PUConfig_2eproto();
  friend void protobuf_AssignDesc_PUConfig_2eproto();
  friend void protobuf_ShutdownFile_PUConfig_2eproto();
  
  void InitAsDefaultInstance();
  static WifiHotSpot* default_instance_;
};
// -------------------------------------------------------------------

class WifiGeneral : public ::google::protobuf::Message {
 public:
  WifiGeneral();
  virtual ~WifiGeneral();
  
  WifiGeneral(const WifiGeneral& from);
  
  inline WifiGeneral& operator=(const WifiGeneral& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const WifiGeneral& default_instance();
  
  void Swap(WifiGeneral* other);
  
  // implements Message ----------------------------------------------
  
  WifiGeneral* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const WifiGeneral& from);
  void MergeFrom(const WifiGeneral& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string szSSID = 1;
  inline bool has_szssid() const;
  inline void clear_szssid();
  static const int kSzSSIDFieldNumber = 1;
  inline const ::std::string& szssid() const;
  inline void set_szssid(const ::std::string& value);
  inline void set_szssid(const char* value);
  inline void set_szssid(const char* value, size_t size);
  inline ::std::string* mutable_szssid();
  inline ::std::string* release_szssid();
  
  // optional uint32 iSecurityType = 2;
  inline bool has_isecuritytype() const;
  inline void clear_isecuritytype();
  static const int kISecurityTypeFieldNumber = 2;
  inline ::google::protobuf::uint32 isecuritytype() const;
  inline void set_isecuritytype(::google::protobuf::uint32 value);
  
  // optional uint32 iCryptType = 3;
  inline bool has_icrypttype() const;
  inline void clear_icrypttype();
  static const int kICryptTypeFieldNumber = 3;
  inline ::google::protobuf::uint32 icrypttype() const;
  inline void set_icrypttype(::google::protobuf::uint32 value);
  
  // repeated bytes szWEPKey = 4;
  inline int szwepkey_size() const;
  inline void clear_szwepkey();
  static const int kSzWEPKeyFieldNumber = 4;
  inline const ::std::string& szwepkey(int index) const;
  inline ::std::string* mutable_szwepkey(int index);
  inline void set_szwepkey(int index, const ::std::string& value);
  inline void set_szwepkey(int index, const char* value);
  inline void set_szwepkey(int index, const void* value, size_t size);
  inline ::std::string* add_szwepkey();
  inline void add_szwepkey(const ::std::string& value);
  inline void add_szwepkey(const char* value);
  inline void add_szwepkey(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& szwepkey() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_szwepkey();
  
  // optional bytes szWPAKey = 5;
  inline bool has_szwpakey() const;
  inline void clear_szwpakey();
  static const int kSzWPAKeyFieldNumber = 5;
  inline const ::std::string& szwpakey() const;
  inline void set_szwpakey(const ::std::string& value);
  inline void set_szwpakey(const char* value);
  inline void set_szwpakey(const void* value, size_t size);
  inline ::std::string* mutable_szwpakey();
  inline ::std::string* release_szwpakey();
  
  // optional int32 bDHCP = 6;
  inline bool has_bdhcp() const;
  inline void clear_bdhcp();
  static const int kBDHCPFieldNumber = 6;
  inline ::google::protobuf::int32 bdhcp() const;
  inline void set_bdhcp(::google::protobuf::int32 value);
  
  // optional int32 bPPPoE = 7;
  inline bool has_bpppoe() const;
  inline void clear_bpppoe();
  static const int kBPPPoEFieldNumber = 7;
  inline ::google::protobuf::int32 bpppoe() const;
  inline void set_bpppoe(::google::protobuf::int32 value);
  
  // optional uint32 bAutoDNS = 8;
  inline bool has_bautodns() const;
  inline void clear_bautodns();
  static const int kBAutoDNSFieldNumber = 8;
  inline ::google::protobuf::uint32 bautodns() const;
  inline void set_bautodns(::google::protobuf::uint32 value);
  
  // optional string szIP = 9;
  inline bool has_szip() const;
  inline void clear_szip();
  static const int kSzIPFieldNumber = 9;
  inline const ::std::string& szip() const;
  inline void set_szip(const ::std::string& value);
  inline void set_szip(const char* value);
  inline void set_szip(const char* value, size_t size);
  inline ::std::string* mutable_szip();
  inline ::std::string* release_szip();
  
  // optional string szNetMask = 10;
  inline bool has_sznetmask() const;
  inline void clear_sznetmask();
  static const int kSzNetMaskFieldNumber = 10;
  inline const ::std::string& sznetmask() const;
  inline void set_sznetmask(const ::std::string& value);
  inline void set_sznetmask(const char* value);
  inline void set_sznetmask(const char* value, size_t size);
  inline ::std::string* mutable_sznetmask();
  inline ::std::string* release_sznetmask();
  
  // optional string szGateway = 11;
  inline bool has_szgateway() const;
  inline void clear_szgateway();
  static const int kSzGatewayFieldNumber = 11;
  inline const ::std::string& szgateway() const;
  inline void set_szgateway(const ::std::string& value);
  inline void set_szgateway(const char* value);
  inline void set_szgateway(const char* value, size_t size);
  inline ::std::string* mutable_szgateway();
  inline ::std::string* release_szgateway();
  
  // repeated string szDNS = 12;
  inline int szdns_size() const;
  inline void clear_szdns();
  static const int kSzDNSFieldNumber = 12;
  inline const ::std::string& szdns(int index) const;
  inline ::std::string* mutable_szdns(int index);
  inline void set_szdns(int index, const ::std::string& value);
  inline void set_szdns(int index, const char* value);
  inline void set_szdns(int index, const char* value, size_t size);
  inline ::std::string* add_szdns();
  inline void add_szdns(const ::std::string& value);
  inline void add_szdns(const char* value);
  inline void add_szdns(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& szdns() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_szdns();
  
  // @@protoc_insertion_point(class_scope:BVCU.PUConfig.WifiGeneral)
 private:
  inline void set_has_szssid();
  inline void clear_has_szssid();
  inline void set_has_isecuritytype();
  inline void clear_has_isecuritytype();
  inline void set_has_icrypttype();
  inline void clear_has_icrypttype();
  inline void set_has_szwpakey();
  inline void clear_has_szwpakey();
  inline void set_has_bdhcp();
  inline void clear_has_bdhcp();
  inline void set_has_bpppoe();
  inline void clear_has_bpppoe();
  inline void set_has_bautodns();
  inline void clear_has_bautodns();
  inline void set_has_szip();
  inline void clear_has_szip();
  inline void set_has_sznetmask();
  inline void clear_has_sznetmask();
  inline void set_has_szgateway();
  inline void clear_has_szgateway();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* szssid_;
  ::google::protobuf::uint32 isecuritytype_;
  ::google::protobuf::uint32 icrypttype_;
  ::google::protobuf::RepeatedPtrField< ::std::string> szwepkey_;
  ::std::string* szwpakey_;
  ::google::protobuf::int32 bdhcp_;
  ::google::protobuf::int32 bpppoe_;
  ::std::string* szip_;
  ::std::string* sznetmask_;
  ::std::string* szgateway_;
  ::google::protobuf::RepeatedPtrField< ::std::string> szdns_;
  ::google::protobuf::uint32 bautodns_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(12 + 31) / 32];
  
  friend void  protobuf_AddDesc_PUConfig_2eproto();
  friend void protobuf_AssignDesc_PUConfig_2eproto();
  friend void protobuf_ShutdownFile_PUConfig_2eproto();
  
  void InitAsDefaultInstance();
  static WifiGeneral* default_instance_;
};
// -------------------------------------------------------------------

class Wifi : public ::google::protobuf::Message {
 public:
  Wifi();
  virtual ~Wifi();
  
  Wifi(const Wifi& from);
  
  inline Wifi& operator=(const Wifi& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Wifi& default_instance();
  
  void Swap(Wifi* other);
  
  // implements Message ----------------------------------------------
  
  Wifi* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Wifi& from);
  void MergeFrom(const Wifi& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional uint32 bEnable = 1;
  inline bool has_benable() const;
  inline void clear_benable();
  static const int kBEnableFieldNumber = 1;
  inline ::google::protobuf::uint32 benable() const;
  inline void set_benable(::google::protobuf::uint32 value);
  
  // optional uint32 iMode = 2;
  inline bool has_imode() const;
  inline void clear_imode();
  static const int kIModeFieldNumber = 2;
  inline ::google::protobuf::uint32 imode() const;
  inline void set_imode(::google::protobuf::uint32 value);
  
  // optional uint32 iSignalLevel = 3;
  inline bool has_isignallevel() const;
  inline void clear_isignallevel();
  static const int kISignalLevelFieldNumber = 3;
  inline ::google::protobuf::uint32 isignallevel() const;
  inline void set_isignallevel(::google::protobuf::uint32 value);
  
  // optional .BVCU.PUConfig.WifiGeneral stGeneral = 4;
  inline bool has_stgeneral() const;
  inline void clear_stgeneral();
  static const int kStGeneralFieldNumber = 4;
  inline const ::BVCU::PUConfig::WifiGeneral& stgeneral() const;
  inline ::BVCU::PUConfig::WifiGeneral* mutable_stgeneral();
  inline ::BVCU::PUConfig::WifiGeneral* release_stgeneral();
  
  // optional .BVCU.PUConfig.WifiHotSpot stHostSpot = 5;
  inline bool has_sthostspot() const;
  inline void clear_sthostspot();
  static const int kStHostSpotFieldNumber = 5;
  inline const ::BVCU::PUConfig::WifiHotSpot& sthostspot() const;
  inline ::BVCU::PUConfig::WifiHotSpot* mutable_sthostspot();
  inline ::BVCU::PUConfig::WifiHotSpot* release_sthostspot();
  
  // @@protoc_insertion_point(class_scope:BVCU.PUConfig.Wifi)
 private:
  inline void set_has_benable();
  inline void clear_has_benable();
  inline void set_has_imode();
  inline void clear_has_imode();
  inline void set_has_isignallevel();
  inline void clear_has_isignallevel();
  inline void set_has_stgeneral();
  inline void clear_has_stgeneral();
  inline void set_has_sthostspot();
  inline void clear_has_sthostspot();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint32 benable_;
  ::google::protobuf::uint32 imode_;
  ::BVCU::PUConfig::WifiGeneral* stgeneral_;
  ::BVCU::PUConfig::WifiHotSpot* sthostspot_;
  ::google::protobuf::uint32 isignallevel_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_PUConfig_2eproto();
  friend void protobuf_AssignDesc_PUConfig_2eproto();
  friend void protobuf_ShutdownFile_PUConfig_2eproto();
  
  void InitAsDefaultInstance();
  static Wifi* default_instance_;
};
// -------------------------------------------------------------------

class RadioNetwork : public ::google::protobuf::Message {
 public:
  RadioNetwork();
  virtual ~RadioNetwork();
  
  RadioNetwork(const RadioNetwork& from);
  
  inline RadioNetwork& operator=(const RadioNetwork& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RadioNetwork& default_instance();
  
  void Swap(RadioNetwork* other);
  
  // implements Message ----------------------------------------------
  
  RadioNetwork* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RadioNetwork& from);
  void MergeFrom(const RadioNetwork& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional uint32 bEnable = 1;
  inline bool has_benable() const;
  inline void clear_benable();
  static const int kBEnableFieldNumber = 1;
  inline ::google::protobuf::uint32 benable() const;
  inline void set_benable(::google::protobuf::uint32 value);
  
  // repeated uint32 iTypeAll = 2;
  inline int itypeall_size() const;
  inline void clear_itypeall();
  static const int kITypeAllFieldNumber = 2;
  inline ::google::protobuf::uint32 itypeall(int index) const;
  inline void set_itypeall(int index, ::google::protobuf::uint32 value);
  inline void add_itypeall(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      itypeall() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_itypeall();
  
  // optional uint32 iTypeIndex = 3;
  inline bool has_itypeindex() const;
  inline void clear_itypeindex();
  static const int kITypeIndexFieldNumber = 3;
  inline ::google::protobuf::uint32 itypeindex() const;
  inline void set_itypeindex(::google::protobuf::uint32 value);
  
  // optional string szModuleName = 4;
  inline bool has_szmodulename() const;
  inline void clear_szmodulename();
  static const int kSzModuleNameFieldNumber = 4;
  inline const ::std::string& szmodulename() const;
  inline void set_szmodulename(const ::std::string& value);
  inline void set_szmodulename(const char* value);
  inline void set_szmodulename(const char* value, size_t size);
  inline ::std::string* mutable_szmodulename();
  inline ::std::string* release_szmodulename();
  
  // optional string szUserName = 5;
  inline bool has_szusername() const;
  inline void clear_szusername();
  static const int kSzUserNameFieldNumber = 5;
  inline const ::std::string& szusername() const;
  inline void set_szusername(const ::std::string& value);
  inline void set_szusername(const char* value);
  inline void set_szusername(const char* value, size_t size);
  inline ::std::string* mutable_szusername();
  inline ::std::string* release_szusername();
  
  // optional bytes szPassword = 6;
  inline bool has_szpassword() const;
  inline void clear_szpassword();
  static const int kSzPasswordFieldNumber = 6;
  inline const ::std::string& szpassword() const;
  inline void set_szpassword(const ::std::string& value);
  inline void set_szpassword(const char* value);
  inline void set_szpassword(const void* value, size_t size);
  inline ::std::string* mutable_szpassword();
  inline ::std::string* release_szpassword();
  
  // optional string szAPN = 7;
  inline bool has_szapn() const;
  inline void clear_szapn();
  static const int kSzAPNFieldNumber = 7;
  inline const ::std::string& szapn() const;
  inline void set_szapn(const ::std::string& value);
  inline void set_szapn(const char* value);
  inline void set_szapn(const char* value, size_t size);
  inline ::std::string* mutable_szapn();
  inline ::std::string* release_szapn();
  
  // optional string szAccessNum = 8;
  inline bool has_szaccessnum() const;
  inline void clear_szaccessnum();
  static const int kSzAccessNumFieldNumber = 8;
  inline const ::std::string& szaccessnum() const;
  inline void set_szaccessnum(const ::std::string& value);
  inline void set_szaccessnum(const char* value);
  inline void set_szaccessnum(const char* value, size_t size);
  inline ::std::string* mutable_szaccessnum();
  inline ::std::string* release_szaccessnum();
  
  // optional string szCardNum = 9;
  inline bool has_szcardnum() const;
  inline void clear_szcardnum();
  static const int kSzCardNumFieldNumber = 9;
  inline const ::std::string& szcardnum() const;
  inline void set_szcardnum(const ::std::string& value);
  inline void set_szcardnum(const char* value);
  inline void set_szcardnum(const char* value, size_t size);
  inline ::std::string* mutable_szcardnum();
  inline ::std::string* release_szcardnum();
  
  // optional uint32 bOnline = 10;
  inline bool has_bonline() const;
  inline void clear_bonline();
  static const int kBOnlineFieldNumber = 10;
  inline ::google::protobuf::uint32 bonline() const;
  inline void set_bonline(::google::protobuf::uint32 value);
  
  // repeated uint32 iSignalLevel = 11;
  inline int isignallevel_size() const;
  inline void clear_isignallevel();
  static const int kISignalLevelFieldNumber = 11;
  inline ::google::protobuf::uint32 isignallevel(int index) const;
  inline void set_isignallevel(int index, ::google::protobuf::uint32 value);
  inline void add_isignallevel(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      isignallevel() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_isignallevel();
  
  // optional int32 iOnlineTime = 12;
  inline bool has_ionlinetime() const;
  inline void clear_ionlinetime();
  static const int kIOnlineTimeFieldNumber = 12;
  inline ::google::protobuf::int32 ionlinetime() const;
  inline void set_ionlinetime(::google::protobuf::int32 value);
  
  // optional int32 iTrafficDownload = 13;
  inline bool has_itrafficdownload() const;
  inline void clear_itrafficdownload();
  static const int kITrafficDownloadFieldNumber = 13;
  inline ::google::protobuf::int32 itrafficdownload() const;
  inline void set_itrafficdownload(::google::protobuf::int32 value);
  
  // optional int32 iTrafficUpload = 14;
  inline bool has_itrafficupload() const;
  inline void clear_itrafficupload();
  static const int kITrafficUploadFieldNumber = 14;
  inline ::google::protobuf::int32 itrafficupload() const;
  inline void set_itrafficupload(::google::protobuf::int32 value);
  
  // optional uint32 iSpeedDownload = 15;
  inline bool has_ispeeddownload() const;
  inline void clear_ispeeddownload();
  static const int kISpeedDownloadFieldNumber = 15;
  inline ::google::protobuf::uint32 ispeeddownload() const;
  inline void set_ispeeddownload(::google::protobuf::uint32 value);
  
  // optional uint32 iSpeedUpload = 16;
  inline bool has_ispeedupload() const;
  inline void clear_ispeedupload();
  static const int kISpeedUploadFieldNumber = 16;
  inline ::google::protobuf::uint32 ispeedupload() const;
  inline void set_ispeedupload(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:BVCU.PUConfig.RadioNetwork)
 private:
  inline void set_has_benable();
  inline void clear_has_benable();
  inline void set_has_itypeindex();
  inline void clear_has_itypeindex();
  inline void set_has_szmodulename();
  inline void clear_has_szmodulename();
  inline void set_has_szusername();
  inline void clear_has_szusername();
  inline void set_has_szpassword();
  inline void clear_has_szpassword();
  inline void set_has_szapn();
  inline void clear_has_szapn();
  inline void set_has_szaccessnum();
  inline void clear_has_szaccessnum();
  inline void set_has_szcardnum();
  inline void clear_has_szcardnum();
  inline void set_has_bonline();
  inline void clear_has_bonline();
  inline void set_has_ionlinetime();
  inline void clear_has_ionlinetime();
  inline void set_has_itrafficdownload();
  inline void clear_has_itrafficdownload();
  inline void set_has_itrafficupload();
  inline void clear_has_itrafficupload();
  inline void set_has_ispeeddownload();
  inline void clear_has_ispeeddownload();
  inline void set_has_ispeedupload();
  inline void clear_has_ispeedupload();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > itypeall_;
  ::google::protobuf::uint32 benable_;
  ::google::protobuf::uint32 itypeindex_;
  ::std::string* szmodulename_;
  ::std::string* szusername_;
  ::std::string* szpassword_;
  ::std::string* szapn_;
  ::std::string* szaccessnum_;
  ::std::string* szcardnum_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > isignallevel_;
  ::google::protobuf::uint32 bonline_;
  ::google::protobuf::int32 ionlinetime_;
  ::google::protobuf::int32 itrafficdownload_;
  ::google::protobuf::int32 itrafficupload_;
  ::google::protobuf::uint32 ispeeddownload_;
  ::google::protobuf::uint32 ispeedupload_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(16 + 31) / 32];
  
  friend void  protobuf_AddDesc_PUConfig_2eproto();
  friend void protobuf_AssignDesc_PUConfig_2eproto();
  friend void protobuf_ShutdownFile_PUConfig_2eproto();
  
  void InitAsDefaultInstance();
  static RadioNetwork* default_instance_;
};
// -------------------------------------------------------------------

class RadioNetworkAll : public ::google::protobuf::Message {
 public:
  RadioNetworkAll();
  virtual ~RadioNetworkAll();
  
  RadioNetworkAll(const RadioNetworkAll& from);
  
  inline RadioNetworkAll& operator=(const RadioNetworkAll& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RadioNetworkAll& default_instance();
  
  void Swap(RadioNetworkAll* other);
  
  // implements Message ----------------------------------------------
  
  RadioNetworkAll* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RadioNetworkAll& from);
  void MergeFrom(const RadioNetworkAll& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .BVCU.PUConfig.RadioNetwork stRadioNetwork = 1;
  inline int stradionetwork_size() const;
  inline void clear_stradionetwork();
  static const int kStRadioNetworkFieldNumber = 1;
  inline const ::BVCU::PUConfig::RadioNetwork& stradionetwork(int index) const;
  inline ::BVCU::PUConfig::RadioNetwork* mutable_stradionetwork(int index);
  inline ::BVCU::PUConfig::RadioNetwork* add_stradionetwork();
  inline const ::google::protobuf::RepeatedPtrField< ::BVCU::PUConfig::RadioNetwork >&
      stradionetwork() const;
  inline ::google::protobuf::RepeatedPtrField< ::BVCU::PUConfig::RadioNetwork >*
      mutable_stradionetwork();
  
  // @@protoc_insertion_point(class_scope:BVCU.PUConfig.RadioNetworkAll)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::BVCU::PUConfig::RadioNetwork > stradionetwork_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_PUConfig_2eproto();
  friend void protobuf_AssignDesc_PUConfig_2eproto();
  friend void protobuf_ShutdownFile_PUConfig_2eproto();
  
  void InitAsDefaultInstance();
  static RadioNetworkAll* default_instance_;
};
// -------------------------------------------------------------------

class RegisterServer : public ::google::protobuf::Message {
 public:
  RegisterServer();
  virtual ~RegisterServer();
  
  RegisterServer(const RegisterServer& from);
  
  inline RegisterServer& operator=(const RegisterServer& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RegisterServer& default_instance();
  
  void Swap(RegisterServer* other);
  
  // implements Message ----------------------------------------------
  
  RegisterServer* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RegisterServer& from);
  void MergeFrom(const RegisterServer& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string szAddr = 1;
  inline bool has_szaddr() const;
  inline void clear_szaddr();
  static const int kSzAddrFieldNumber = 1;
  inline const ::std::string& szaddr() const;
  inline void set_szaddr(const ::std::string& value);
  inline void set_szaddr(const char* value);
  inline void set_szaddr(const char* value, size_t size);
  inline ::std::string* mutable_szaddr();
  inline ::std::string* release_szaddr();
  
  // optional uint32 iPort = 2;
  inline bool has_iport() const;
  inline void clear_iport();
  static const int kIPortFieldNumber = 2;
  inline ::google::protobuf::uint32 iport() const;
  inline void set_iport(::google::protobuf::uint32 value);
  
  // optional uint32 iProto = 3;
  inline bool has_iproto() const;
  inline void clear_iproto();
  static const int kIProtoFieldNumber = 3;
  inline ::google::protobuf::uint32 iproto() const;
  inline void set_iproto(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:BVCU.PUConfig.RegisterServer)
 private:
  inline void set_has_szaddr();
  inline void clear_has_szaddr();
  inline void set_has_iport();
  inline void clear_has_iport();
  inline void set_has_iproto();
  inline void clear_has_iproto();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* szaddr_;
  ::google::protobuf::uint32 iport_;
  ::google::protobuf::uint32 iproto_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_PUConfig_2eproto();
  friend void protobuf_AssignDesc_PUConfig_2eproto();
  friend void protobuf_ShutdownFile_PUConfig_2eproto();
  
  void InitAsDefaultInstance();
  static RegisterServer* default_instance_;
};
// -------------------------------------------------------------------

class UpdateServer : public ::google::protobuf::Message {
 public:
  UpdateServer();
  virtual ~UpdateServer();
  
  UpdateServer(const UpdateServer& from);
  
  inline UpdateServer& operator=(const UpdateServer& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const UpdateServer& default_instance();
  
  void Swap(UpdateServer* other);
  
  // implements Message ----------------------------------------------
  
  UpdateServer* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UpdateServer& from);
  void MergeFrom(const UpdateServer& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string szAddr = 1;
  inline bool has_szaddr() const;
  inline void clear_szaddr();
  static const int kSzAddrFieldNumber = 1;
  inline const ::std::string& szaddr() const;
  inline void set_szaddr(const ::std::string& value);
  inline void set_szaddr(const char* value);
  inline void set_szaddr(const char* value, size_t size);
  inline ::std::string* mutable_szaddr();
  inline ::std::string* release_szaddr();
  
  // optional uint32 iPort = 2;
  inline bool has_iport() const;
  inline void clear_iport();
  static const int kIPortFieldNumber = 2;
  inline ::google::protobuf::uint32 iport() const;
  inline void set_iport(::google::protobuf::uint32 value);
  
  // optional string szUserName = 3;
  inline bool has_szusername() const;
  inline void clear_szusername();
  static const int kSzUserNameFieldNumber = 3;
  inline const ::std::string& szusername() const;
  inline void set_szusername(const ::std::string& value);
  inline void set_szusername(const char* value);
  inline void set_szusername(const char* value, size_t size);
  inline ::std::string* mutable_szusername();
  inline ::std::string* release_szusername();
  
  // optional bytes szPassword = 4;
  inline bool has_szpassword() const;
  inline void clear_szpassword();
  static const int kSzPasswordFieldNumber = 4;
  inline const ::std::string& szpassword() const;
  inline void set_szpassword(const ::std::string& value);
  inline void set_szpassword(const char* value);
  inline void set_szpassword(const void* value, size_t size);
  inline ::std::string* mutable_szpassword();
  inline ::std::string* release_szpassword();
  
  // optional uint32 iProto = 5;
  inline bool has_iproto() const;
  inline void clear_iproto();
  static const int kIProtoFieldNumber = 5;
  inline ::google::protobuf::uint32 iproto() const;
  inline void set_iproto(::google::protobuf::uint32 value);
  
  // optional string szPath = 6;
  inline bool has_szpath() const;
  inline void clear_szpath();
  static const int kSzPathFieldNumber = 6;
  inline const ::std::string& szpath() const;
  inline void set_szpath(const ::std::string& value);
  inline void set_szpath(const char* value);
  inline void set_szpath(const char* value, size_t size);
  inline ::std::string* mutable_szpath();
  inline ::std::string* release_szpath();
  
  // @@protoc_insertion_point(class_scope:BVCU.PUConfig.UpdateServer)
 private:
  inline void set_has_szaddr();
  inline void clear_has_szaddr();
  inline void set_has_iport();
  inline void clear_has_iport();
  inline void set_has_szusername();
  inline void clear_has_szusername();
  inline void set_has_szpassword();
  inline void clear_has_szpassword();
  inline void set_has_iproto();
  inline void clear_has_iproto();
  inline void set_has_szpath();
  inline void clear_has_szpath();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* szaddr_;
  ::std::string* szusername_;
  ::google::protobuf::uint32 iport_;
  ::google::protobuf::uint32 iproto_;
  ::std::string* szpassword_;
  ::std::string* szpath_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  friend void  protobuf_AddDesc_PUConfig_2eproto();
  friend void protobuf_AssignDesc_PUConfig_2eproto();
  friend void protobuf_ShutdownFile_PUConfig_2eproto();
  
  void InitAsDefaultInstance();
  static UpdateServer* default_instance_;
};
// -------------------------------------------------------------------

class EmailServer : public ::google::protobuf::Message {
 public:
  EmailServer();
  virtual ~EmailServer();
  
  EmailServer(const EmailServer& from);
  
  inline EmailServer& operator=(const EmailServer& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const EmailServer& default_instance();
  
  void Swap(EmailServer* other);
  
  // implements Message ----------------------------------------------
  
  EmailServer* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EmailServer& from);
  void MergeFrom(const EmailServer& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string szServerAddr = 1;
  inline bool has_szserveraddr() const;
  inline void clear_szserveraddr();
  static const int kSzServerAddrFieldNumber = 1;
  inline const ::std::string& szserveraddr() const;
  inline void set_szserveraddr(const ::std::string& value);
  inline void set_szserveraddr(const char* value);
  inline void set_szserveraddr(const char* value, size_t size);
  inline ::std::string* mutable_szserveraddr();
  inline ::std::string* release_szserveraddr();
  
  // optional uint32 iServerPort = 2;
  inline bool has_iserverport() const;
  inline void clear_iserverport();
  static const int kIServerPortFieldNumber = 2;
  inline ::google::protobuf::uint32 iserverport() const;
  inline void set_iserverport(::google::protobuf::uint32 value);
  
  // optional string szUserName = 3;
  inline bool has_szusername() const;
  inline void clear_szusername();
  static const int kSzUserNameFieldNumber = 3;
  inline const ::std::string& szusername() const;
  inline void set_szusername(const ::std::string& value);
  inline void set_szusername(const char* value);
  inline void set_szusername(const char* value, size_t size);
  inline ::std::string* mutable_szusername();
  inline ::std::string* release_szusername();
  
  // optional string szPassword = 4;
  inline bool has_szpassword() const;
  inline void clear_szpassword();
  static const int kSzPasswordFieldNumber = 4;
  inline const ::std::string& szpassword() const;
  inline void set_szpassword(const ::std::string& value);
  inline void set_szpassword(const char* value);
  inline void set_szpassword(const char* value, size_t size);
  inline ::std::string* mutable_szpassword();
  inline ::std::string* release_szpassword();
  
  // optional string szSenderAddr = 5;
  inline bool has_szsenderaddr() const;
  inline void clear_szsenderaddr();
  static const int kSzSenderAddrFieldNumber = 5;
  inline const ::std::string& szsenderaddr() const;
  inline void set_szsenderaddr(const ::std::string& value);
  inline void set_szsenderaddr(const char* value);
  inline void set_szsenderaddr(const char* value, size_t size);
  inline ::std::string* mutable_szsenderaddr();
  inline ::std::string* release_szsenderaddr();
  
  // optional uint32 bSSLEnable = 6;
  inline bool has_bsslenable() const;
  inline void clear_bsslenable();
  static const int kBSSLEnableFieldNumber = 6;
  inline ::google::protobuf::uint32 bsslenable() const;
  inline void set_bsslenable(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:BVCU.PUConfig.EmailServer)
 private:
  inline void set_has_szserveraddr();
  inline void clear_has_szserveraddr();
  inline void set_has_iserverport();
  inline void clear_has_iserverport();
  inline void set_has_szusername();
  inline void clear_has_szusername();
  inline void set_has_szpassword();
  inline void clear_has_szpassword();
  inline void set_has_szsenderaddr();
  inline void clear_has_szsenderaddr();
  inline void set_has_bsslenable();
  inline void clear_has_bsslenable();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* szserveraddr_;
  ::std::string* szusername_;
  ::std::string* szpassword_;
  ::google::protobuf::uint32 iserverport_;
  ::google::protobuf::uint32 bsslenable_;
  ::std::string* szsenderaddr_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  friend void  protobuf_AddDesc_PUConfig_2eproto();
  friend void protobuf_AssignDesc_PUConfig_2eproto();
  friend void protobuf_ShutdownFile_PUConfig_2eproto();
  
  void InitAsDefaultInstance();
  static EmailServer* default_instance_;
};
// -------------------------------------------------------------------

class NTPServer : public ::google::protobuf::Message {
 public:
  NTPServer();
  virtual ~NTPServer();
  
  NTPServer(const NTPServer& from);
  
  inline NTPServer& operator=(const NTPServer& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const NTPServer& default_instance();
  
  void Swap(NTPServer* other);
  
  // implements Message ----------------------------------------------
  
  NTPServer* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NTPServer& from);
  void MergeFrom(const NTPServer& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated string szAddr = 1;
  inline int szaddr_size() const;
  inline void clear_szaddr();
  static const int kSzAddrFieldNumber = 1;
  inline const ::std::string& szaddr(int index) const;
  inline ::std::string* mutable_szaddr(int index);
  inline void set_szaddr(int index, const ::std::string& value);
  inline void set_szaddr(int index, const char* value);
  inline void set_szaddr(int index, const char* value, size_t size);
  inline ::std::string* add_szaddr();
  inline void add_szaddr(const ::std::string& value);
  inline void add_szaddr(const char* value);
  inline void add_szaddr(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& szaddr() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_szaddr();
  
  // repeated uint32 iPort = 2;
  inline int iport_size() const;
  inline void clear_iport();
  static const int kIPortFieldNumber = 2;
  inline ::google::protobuf::uint32 iport(int index) const;
  inline void set_iport(int index, ::google::protobuf::uint32 value);
  inline void add_iport(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      iport() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_iport();
  
  // optional uint32 iUpdateInterval = 3;
  inline bool has_iupdateinterval() const;
  inline void clear_iupdateinterval();
  static const int kIUpdateIntervalFieldNumber = 3;
  inline ::google::protobuf::uint32 iupdateinterval() const;
  inline void set_iupdateinterval(::google::protobuf::uint32 value);
  
  // optional uint32 bUpdateImmediately = 4;
  inline bool has_bupdateimmediately() const;
  inline void clear_bupdateimmediately();
  static const int kBUpdateImmediatelyFieldNumber = 4;
  inline ::google::protobuf::uint32 bupdateimmediately() const;
  inline void set_bupdateimmediately(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:BVCU.PUConfig.NTPServer)
 private:
  inline void set_has_iupdateinterval();
  inline void clear_has_iupdateinterval();
  inline void set_has_bupdateimmediately();
  inline void clear_has_bupdateimmediately();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::std::string> szaddr_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > iport_;
  ::google::protobuf::uint32 iupdateinterval_;
  ::google::protobuf::uint32 bupdateimmediately_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_PUConfig_2eproto();
  friend void protobuf_AssignDesc_PUConfig_2eproto();
  friend void protobuf_ShutdownFile_PUConfig_2eproto();
  
  void InitAsDefaultInstance();
  static NTPServer* default_instance_;
};
// -------------------------------------------------------------------

class TimeSource : public ::google::protobuf::Message {
 public:
  TimeSource();
  virtual ~TimeSource();
  
  TimeSource(const TimeSource& from);
  
  inline TimeSource& operator=(const TimeSource& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const TimeSource& default_instance();
  
  void Swap(TimeSource* other);
  
  // implements Message ----------------------------------------------
  
  TimeSource* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TimeSource& from);
  void MergeFrom(const TimeSource& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional uint32 iTimeZone = 1;
  inline bool has_itimezone() const;
  inline void clear_itimezone();
  static const int kITimeZoneFieldNumber = 1;
  inline ::google::protobuf::uint32 itimezone() const;
  inline void set_itimezone(::google::protobuf::uint32 value);
  
  // optional uint32 bDST = 2;
  inline bool has_bdst() const;
  inline void clear_bdst();
  static const int kBDSTFieldNumber = 2;
  inline ::google::protobuf::uint32 bdst() const;
  inline void set_bdst(::google::protobuf::uint32 value);
  
  // optional .BVCU.PUConfig.NTPServer stNTPServer = 3;
  inline bool has_stntpserver() const;
  inline void clear_stntpserver();
  static const int kStNTPServerFieldNumber = 3;
  inline const ::BVCU::PUConfig::NTPServer& stntpserver() const;
  inline ::BVCU::PUConfig::NTPServer* mutable_stntpserver();
  inline ::BVCU::PUConfig::NTPServer* release_stntpserver();
  
  // optional uint32 iNTP = 4;
  inline bool has_intp() const;
  inline void clear_intp();
  static const int kINTPFieldNumber = 4;
  inline ::google::protobuf::uint32 intp() const;
  inline void set_intp(::google::protobuf::uint32 value);
  
  // optional uint32 iGPS = 5;
  inline bool has_igps() const;
  inline void clear_igps();
  static const int kIGPSFieldNumber = 5;
  inline ::google::protobuf::uint32 igps() const;
  inline void set_igps(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:BVCU.PUConfig.TimeSource)
 private:
  inline void set_has_itimezone();
  inline void clear_has_itimezone();
  inline void set_has_bdst();
  inline void clear_has_bdst();
  inline void set_has_stntpserver();
  inline void clear_has_stntpserver();
  inline void set_has_intp();
  inline void clear_has_intp();
  inline void set_has_igps();
  inline void clear_has_igps();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint32 itimezone_;
  ::google::protobuf::uint32 bdst_;
  ::BVCU::PUConfig::NTPServer* stntpserver_;
  ::google::protobuf::uint32 intp_;
  ::google::protobuf::uint32 igps_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_PUConfig_2eproto();
  friend void protobuf_AssignDesc_PUConfig_2eproto();
  friend void protobuf_ShutdownFile_PUConfig_2eproto();
  
  void InitAsDefaultInstance();
  static TimeSource* default_instance_;
};
// -------------------------------------------------------------------

class DDNS : public ::google::protobuf::Message {
 public:
  DDNS();
  virtual ~DDNS();
  
  DDNS(const DDNS& from);
  
  inline DDNS& operator=(const DDNS& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const DDNS& default_instance();
  
  void Swap(DDNS* other);
  
  // implements Message ----------------------------------------------
  
  DDNS* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DDNS& from);
  void MergeFrom(const DDNS& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 bDDNS = 1;
  inline bool has_bddns() const;
  inline void clear_bddns();
  static const int kBDDNSFieldNumber = 1;
  inline ::google::protobuf::int32 bddns() const;
  inline void set_bddns(::google::protobuf::int32 value);
  
  // optional string szDDNSProvider = 2;
  inline bool has_szddnsprovider() const;
  inline void clear_szddnsprovider();
  static const int kSzDDNSProviderFieldNumber = 2;
  inline const ::std::string& szddnsprovider() const;
  inline void set_szddnsprovider(const ::std::string& value);
  inline void set_szddnsprovider(const char* value);
  inline void set_szddnsprovider(const char* value, size_t size);
  inline ::std::string* mutable_szddnsprovider();
  inline ::std::string* release_szddnsprovider();
  
  // optional string szDDNSAddr = 3;
  inline bool has_szddnsaddr() const;
  inline void clear_szddnsaddr();
  static const int kSzDDNSAddrFieldNumber = 3;
  inline const ::std::string& szddnsaddr() const;
  inline void set_szddnsaddr(const ::std::string& value);
  inline void set_szddnsaddr(const char* value);
  inline void set_szddnsaddr(const char* value, size_t size);
  inline ::std::string* mutable_szddnsaddr();
  inline ::std::string* release_szddnsaddr();
  
  // optional string szDDNSUserName = 4;
  inline bool has_szddnsusername() const;
  inline void clear_szddnsusername();
  static const int kSzDDNSUserNameFieldNumber = 4;
  inline const ::std::string& szddnsusername() const;
  inline void set_szddnsusername(const ::std::string& value);
  inline void set_szddnsusername(const char* value);
  inline void set_szddnsusername(const char* value, size_t size);
  inline ::std::string* mutable_szddnsusername();
  inline ::std::string* release_szddnsusername();
  
  // optional bytes szDDNSPassword = 5;
  inline bool has_szddnspassword() const;
  inline void clear_szddnspassword();
  static const int kSzDDNSPasswordFieldNumber = 5;
  inline const ::std::string& szddnspassword() const;
  inline void set_szddnspassword(const ::std::string& value);
  inline void set_szddnspassword(const char* value);
  inline void set_szddnspassword(const void* value, size_t size);
  inline ::std::string* mutable_szddnspassword();
  inline ::std::string* release_szddnspassword();
  
  // optional string szDynamicName = 6;
  inline bool has_szdynamicname() const;
  inline void clear_szdynamicname();
  static const int kSzDynamicNameFieldNumber = 6;
  inline const ::std::string& szdynamicname() const;
  inline void set_szdynamicname(const ::std::string& value);
  inline void set_szdynamicname(const char* value);
  inline void set_szdynamicname(const char* value, size_t size);
  inline ::std::string* mutable_szdynamicname();
  inline ::std::string* release_szdynamicname();
  
  // @@protoc_insertion_point(class_scope:BVCU.PUConfig.DDNS)
 private:
  inline void set_has_bddns();
  inline void clear_has_bddns();
  inline void set_has_szddnsprovider();
  inline void clear_has_szddnsprovider();
  inline void set_has_szddnsaddr();
  inline void clear_has_szddnsaddr();
  inline void set_has_szddnsusername();
  inline void clear_has_szddnsusername();
  inline void set_has_szddnspassword();
  inline void clear_has_szddnspassword();
  inline void set_has_szdynamicname();
  inline void clear_has_szdynamicname();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* szddnsprovider_;
  ::std::string* szddnsaddr_;
  ::std::string* szddnsusername_;
  ::std::string* szddnspassword_;
  ::std::string* szdynamicname_;
  ::google::protobuf::int32 bddns_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  friend void  protobuf_AddDesc_PUConfig_2eproto();
  friend void protobuf_AssignDesc_PUConfig_2eproto();
  friend void protobuf_ShutdownFile_PUConfig_2eproto();
  
  void InitAsDefaultInstance();
  static DDNS* default_instance_;
};
// -------------------------------------------------------------------

class Servers : public ::google::protobuf::Message {
 public:
  Servers();
  virtual ~Servers();
  
  Servers(const Servers& from);
  
  inline Servers& operator=(const Servers& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Servers& default_instance();
  
  void Swap(Servers* other);
  
  // implements Message ----------------------------------------------
  
  Servers* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Servers& from);
  void MergeFrom(const Servers& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional .BVCU.PUConfig.RegisterServer stRegisterServer = 1;
  inline bool has_stregisterserver() const;
  inline void clear_stregisterserver();
  static const int kStRegisterServerFieldNumber = 1;
  inline const ::BVCU::PUConfig::RegisterServer& stregisterserver() const;
  inline ::BVCU::PUConfig::RegisterServer* mutable_stregisterserver();
  inline ::BVCU::PUConfig::RegisterServer* release_stregisterserver();
  
  // optional .BVCU.PUConfig.UpdateServer stUpdateServer = 2;
  inline bool has_stupdateserver() const;
  inline void clear_stupdateserver();
  static const int kStUpdateServerFieldNumber = 2;
  inline const ::BVCU::PUConfig::UpdateServer& stupdateserver() const;
  inline ::BVCU::PUConfig::UpdateServer* mutable_stupdateserver();
  inline ::BVCU::PUConfig::UpdateServer* release_stupdateserver();
  
  // optional .BVCU.PUConfig.TimeSource stTimeSource = 3;
  inline bool has_sttimesource() const;
  inline void clear_sttimesource();
  static const int kStTimeSourceFieldNumber = 3;
  inline const ::BVCU::PUConfig::TimeSource& sttimesource() const;
  inline ::BVCU::PUConfig::TimeSource* mutable_sttimesource();
  inline ::BVCU::PUConfig::TimeSource* release_sttimesource();
  
  // optional .BVCU.PUConfig.DDNS stDDNS = 4;
  inline bool has_stddns() const;
  inline void clear_stddns();
  static const int kStDDNSFieldNumber = 4;
  inline const ::BVCU::PUConfig::DDNS& stddns() const;
  inline ::BVCU::PUConfig::DDNS* mutable_stddns();
  inline ::BVCU::PUConfig::DDNS* release_stddns();
  
  // optional .BVCU.PUConfig.EmailServer stEmailServer = 5;
  inline bool has_stemailserver() const;
  inline void clear_stemailserver();
  static const int kStEmailServerFieldNumber = 5;
  inline const ::BVCU::PUConfig::EmailServer& stemailserver() const;
  inline ::BVCU::PUConfig::EmailServer* mutable_stemailserver();
  inline ::BVCU::PUConfig::EmailServer* release_stemailserver();
  
  // @@protoc_insertion_point(class_scope:BVCU.PUConfig.Servers)
 private:
  inline void set_has_stregisterserver();
  inline void clear_has_stregisterserver();
  inline void set_has_stupdateserver();
  inline void clear_has_stupdateserver();
  inline void set_has_sttimesource();
  inline void clear_has_sttimesource();
  inline void set_has_stddns();
  inline void clear_has_stddns();
  inline void set_has_stemailserver();
  inline void clear_has_stemailserver();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::BVCU::PUConfig::RegisterServer* stregisterserver_;
  ::BVCU::PUConfig::UpdateServer* stupdateserver_;
  ::BVCU::PUConfig::TimeSource* sttimesource_;
  ::BVCU::PUConfig::DDNS* stddns_;
  ::BVCU::PUConfig::EmailServer* stemailserver_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_PUConfig_2eproto();
  friend void protobuf_AssignDesc_PUConfig_2eproto();
  friend void protobuf_ShutdownFile_PUConfig_2eproto();
  
  void InitAsDefaultInstance();
  static Servers* default_instance_;
};
// -------------------------------------------------------------------

class Storage_Schedule : public ::google::protobuf::Message {
 public:
  Storage_Schedule();
  virtual ~Storage_Schedule();
  
  Storage_Schedule(const Storage_Schedule& from);
  
  inline Storage_Schedule& operator=(const Storage_Schedule& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Storage_Schedule& default_instance();
  
  void Swap(Storage_Schedule* other);
  
  // implements Message ----------------------------------------------
  
  Storage_Schedule* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Storage_Schedule& from);
  void MergeFrom(const Storage_Schedule& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional uint32 iChannelIndex = 1;
  inline bool has_ichannelindex() const;
  inline void clear_ichannelindex();
  static const int kIChannelIndexFieldNumber = 1;
  inline ::google::protobuf::uint32 ichannelindex() const;
  inline void set_ichannelindex(::google::protobuf::uint32 value);
  
  // optional .BVCU.PUConfig.WeekTimeSlice stWeekSnapshot = 2;
  inline bool has_stweeksnapshot() const;
  inline void clear_stweeksnapshot();
  static const int kStWeekSnapshotFieldNumber = 2;
  inline const ::BVCU::PUConfig::WeekTimeSlice& stweeksnapshot() const;
  inline ::BVCU::PUConfig::WeekTimeSlice* mutable_stweeksnapshot();
  inline ::BVCU::PUConfig::WeekTimeSlice* release_stweeksnapshot();
  
  // optional .BVCU.PUConfig.WeekTimeSlice stWeekRecord = 3;
  inline bool has_stweekrecord() const;
  inline void clear_stweekrecord();
  static const int kStWeekRecordFieldNumber = 3;
  inline const ::BVCU::PUConfig::WeekTimeSlice& stweekrecord() const;
  inline ::BVCU::PUConfig::WeekTimeSlice* mutable_stweekrecord();
  inline ::BVCU::PUConfig::WeekTimeSlice* release_stweekrecord();
  
  // optional uint32 bRecordAudio = 4;
  inline bool has_brecordaudio() const;
  inline void clear_brecordaudio();
  static const int kBRecordAudioFieldNumber = 4;
  inline ::google::protobuf::uint32 brecordaudio() const;
  inline void set_brecordaudio(::google::protobuf::uint32 value);
  
  // optional .BVCU.PUConfig.WallTime stBegin = 5;
  inline bool has_stbegin() const;
  inline void clear_stbegin();
  static const int kStBeginFieldNumber = 5;
  inline const ::BVCU::PUConfig::WallTime& stbegin() const;
  inline ::BVCU::PUConfig::WallTime* mutable_stbegin();
  inline ::BVCU::PUConfig::WallTime* release_stbegin();
  
  // optional .BVCU.PUConfig.WallTime stEnd = 6;
  inline bool has_stend() const;
  inline void clear_stend();
  static const int kStEndFieldNumber = 6;
  inline const ::BVCU::PUConfig::WallTime& stend() const;
  inline ::BVCU::PUConfig::WallTime* mutable_stend();
  inline ::BVCU::PUConfig::WallTime* release_stend();
  
  // @@protoc_insertion_point(class_scope:BVCU.PUConfig.Storage_Schedule)
 private:
  inline void set_has_ichannelindex();
  inline void clear_has_ichannelindex();
  inline void set_has_stweeksnapshot();
  inline void clear_has_stweeksnapshot();
  inline void set_has_stweekrecord();
  inline void clear_has_stweekrecord();
  inline void set_has_brecordaudio();
  inline void clear_has_brecordaudio();
  inline void set_has_stbegin();
  inline void clear_has_stbegin();
  inline void set_has_stend();
  inline void clear_has_stend();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::BVCU::PUConfig::WeekTimeSlice* stweeksnapshot_;
  ::google::protobuf::uint32 ichannelindex_;
  ::google::protobuf::uint32 brecordaudio_;
  ::BVCU::PUConfig::WeekTimeSlice* stweekrecord_;
  ::BVCU::PUConfig::WallTime* stbegin_;
  ::BVCU::PUConfig::WallTime* stend_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  friend void  protobuf_AddDesc_PUConfig_2eproto();
  friend void protobuf_AssignDesc_PUConfig_2eproto();
  friend void protobuf_ShutdownFile_PUConfig_2eproto();
  
  void InitAsDefaultInstance();
  static Storage_Schedule* default_instance_;
};
// -------------------------------------------------------------------

class Storage_Media : public ::google::protobuf::Message {
 public:
  Storage_Media();
  virtual ~Storage_Media();
  
  Storage_Media(const Storage_Media& from);
  
  inline Storage_Media& operator=(const Storage_Media& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Storage_Media& default_instance();
  
  void Swap(Storage_Media* other);
  
  // implements Message ----------------------------------------------
  
  Storage_Media* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Storage_Media& from);
  void MergeFrom(const Storage_Media& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string szMediaName = 7;
  inline bool has_szmedianame() const;
  inline void clear_szmedianame();
  static const int kSzMediaNameFieldNumber = 7;
  inline const ::std::string& szmedianame() const;
  inline void set_szmedianame(const ::std::string& value);
  inline void set_szmedianame(const char* value);
  inline void set_szmedianame(const char* value, size_t size);
  inline ::std::string* mutable_szmedianame();
  inline ::std::string* release_szmedianame();
  
  // optional uint32 iStorageMediaType = 1;
  inline bool has_istoragemediatype() const;
  inline void clear_istoragemediatype();
  static const int kIStorageMediaTypeFieldNumber = 1;
  inline ::google::protobuf::uint32 istoragemediatype() const;
  inline void set_istoragemediatype(::google::protobuf::uint32 value);
  
  // optional uint32 iTotalSpace = 2;
  inline bool has_itotalspace() const;
  inline void clear_itotalspace();
  static const int kITotalSpaceFieldNumber = 2;
  inline ::google::protobuf::uint32 itotalspace() const;
  inline void set_itotalspace(::google::protobuf::uint32 value);
  
  // optional uint32 iFreeSpace = 3;
  inline bool has_ifreespace() const;
  inline void clear_ifreespace();
  static const int kIFreeSpaceFieldNumber = 3;
  inline ::google::protobuf::uint32 ifreespace() const;
  inline void set_ifreespace(::google::protobuf::uint32 value);
  
  // optional uint32 bFormated = 4;
  inline bool has_bformated() const;
  inline void clear_bformated();
  static const int kBFormatedFieldNumber = 4;
  inline ::google::protobuf::uint32 bformated() const;
  inline void set_bformated(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:BVCU.PUConfig.Storage_Media)
 private:
  inline void set_has_szmedianame();
  inline void clear_has_szmedianame();
  inline void set_has_istoragemediatype();
  inline void clear_has_istoragemediatype();
  inline void set_has_itotalspace();
  inline void clear_has_itotalspace();
  inline void set_has_ifreespace();
  inline void clear_has_ifreespace();
  inline void set_has_bformated();
  inline void clear_has_bformated();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* szmedianame_;
  ::google::protobuf::uint32 istoragemediatype_;
  ::google::protobuf::uint32 itotalspace_;
  ::google::protobuf::uint32 ifreespace_;
  ::google::protobuf::uint32 bformated_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_PUConfig_2eproto();
  friend void protobuf_AssignDesc_PUConfig_2eproto();
  friend void protobuf_ShutdownFile_PUConfig_2eproto();
  
  void InitAsDefaultInstance();
  static Storage_Media* default_instance_;
};
// -------------------------------------------------------------------

class Storage_Rule : public ::google::protobuf::Message {
 public:
  Storage_Rule();
  virtual ~Storage_Rule();
  
  Storage_Rule(const Storage_Rule& from);
  
  inline Storage_Rule& operator=(const Storage_Rule& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Storage_Rule& default_instance();
  
  void Swap(Storage_Rule* other);
  
  // implements Message ----------------------------------------------
  
  Storage_Rule* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Storage_Rule& from);
  void MergeFrom(const Storage_Rule& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional uint32 iNoSpaceRule = 1;
  inline bool has_inospacerule() const;
  inline void clear_inospacerule();
  static const int kINoSpaceRuleFieldNumber = 1;
  inline ::google::protobuf::uint32 inospacerule() const;
  inline void set_inospacerule(::google::protobuf::uint32 value);
  
  // optional uint32 iAlarmSpace = 2;
  inline bool has_ialarmspace() const;
  inline void clear_ialarmspace();
  static const int kIAlarmSpaceFieldNumber = 2;
  inline ::google::protobuf::uint32 ialarmspace() const;
  inline void set_ialarmspace(::google::protobuf::uint32 value);
  
  // optional uint32 iReserveDays = 3;
  inline bool has_ireservedays() const;
  inline void clear_ireservedays();
  static const int kIReserveDaysFieldNumber = 3;
  inline ::google::protobuf::uint32 ireservedays() const;
  inline void set_ireservedays(::google::protobuf::uint32 value);
  
  // optional uint32 iRecordFileLength = 4;
  inline bool has_irecordfilelength() const;
  inline void clear_irecordfilelength();
  static const int kIRecordFileLengthFieldNumber = 4;
  inline ::google::protobuf::uint32 irecordfilelength() const;
  inline void set_irecordfilelength(::google::protobuf::uint32 value);
  
  // optional uint32 bRecordGPS = 5;
  inline bool has_brecordgps() const;
  inline void clear_brecordgps();
  static const int kBRecordGPSFieldNumber = 5;
  inline ::google::protobuf::uint32 brecordgps() const;
  inline void set_brecordgps(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:BVCU.PUConfig.Storage_Rule)
 private:
  inline void set_has_inospacerule();
  inline void clear_has_inospacerule();
  inline void set_has_ialarmspace();
  inline void clear_has_ialarmspace();
  inline void set_has_ireservedays();
  inline void clear_has_ireservedays();
  inline void set_has_irecordfilelength();
  inline void clear_has_irecordfilelength();
  inline void set_has_brecordgps();
  inline void clear_has_brecordgps();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint32 inospacerule_;
  ::google::protobuf::uint32 ialarmspace_;
  ::google::protobuf::uint32 ireservedays_;
  ::google::protobuf::uint32 irecordfilelength_;
  ::google::protobuf::uint32 brecordgps_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_PUConfig_2eproto();
  friend void protobuf_AssignDesc_PUConfig_2eproto();
  friend void protobuf_ShutdownFile_PUConfig_2eproto();
  
  void InitAsDefaultInstance();
  static Storage_Rule* default_instance_;
};
// -------------------------------------------------------------------

class Storage_Format : public ::google::protobuf::Message {
 public:
  Storage_Format();
  virtual ~Storage_Format();
  
  Storage_Format(const Storage_Format& from);
  
  inline Storage_Format& operator=(const Storage_Format& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Storage_Format& default_instance();
  
  void Swap(Storage_Format* other);
  
  // implements Message ----------------------------------------------
  
  Storage_Format* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Storage_Format& from);
  void MergeFrom(const Storage_Format& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional uint32 iAction = 1;
  inline bool has_iaction() const;
  inline void clear_iaction();
  static const int kIActionFieldNumber = 1;
  inline ::google::protobuf::uint32 iaction() const;
  inline void set_iaction(::google::protobuf::uint32 value);
  
  // optional uint32 iPercent = 2;
  inline bool has_ipercent() const;
  inline void clear_ipercent();
  static const int kIPercentFieldNumber = 2;
  inline ::google::protobuf::uint32 ipercent() const;
  inline void set_ipercent(::google::protobuf::uint32 value);
  
  // optional string szMediaName = 3;
  inline bool has_szmedianame() const;
  inline void clear_szmedianame();
  static const int kSzMediaNameFieldNumber = 3;
  inline const ::std::string& szmedianame() const;
  inline void set_szmedianame(const ::std::string& value);
  inline void set_szmedianame(const char* value);
  inline void set_szmedianame(const char* value, size_t size);
  inline ::std::string* mutable_szmedianame();
  inline ::std::string* release_szmedianame();
  
  // @@protoc_insertion_point(class_scope:BVCU.PUConfig.Storage_Format)
 private:
  inline void set_has_iaction();
  inline void clear_has_iaction();
  inline void set_has_ipercent();
  inline void clear_has_ipercent();
  inline void set_has_szmedianame();
  inline void clear_has_szmedianame();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint32 iaction_;
  ::google::protobuf::uint32 ipercent_;
  ::std::string* szmedianame_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_PUConfig_2eproto();
  friend void protobuf_AssignDesc_PUConfig_2eproto();
  friend void protobuf_ShutdownFile_PUConfig_2eproto();
  
  void InitAsDefaultInstance();
  static Storage_Format* default_instance_;
};
// -------------------------------------------------------------------

class OnlineControlOne : public ::google::protobuf::Message {
 public:
  OnlineControlOne();
  virtual ~OnlineControlOne();
  
  OnlineControlOne(const OnlineControlOne& from);
  
  inline OnlineControlOne& operator=(const OnlineControlOne& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const OnlineControlOne& default_instance();
  
  void Swap(OnlineControlOne* other);
  
  // implements Message ----------------------------------------------
  
  OnlineControlOne* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OnlineControlOne& from);
  void MergeFrom(const OnlineControlOne& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional uint32 iTrigger = 1;
  inline bool has_itrigger() const;
  inline void clear_itrigger();
  static const int kITriggerFieldNumber = 1;
  inline ::google::protobuf::uint32 itrigger() const;
  inline void set_itrigger(::google::protobuf::uint32 value);
  
  // optional uint32 iEvent = 2;
  inline bool has_ievent() const;
  inline void clear_ievent();
  static const int kIEventFieldNumber = 2;
  inline ::google::protobuf::uint32 ievent() const;
  inline void set_ievent(::google::protobuf::uint32 value);
  
  // optional int32 iOnlineTime = 3;
  inline bool has_ionlinetime() const;
  inline void clear_ionlinetime();
  static const int kIOnlineTimeFieldNumber = 3;
  inline ::google::protobuf::int32 ionlinetime() const;
  inline void set_ionlinetime(::google::protobuf::int32 value);
  
  // optional uint32 iThrough = 4;
  inline bool has_ithrough() const;
  inline void clear_ithrough();
  static const int kIThroughFieldNumber = 4;
  inline ::google::protobuf::uint32 ithrough() const;
  inline void set_ithrough(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:BVCU.PUConfig.OnlineControlOne)
 private:
  inline void set_has_itrigger();
  inline void clear_has_itrigger();
  inline void set_has_ievent();
  inline void clear_has_ievent();
  inline void set_has_ionlinetime();
  inline void clear_has_ionlinetime();
  inline void set_has_ithrough();
  inline void clear_has_ithrough();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint32 itrigger_;
  ::google::protobuf::uint32 ievent_;
  ::google::protobuf::int32 ionlinetime_;
  ::google::protobuf::uint32 ithrough_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_PUConfig_2eproto();
  friend void protobuf_AssignDesc_PUConfig_2eproto();
  friend void protobuf_ShutdownFile_PUConfig_2eproto();
  
  void InitAsDefaultInstance();
  static OnlineControlOne* default_instance_;
};
// -------------------------------------------------------------------

class OnlineEventSMS : public ::google::protobuf::Message {
 public:
  OnlineEventSMS();
  virtual ~OnlineEventSMS();
  
  OnlineEventSMS(const OnlineEventSMS& from);
  
  inline OnlineEventSMS& operator=(const OnlineEventSMS& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const OnlineEventSMS& default_instance();
  
  void Swap(OnlineEventSMS* other);
  
  // implements Message ----------------------------------------------
  
  OnlineEventSMS* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OnlineEventSMS& from);
  void MergeFrom(const OnlineEventSMS& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated string szCardNum = 1;
  inline int szcardnum_size() const;
  inline void clear_szcardnum();
  static const int kSzCardNumFieldNumber = 1;
  inline const ::std::string& szcardnum(int index) const;
  inline ::std::string* mutable_szcardnum(int index);
  inline void set_szcardnum(int index, const ::std::string& value);
  inline void set_szcardnum(int index, const char* value);
  inline void set_szcardnum(int index, const char* value, size_t size);
  inline ::std::string* add_szcardnum();
  inline void add_szcardnum(const ::std::string& value);
  inline void add_szcardnum(const char* value);
  inline void add_szcardnum(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& szcardnum() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_szcardnum();
  
  // optional string szContent = 2;
  inline bool has_szcontent() const;
  inline void clear_szcontent();
  static const int kSzContentFieldNumber = 2;
  inline const ::std::string& szcontent() const;
  inline void set_szcontent(const ::std::string& value);
  inline void set_szcontent(const char* value);
  inline void set_szcontent(const char* value, size_t size);
  inline ::std::string* mutable_szcontent();
  inline ::std::string* release_szcontent();
  
  // optional uint32 bReply = 3;
  inline bool has_breply() const;
  inline void clear_breply();
  static const int kBReplyFieldNumber = 3;
  inline ::google::protobuf::uint32 breply() const;
  inline void set_breply(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:BVCU.PUConfig.OnlineEventSMS)
 private:
  inline void set_has_szcontent();
  inline void clear_has_szcontent();
  inline void set_has_breply();
  inline void clear_has_breply();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::std::string> szcardnum_;
  ::std::string* szcontent_;
  ::google::protobuf::uint32 breply_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_PUConfig_2eproto();
  friend void protobuf_AssignDesc_PUConfig_2eproto();
  friend void protobuf_ShutdownFile_PUConfig_2eproto();
  
  void InitAsDefaultInstance();
  static OnlineEventSMS* default_instance_;
};
// -------------------------------------------------------------------

class OnlineControl_TimeSliceOnlineCtrl : public ::google::protobuf::Message {
 public:
  OnlineControl_TimeSliceOnlineCtrl();
  virtual ~OnlineControl_TimeSliceOnlineCtrl();
  
  OnlineControl_TimeSliceOnlineCtrl(const OnlineControl_TimeSliceOnlineCtrl& from);
  
  inline OnlineControl_TimeSliceOnlineCtrl& operator=(const OnlineControl_TimeSliceOnlineCtrl& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const OnlineControl_TimeSliceOnlineCtrl& default_instance();
  
  void Swap(OnlineControl_TimeSliceOnlineCtrl* other);
  
  // implements Message ----------------------------------------------
  
  OnlineControl_TimeSliceOnlineCtrl* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OnlineControl_TimeSliceOnlineCtrl& from);
  void MergeFrom(const OnlineControl_TimeSliceOnlineCtrl& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional .BVCU.PUConfig.DayTimeSlice stTime = 1;
  inline bool has_sttime() const;
  inline void clear_sttime();
  static const int kStTimeFieldNumber = 1;
  inline const ::BVCU::PUConfig::DayTimeSlice& sttime() const;
  inline ::BVCU::PUConfig::DayTimeSlice* mutable_sttime();
  inline ::BVCU::PUConfig::DayTimeSlice* release_sttime();
  
  // optional .BVCU.PUConfig.OnlineControlOne stRCO = 2;
  inline bool has_strco() const;
  inline void clear_strco();
  static const int kStRCOFieldNumber = 2;
  inline const ::BVCU::PUConfig::OnlineControlOne& strco() const;
  inline ::BVCU::PUConfig::OnlineControlOne* mutable_strco();
  inline ::BVCU::PUConfig::OnlineControlOne* release_strco();
  
  // @@protoc_insertion_point(class_scope:BVCU.PUConfig.OnlineControl.TimeSliceOnlineCtrl)
 private:
  inline void set_has_sttime();
  inline void clear_has_sttime();
  inline void set_has_strco();
  inline void clear_has_strco();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::BVCU::PUConfig::DayTimeSlice* sttime_;
  ::BVCU::PUConfig::OnlineControlOne* strco_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_PUConfig_2eproto();
  friend void protobuf_AssignDesc_PUConfig_2eproto();
  friend void protobuf_ShutdownFile_PUConfig_2eproto();
  
  void InitAsDefaultInstance();
  static OnlineControl_TimeSliceOnlineCtrl* default_instance_;
};
// -------------------------------------------------------------------

class OnlineControl_TimeSliceOnlineCtrls : public ::google::protobuf::Message {
 public:
  OnlineControl_TimeSliceOnlineCtrls();
  virtual ~OnlineControl_TimeSliceOnlineCtrls();
  
  OnlineControl_TimeSliceOnlineCtrls(const OnlineControl_TimeSliceOnlineCtrls& from);
  
  inline OnlineControl_TimeSliceOnlineCtrls& operator=(const OnlineControl_TimeSliceOnlineCtrls& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const OnlineControl_TimeSliceOnlineCtrls& default_instance();
  
  void Swap(OnlineControl_TimeSliceOnlineCtrls* other);
  
  // implements Message ----------------------------------------------
  
  OnlineControl_TimeSliceOnlineCtrls* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OnlineControl_TimeSliceOnlineCtrls& from);
  void MergeFrom(const OnlineControl_TimeSliceOnlineCtrls& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .BVCU.PUConfig.OnlineControl.TimeSliceOnlineCtrl stDay = 1;
  inline int stday_size() const;
  inline void clear_stday();
  static const int kStDayFieldNumber = 1;
  inline const ::BVCU::PUConfig::OnlineControl_TimeSliceOnlineCtrl& stday(int index) const;
  inline ::BVCU::PUConfig::OnlineControl_TimeSliceOnlineCtrl* mutable_stday(int index);
  inline ::BVCU::PUConfig::OnlineControl_TimeSliceOnlineCtrl* add_stday();
  inline const ::google::protobuf::RepeatedPtrField< ::BVCU::PUConfig::OnlineControl_TimeSliceOnlineCtrl >&
      stday() const;
  inline ::google::protobuf::RepeatedPtrField< ::BVCU::PUConfig::OnlineControl_TimeSliceOnlineCtrl >*
      mutable_stday();
  
  // @@protoc_insertion_point(class_scope:BVCU.PUConfig.OnlineControl.TimeSliceOnlineCtrls)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::BVCU::PUConfig::OnlineControl_TimeSliceOnlineCtrl > stday_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_PUConfig_2eproto();
  friend void protobuf_AssignDesc_PUConfig_2eproto();
  friend void protobuf_ShutdownFile_PUConfig_2eproto();
  
  void InitAsDefaultInstance();
  static OnlineControl_TimeSliceOnlineCtrls* default_instance_;
};
// -------------------------------------------------------------------

class OnlineControl : public ::google::protobuf::Message {
 public:
  OnlineControl();
  virtual ~OnlineControl();
  
  OnlineControl(const OnlineControl& from);
  
  inline OnlineControl& operator=(const OnlineControl& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const OnlineControl& default_instance();
  
  void Swap(OnlineControl* other);
  
  // implements Message ----------------------------------------------
  
  OnlineControl* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OnlineControl& from);
  void MergeFrom(const OnlineControl& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef OnlineControl_TimeSliceOnlineCtrl TimeSliceOnlineCtrl;
  typedef OnlineControl_TimeSliceOnlineCtrls TimeSliceOnlineCtrls;
  
  // accessors -------------------------------------------------------
  
  // repeated .BVCU.PUConfig.OnlineControl.TimeSliceOnlineCtrls stWeek = 1;
  inline int stweek_size() const;
  inline void clear_stweek();
  static const int kStWeekFieldNumber = 1;
  inline const ::BVCU::PUConfig::OnlineControl_TimeSliceOnlineCtrls& stweek(int index) const;
  inline ::BVCU::PUConfig::OnlineControl_TimeSliceOnlineCtrls* mutable_stweek(int index);
  inline ::BVCU::PUConfig::OnlineControl_TimeSliceOnlineCtrls* add_stweek();
  inline const ::google::protobuf::RepeatedPtrField< ::BVCU::PUConfig::OnlineControl_TimeSliceOnlineCtrls >&
      stweek() const;
  inline ::google::protobuf::RepeatedPtrField< ::BVCU::PUConfig::OnlineControl_TimeSliceOnlineCtrls >*
      mutable_stweek();
  
  // optional .BVCU.PUConfig.OnlineEventSMS stRESMS = 8;
  inline bool has_stresms() const;
  inline void clear_stresms();
  static const int kStRESMSFieldNumber = 8;
  inline const ::BVCU::PUConfig::OnlineEventSMS& stresms() const;
  inline ::BVCU::PUConfig::OnlineEventSMS* mutable_stresms();
  inline ::BVCU::PUConfig::OnlineEventSMS* release_stresms();
  
  // @@protoc_insertion_point(class_scope:BVCU.PUConfig.OnlineControl)
 private:
  inline void set_has_stresms();
  inline void clear_has_stresms();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::BVCU::PUConfig::OnlineControl_TimeSliceOnlineCtrls > stweek_;
  ::BVCU::PUConfig::OnlineEventSMS* stresms_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_PUConfig_2eproto();
  friend void protobuf_AssignDesc_PUConfig_2eproto();
  friend void protobuf_ShutdownFile_PUConfig_2eproto();
  
  void InitAsDefaultInstance();
  static OnlineControl* default_instance_;
};
// ===================================================================


// ===================================================================

// ImageSize

// optional uint32 iWidth = 1;
inline bool ImageSize::has_iwidth() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ImageSize::set_has_iwidth() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ImageSize::clear_has_iwidth() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ImageSize::clear_iwidth() {
  iwidth_ = 0u;
  clear_has_iwidth();
}
inline ::google::protobuf::uint32 ImageSize::iwidth() const {
  return iwidth_;
}
inline void ImageSize::set_iwidth(::google::protobuf::uint32 value) {
  set_has_iwidth();
  iwidth_ = value;
}

// optional uint32 iHeight = 2;
inline bool ImageSize::has_iheight() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ImageSize::set_has_iheight() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ImageSize::clear_has_iheight() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ImageSize::clear_iheight() {
  iheight_ = 0u;
  clear_has_iheight();
}
inline ::google::protobuf::uint32 ImageSize::iheight() const {
  return iheight_;
}
inline void ImageSize::set_iheight(::google::protobuf::uint32 value) {
  set_has_iheight();
  iheight_ = value;
}

// -------------------------------------------------------------------

// ImageRect

// optional uint32 iLeft = 1;
inline bool ImageRect::has_ileft() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ImageRect::set_has_ileft() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ImageRect::clear_has_ileft() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ImageRect::clear_ileft() {
  ileft_ = 0u;
  clear_has_ileft();
}
inline ::google::protobuf::uint32 ImageRect::ileft() const {
  return ileft_;
}
inline void ImageRect::set_ileft(::google::protobuf::uint32 value) {
  set_has_ileft();
  ileft_ = value;
}

// optional uint32 iTop = 2;
inline bool ImageRect::has_itop() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ImageRect::set_has_itop() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ImageRect::clear_has_itop() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ImageRect::clear_itop() {
  itop_ = 0u;
  clear_has_itop();
}
inline ::google::protobuf::uint32 ImageRect::itop() const {
  return itop_;
}
inline void ImageRect::set_itop(::google::protobuf::uint32 value) {
  set_has_itop();
  itop_ = value;
}

// optional uint32 iWidth = 3;
inline bool ImageRect::has_iwidth() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ImageRect::set_has_iwidth() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ImageRect::clear_has_iwidth() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ImageRect::clear_iwidth() {
  iwidth_ = 0u;
  clear_has_iwidth();
}
inline ::google::protobuf::uint32 ImageRect::iwidth() const {
  return iwidth_;
}
inline void ImageRect::set_iwidth(::google::protobuf::uint32 value) {
  set_has_iwidth();
  iwidth_ = value;
}

// optional uint32 iHeight = 4;
inline bool ImageRect::has_iheight() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ImageRect::set_has_iheight() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ImageRect::clear_has_iheight() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ImageRect::clear_iheight() {
  iheight_ = 0u;
  clear_has_iheight();
}
inline ::google::protobuf::uint32 ImageRect::iheight() const {
  return iheight_;
}
inline void ImageRect::set_iheight(::google::protobuf::uint32 value) {
  set_has_iheight();
  iheight_ = value;
}

// -------------------------------------------------------------------

// DayTimeSlice

// optional uint32 cHourBegin = 1;
inline bool DayTimeSlice::has_chourbegin() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DayTimeSlice::set_has_chourbegin() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DayTimeSlice::clear_has_chourbegin() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DayTimeSlice::clear_chourbegin() {
  chourbegin_ = 0u;
  clear_has_chourbegin();
}
inline ::google::protobuf::uint32 DayTimeSlice::chourbegin() const {
  return chourbegin_;
}
inline void DayTimeSlice::set_chourbegin(::google::protobuf::uint32 value) {
  set_has_chourbegin();
  chourbegin_ = value;
}

// optional uint32 cMinuteBegin = 2;
inline bool DayTimeSlice::has_cminutebegin() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DayTimeSlice::set_has_cminutebegin() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DayTimeSlice::clear_has_cminutebegin() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DayTimeSlice::clear_cminutebegin() {
  cminutebegin_ = 0u;
  clear_has_cminutebegin();
}
inline ::google::protobuf::uint32 DayTimeSlice::cminutebegin() const {
  return cminutebegin_;
}
inline void DayTimeSlice::set_cminutebegin(::google::protobuf::uint32 value) {
  set_has_cminutebegin();
  cminutebegin_ = value;
}

// optional uint32 cSecondBegin = 3;
inline bool DayTimeSlice::has_csecondbegin() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DayTimeSlice::set_has_csecondbegin() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DayTimeSlice::clear_has_csecondbegin() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DayTimeSlice::clear_csecondbegin() {
  csecondbegin_ = 0u;
  clear_has_csecondbegin();
}
inline ::google::protobuf::uint32 DayTimeSlice::csecondbegin() const {
  return csecondbegin_;
}
inline void DayTimeSlice::set_csecondbegin(::google::protobuf::uint32 value) {
  set_has_csecondbegin();
  csecondbegin_ = value;
}

// optional uint32 cHourEnd = 4 [default = 24];
inline bool DayTimeSlice::has_chourend() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DayTimeSlice::set_has_chourend() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DayTimeSlice::clear_has_chourend() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DayTimeSlice::clear_chourend() {
  chourend_ = 24u;
  clear_has_chourend();
}
inline ::google::protobuf::uint32 DayTimeSlice::chourend() const {
  return chourend_;
}
inline void DayTimeSlice::set_chourend(::google::protobuf::uint32 value) {
  set_has_chourend();
  chourend_ = value;
}

// optional uint32 cMinuteEnd = 5;
inline bool DayTimeSlice::has_cminuteend() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DayTimeSlice::set_has_cminuteend() {
  _has_bits_[0] |= 0x00000010u;
}
inline void DayTimeSlice::clear_has_cminuteend() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void DayTimeSlice::clear_cminuteend() {
  cminuteend_ = 0u;
  clear_has_cminuteend();
}
inline ::google::protobuf::uint32 DayTimeSlice::cminuteend() const {
  return cminuteend_;
}
inline void DayTimeSlice::set_cminuteend(::google::protobuf::uint32 value) {
  set_has_cminuteend();
  cminuteend_ = value;
}

// optional uint32 cSecondEnd = 6;
inline bool DayTimeSlice::has_csecondend() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void DayTimeSlice::set_has_csecondend() {
  _has_bits_[0] |= 0x00000020u;
}
inline void DayTimeSlice::clear_has_csecondend() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void DayTimeSlice::clear_csecondend() {
  csecondend_ = 0u;
  clear_has_csecondend();
}
inline ::google::protobuf::uint32 DayTimeSlice::csecondend() const {
  return csecondend_;
}
inline void DayTimeSlice::set_csecondend(::google::protobuf::uint32 value) {
  set_has_csecondend();
  csecondend_ = value;
}

// -------------------------------------------------------------------

// WeekTimeSlice_DayTimeSlices

// repeated .BVCU.PUConfig.DayTimeSlice stDay = 1;
inline int WeekTimeSlice_DayTimeSlices::stday_size() const {
  return stday_.size();
}
inline void WeekTimeSlice_DayTimeSlices::clear_stday() {
  stday_.Clear();
}
inline const ::BVCU::PUConfig::DayTimeSlice& WeekTimeSlice_DayTimeSlices::stday(int index) const {
  return stday_.Get(index);
}
inline ::BVCU::PUConfig::DayTimeSlice* WeekTimeSlice_DayTimeSlices::mutable_stday(int index) {
  return stday_.Mutable(index);
}
inline ::BVCU::PUConfig::DayTimeSlice* WeekTimeSlice_DayTimeSlices::add_stday() {
  return stday_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::BVCU::PUConfig::DayTimeSlice >&
WeekTimeSlice_DayTimeSlices::stday() const {
  return stday_;
}
inline ::google::protobuf::RepeatedPtrField< ::BVCU::PUConfig::DayTimeSlice >*
WeekTimeSlice_DayTimeSlices::mutable_stday() {
  return &stday_;
}

// -------------------------------------------------------------------

// WeekTimeSlice

// repeated .BVCU.PUConfig.WeekTimeSlice.DayTimeSlices stWeek = 1;
inline int WeekTimeSlice::stweek_size() const {
  return stweek_.size();
}
inline void WeekTimeSlice::clear_stweek() {
  stweek_.Clear();
}
inline const ::BVCU::PUConfig::WeekTimeSlice_DayTimeSlices& WeekTimeSlice::stweek(int index) const {
  return stweek_.Get(index);
}
inline ::BVCU::PUConfig::WeekTimeSlice_DayTimeSlices* WeekTimeSlice::mutable_stweek(int index) {
  return stweek_.Mutable(index);
}
inline ::BVCU::PUConfig::WeekTimeSlice_DayTimeSlices* WeekTimeSlice::add_stweek() {
  return stweek_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::BVCU::PUConfig::WeekTimeSlice_DayTimeSlices >&
WeekTimeSlice::stweek() const {
  return stweek_;
}
inline ::google::protobuf::RepeatedPtrField< ::BVCU::PUConfig::WeekTimeSlice_DayTimeSlices >*
WeekTimeSlice::mutable_stweek() {
  return &stweek_;
}

// -------------------------------------------------------------------

// WallTime

// optional uint32 iYear = 1;
inline bool WallTime::has_iyear() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void WallTime::set_has_iyear() {
  _has_bits_[0] |= 0x00000001u;
}
inline void WallTime::clear_has_iyear() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void WallTime::clear_iyear() {
  iyear_ = 0u;
  clear_has_iyear();
}
inline ::google::protobuf::uint32 WallTime::iyear() const {
  return iyear_;
}
inline void WallTime::set_iyear(::google::protobuf::uint32 value) {
  set_has_iyear();
  iyear_ = value;
}

// optional uint32 iMonth = 2;
inline bool WallTime::has_imonth() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void WallTime::set_has_imonth() {
  _has_bits_[0] |= 0x00000002u;
}
inline void WallTime::clear_has_imonth() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void WallTime::clear_imonth() {
  imonth_ = 0u;
  clear_has_imonth();
}
inline ::google::protobuf::uint32 WallTime::imonth() const {
  return imonth_;
}
inline void WallTime::set_imonth(::google::protobuf::uint32 value) {
  set_has_imonth();
  imonth_ = value;
}

// optional uint32 iDay = 3;
inline bool WallTime::has_iday() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void WallTime::set_has_iday() {
  _has_bits_[0] |= 0x00000004u;
}
inline void WallTime::clear_has_iday() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void WallTime::clear_iday() {
  iday_ = 0u;
  clear_has_iday();
}
inline ::google::protobuf::uint32 WallTime::iday() const {
  return iday_;
}
inline void WallTime::set_iday(::google::protobuf::uint32 value) {
  set_has_iday();
  iday_ = value;
}

// optional uint32 iHour = 4;
inline bool WallTime::has_ihour() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void WallTime::set_has_ihour() {
  _has_bits_[0] |= 0x00000008u;
}
inline void WallTime::clear_has_ihour() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void WallTime::clear_ihour() {
  ihour_ = 0u;
  clear_has_ihour();
}
inline ::google::protobuf::uint32 WallTime::ihour() const {
  return ihour_;
}
inline void WallTime::set_ihour(::google::protobuf::uint32 value) {
  set_has_ihour();
  ihour_ = value;
}

// optional uint32 iMinute = 5;
inline bool WallTime::has_iminute() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void WallTime::set_has_iminute() {
  _has_bits_[0] |= 0x00000010u;
}
inline void WallTime::clear_has_iminute() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void WallTime::clear_iminute() {
  iminute_ = 0u;
  clear_has_iminute();
}
inline ::google::protobuf::uint32 WallTime::iminute() const {
  return iminute_;
}
inline void WallTime::set_iminute(::google::protobuf::uint32 value) {
  set_has_iminute();
  iminute_ = value;
}

// optional uint32 iSecond = 6;
inline bool WallTime::has_isecond() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void WallTime::set_has_isecond() {
  _has_bits_[0] |= 0x00000020u;
}
inline void WallTime::clear_has_isecond() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void WallTime::clear_isecond() {
  isecond_ = 0u;
  clear_has_isecond();
}
inline ::google::protobuf::uint32 WallTime::isecond() const {
  return isecond_;
}
inline void WallTime::set_isecond(::google::protobuf::uint32 value) {
  set_has_isecond();
  isecond_ = value;
}

// -------------------------------------------------------------------

// VideoFormat

// optional uint32 iVideoForamt = 1;
inline bool VideoFormat::has_ivideoforamt() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VideoFormat::set_has_ivideoforamt() {
  _has_bits_[0] |= 0x00000001u;
}
inline void VideoFormat::clear_has_ivideoforamt() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void VideoFormat::clear_ivideoforamt() {
  ivideoforamt_ = 0u;
  clear_has_ivideoforamt();
}
inline ::google::protobuf::uint32 VideoFormat::ivideoforamt() const {
  return ivideoforamt_;
}
inline void VideoFormat::set_ivideoforamt(::google::protobuf::uint32 value) {
  set_has_ivideoforamt();
  ivideoforamt_ = value;
}

// repeated .BVCU.PUConfig.ImageSize stImageSize = 2;
inline int VideoFormat::stimagesize_size() const {
  return stimagesize_.size();
}
inline void VideoFormat::clear_stimagesize() {
  stimagesize_.Clear();
}
inline const ::BVCU::PUConfig::ImageSize& VideoFormat::stimagesize(int index) const {
  return stimagesize_.Get(index);
}
inline ::BVCU::PUConfig::ImageSize* VideoFormat::mutable_stimagesize(int index) {
  return stimagesize_.Mutable(index);
}
inline ::BVCU::PUConfig::ImageSize* VideoFormat::add_stimagesize() {
  return stimagesize_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::BVCU::PUConfig::ImageSize >&
VideoFormat::stimagesize() const {
  return stimagesize_;
}
inline ::google::protobuf::RepeatedPtrField< ::BVCU::PUConfig::ImageSize >*
VideoFormat::mutable_stimagesize() {
  return &stimagesize_;
}

// repeated uint32 iFPSMax = 3;
inline int VideoFormat::ifpsmax_size() const {
  return ifpsmax_.size();
}
inline void VideoFormat::clear_ifpsmax() {
  ifpsmax_.Clear();
}
inline ::google::protobuf::uint32 VideoFormat::ifpsmax(int index) const {
  return ifpsmax_.Get(index);
}
inline void VideoFormat::set_ifpsmax(int index, ::google::protobuf::uint32 value) {
  ifpsmax_.Set(index, value);
}
inline void VideoFormat::add_ifpsmax(::google::protobuf::uint32 value) {
  ifpsmax_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
VideoFormat::ifpsmax() const {
  return ifpsmax_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
VideoFormat::mutable_ifpsmax() {
  return &ifpsmax_;
}

// optional uint32 iIndex = 4;
inline bool VideoFormat::has_iindex() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void VideoFormat::set_has_iindex() {
  _has_bits_[0] |= 0x00000008u;
}
inline void VideoFormat::clear_has_iindex() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void VideoFormat::clear_iindex() {
  iindex_ = 0u;
  clear_has_iindex();
}
inline ::google::protobuf::uint32 VideoFormat::iindex() const {
  return iindex_;
}
inline void VideoFormat::set_iindex(::google::protobuf::uint32 value) {
  set_has_iindex();
  iindex_ = value;
}

// -------------------------------------------------------------------

// ImagePos

// optional uint32 iLeft = 1;
inline bool ImagePos::has_ileft() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ImagePos::set_has_ileft() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ImagePos::clear_has_ileft() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ImagePos::clear_ileft() {
  ileft_ = 0u;
  clear_has_ileft();
}
inline ::google::protobuf::uint32 ImagePos::ileft() const {
  return ileft_;
}
inline void ImagePos::set_ileft(::google::protobuf::uint32 value) {
  set_has_ileft();
  ileft_ = value;
}

// optional uint32 iTop = 2;
inline bool ImagePos::has_itop() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ImagePos::set_has_itop() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ImagePos::clear_has_itop() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ImagePos::clear_itop() {
  itop_ = 0u;
  clear_has_itop();
}
inline ::google::protobuf::uint32 ImagePos::itop() const {
  return itop_;
}
inline void ImagePos::set_itop(::google::protobuf::uint32 value) {
  set_has_itop();
  itop_ = value;
}

// -------------------------------------------------------------------

// PUOneChannelInfo

// optional uint32 iChannelIndex = 4;
inline bool PUOneChannelInfo::has_ichannelindex() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PUOneChannelInfo::set_has_ichannelindex() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PUOneChannelInfo::clear_has_ichannelindex() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PUOneChannelInfo::clear_ichannelindex() {
  ichannelindex_ = 0u;
  clear_has_ichannelindex();
}
inline ::google::protobuf::uint32 PUOneChannelInfo::ichannelindex() const {
  return ichannelindex_;
}
inline void PUOneChannelInfo::set_ichannelindex(::google::protobuf::uint32 value) {
  set_has_ichannelindex();
  ichannelindex_ = value;
}

// required uint32 iMediaDir = 1;
inline bool PUOneChannelInfo::has_imediadir() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PUOneChannelInfo::set_has_imediadir() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PUOneChannelInfo::clear_has_imediadir() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PUOneChannelInfo::clear_imediadir() {
  imediadir_ = 0u;
  clear_has_imediadir();
}
inline ::google::protobuf::uint32 PUOneChannelInfo::imediadir() const {
  return imediadir_;
}
inline void PUOneChannelInfo::set_imediadir(::google::protobuf::uint32 value) {
  set_has_imediadir();
  imediadir_ = value;
}

// required int32 iPTZ = 2;
inline bool PUOneChannelInfo::has_iptz() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PUOneChannelInfo::set_has_iptz() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PUOneChannelInfo::clear_has_iptz() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PUOneChannelInfo::clear_iptz() {
  iptz_ = 0;
  clear_has_iptz();
}
inline ::google::protobuf::int32 PUOneChannelInfo::iptz() const {
  return iptz_;
}
inline void PUOneChannelInfo::set_iptz(::google::protobuf::int32 value) {
  set_has_iptz();
  iptz_ = value;
}

// optional string szName = 3;
inline bool PUOneChannelInfo::has_szname() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PUOneChannelInfo::set_has_szname() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PUOneChannelInfo::clear_has_szname() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PUOneChannelInfo::clear_szname() {
  if (szname_ != &::google::protobuf::internal::kEmptyString) {
    szname_->clear();
  }
  clear_has_szname();
}
inline const ::std::string& PUOneChannelInfo::szname() const {
  return *szname_;
}
inline void PUOneChannelInfo::set_szname(const ::std::string& value) {
  set_has_szname();
  if (szname_ == &::google::protobuf::internal::kEmptyString) {
    szname_ = new ::std::string;
  }
  szname_->assign(value);
}
inline void PUOneChannelInfo::set_szname(const char* value) {
  set_has_szname();
  if (szname_ == &::google::protobuf::internal::kEmptyString) {
    szname_ = new ::std::string;
  }
  szname_->assign(value);
}
inline void PUOneChannelInfo::set_szname(const char* value, size_t size) {
  set_has_szname();
  if (szname_ == &::google::protobuf::internal::kEmptyString) {
    szname_ = new ::std::string;
  }
  szname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PUOneChannelInfo::mutable_szname() {
  set_has_szname();
  if (szname_ == &::google::protobuf::internal::kEmptyString) {
    szname_ = new ::std::string;
  }
  return szname_;
}
inline ::std::string* PUOneChannelInfo::release_szname() {
  clear_has_szname();
  if (szname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = szname_;
    szname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// PUChannelInfo

// required string szID = 1;
inline bool PUChannelInfo::has_szid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PUChannelInfo::set_has_szid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PUChannelInfo::clear_has_szid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PUChannelInfo::clear_szid() {
  if (szid_ != &::google::protobuf::internal::kEmptyString) {
    szid_->clear();
  }
  clear_has_szid();
}
inline const ::std::string& PUChannelInfo::szid() const {
  return *szid_;
}
inline void PUChannelInfo::set_szid(const ::std::string& value) {
  set_has_szid();
  if (szid_ == &::google::protobuf::internal::kEmptyString) {
    szid_ = new ::std::string;
  }
  szid_->assign(value);
}
inline void PUChannelInfo::set_szid(const char* value) {
  set_has_szid();
  if (szid_ == &::google::protobuf::internal::kEmptyString) {
    szid_ = new ::std::string;
  }
  szid_->assign(value);
}
inline void PUChannelInfo::set_szid(const char* value, size_t size) {
  set_has_szid();
  if (szid_ == &::google::protobuf::internal::kEmptyString) {
    szid_ = new ::std::string;
  }
  szid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PUChannelInfo::mutable_szid() {
  set_has_szid();
  if (szid_ == &::google::protobuf::internal::kEmptyString) {
    szid_ = new ::std::string;
  }
  return szid_;
}
inline ::std::string* PUChannelInfo::release_szid() {
  clear_has_szid();
  if (szid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = szid_;
    szid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string szPUName = 2;
inline bool PUChannelInfo::has_szpuname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PUChannelInfo::set_has_szpuname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PUChannelInfo::clear_has_szpuname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PUChannelInfo::clear_szpuname() {
  if (szpuname_ != &::google::protobuf::internal::kEmptyString) {
    szpuname_->clear();
  }
  clear_has_szpuname();
}
inline const ::std::string& PUChannelInfo::szpuname() const {
  return *szpuname_;
}
inline void PUChannelInfo::set_szpuname(const ::std::string& value) {
  set_has_szpuname();
  if (szpuname_ == &::google::protobuf::internal::kEmptyString) {
    szpuname_ = new ::std::string;
  }
  szpuname_->assign(value);
}
inline void PUChannelInfo::set_szpuname(const char* value) {
  set_has_szpuname();
  if (szpuname_ == &::google::protobuf::internal::kEmptyString) {
    szpuname_ = new ::std::string;
  }
  szpuname_->assign(value);
}
inline void PUChannelInfo::set_szpuname(const char* value, size_t size) {
  set_has_szpuname();
  if (szpuname_ == &::google::protobuf::internal::kEmptyString) {
    szpuname_ = new ::std::string;
  }
  szpuname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PUChannelInfo::mutable_szpuname() {
  set_has_szpuname();
  if (szpuname_ == &::google::protobuf::internal::kEmptyString) {
    szpuname_ = new ::std::string;
  }
  return szpuname_;
}
inline ::std::string* PUChannelInfo::release_szpuname() {
  clear_has_szpuname();
  if (szpuname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = szpuname_;
    szpuname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated .BVCU.PUConfig.PUOneChannelInfo pChannel = 4;
inline int PUChannelInfo::pchannel_size() const {
  return pchannel_.size();
}
inline void PUChannelInfo::clear_pchannel() {
  pchannel_.Clear();
}
inline const ::BVCU::PUConfig::PUOneChannelInfo& PUChannelInfo::pchannel(int index) const {
  return pchannel_.Get(index);
}
inline ::BVCU::PUConfig::PUOneChannelInfo* PUChannelInfo::mutable_pchannel(int index) {
  return pchannel_.Mutable(index);
}
inline ::BVCU::PUConfig::PUOneChannelInfo* PUChannelInfo::add_pchannel() {
  return pchannel_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::BVCU::PUConfig::PUOneChannelInfo >&
PUChannelInfo::pchannel() const {
  return pchannel_;
}
inline ::google::protobuf::RepeatedPtrField< ::BVCU::PUConfig::PUOneChannelInfo >*
PUChannelInfo::mutable_pchannel() {
  return &pchannel_;
}

// required uint32 iOnlineStatus = 5;
inline bool PUChannelInfo::has_ionlinestatus() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PUChannelInfo::set_has_ionlinestatus() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PUChannelInfo::clear_has_ionlinestatus() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PUChannelInfo::clear_ionlinestatus() {
  ionlinestatus_ = 0u;
  clear_has_ionlinestatus();
}
inline ::google::protobuf::uint32 PUChannelInfo::ionlinestatus() const {
  return ionlinestatus_;
}
inline void PUChannelInfo::set_ionlinestatus(::google::protobuf::uint32 value) {
  set_has_ionlinestatus();
  ionlinestatus_ = value;
}

// optional uint32 iGPSCount = 6;
inline bool PUChannelInfo::has_igpscount() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PUChannelInfo::set_has_igpscount() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PUChannelInfo::clear_has_igpscount() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PUChannelInfo::clear_igpscount() {
  igpscount_ = 0u;
  clear_has_igpscount();
}
inline ::google::protobuf::uint32 PUChannelInfo::igpscount() const {
  return igpscount_;
}
inline void PUChannelInfo::set_igpscount(::google::protobuf::uint32 value) {
  set_has_igpscount();
  igpscount_ = value;
}

// optional uint32 iLongitude = 7 [default = 2000000000];
inline bool PUChannelInfo::has_ilongitude() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PUChannelInfo::set_has_ilongitude() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PUChannelInfo::clear_has_ilongitude() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PUChannelInfo::clear_ilongitude() {
  ilongitude_ = 2000000000u;
  clear_has_ilongitude();
}
inline ::google::protobuf::uint32 PUChannelInfo::ilongitude() const {
  return ilongitude_;
}
inline void PUChannelInfo::set_ilongitude(::google::protobuf::uint32 value) {
  set_has_ilongitude();
  ilongitude_ = value;
}

// optional uint32 iLatitude = 8 [default = 2000000000];
inline bool PUChannelInfo::has_ilatitude() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void PUChannelInfo::set_has_ilatitude() {
  _has_bits_[0] |= 0x00000040u;
}
inline void PUChannelInfo::clear_has_ilatitude() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void PUChannelInfo::clear_ilatitude() {
  ilatitude_ = 2000000000u;
  clear_has_ilatitude();
}
inline ::google::protobuf::uint32 PUChannelInfo::ilatitude() const {
  return ilatitude_;
}
inline void PUChannelInfo::set_ilatitude(::google::protobuf::uint32 value) {
  set_has_ilatitude();
  ilatitude_ = value;
}

// -------------------------------------------------------------------

// DeviceInfo

// required string szID = 1;
inline bool DeviceInfo::has_szid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DeviceInfo::set_has_szid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DeviceInfo::clear_has_szid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DeviceInfo::clear_szid() {
  if (szid_ != &::google::protobuf::internal::kEmptyString) {
    szid_->clear();
  }
  clear_has_szid();
}
inline const ::std::string& DeviceInfo::szid() const {
  return *szid_;
}
inline void DeviceInfo::set_szid(const ::std::string& value) {
  set_has_szid();
  if (szid_ == &::google::protobuf::internal::kEmptyString) {
    szid_ = new ::std::string;
  }
  szid_->assign(value);
}
inline void DeviceInfo::set_szid(const char* value) {
  set_has_szid();
  if (szid_ == &::google::protobuf::internal::kEmptyString) {
    szid_ = new ::std::string;
  }
  szid_->assign(value);
}
inline void DeviceInfo::set_szid(const char* value, size_t size) {
  set_has_szid();
  if (szid_ == &::google::protobuf::internal::kEmptyString) {
    szid_ = new ::std::string;
  }
  szid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DeviceInfo::mutable_szid() {
  set_has_szid();
  if (szid_ == &::google::protobuf::internal::kEmptyString) {
    szid_ = new ::std::string;
  }
  return szid_;
}
inline ::std::string* DeviceInfo::release_szid() {
  clear_has_szid();
  if (szid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = szid_;
    szid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string szManufacturer = 25;
inline bool DeviceInfo::has_szmanufacturer() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DeviceInfo::set_has_szmanufacturer() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DeviceInfo::clear_has_szmanufacturer() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DeviceInfo::clear_szmanufacturer() {
  if (szmanufacturer_ != &::google::protobuf::internal::kEmptyString) {
    szmanufacturer_->clear();
  }
  clear_has_szmanufacturer();
}
inline const ::std::string& DeviceInfo::szmanufacturer() const {
  return *szmanufacturer_;
}
inline void DeviceInfo::set_szmanufacturer(const ::std::string& value) {
  set_has_szmanufacturer();
  if (szmanufacturer_ == &::google::protobuf::internal::kEmptyString) {
    szmanufacturer_ = new ::std::string;
  }
  szmanufacturer_->assign(value);
}
inline void DeviceInfo::set_szmanufacturer(const char* value) {
  set_has_szmanufacturer();
  if (szmanufacturer_ == &::google::protobuf::internal::kEmptyString) {
    szmanufacturer_ = new ::std::string;
  }
  szmanufacturer_->assign(value);
}
inline void DeviceInfo::set_szmanufacturer(const char* value, size_t size) {
  set_has_szmanufacturer();
  if (szmanufacturer_ == &::google::protobuf::internal::kEmptyString) {
    szmanufacturer_ = new ::std::string;
  }
  szmanufacturer_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DeviceInfo::mutable_szmanufacturer() {
  set_has_szmanufacturer();
  if (szmanufacturer_ == &::google::protobuf::internal::kEmptyString) {
    szmanufacturer_ = new ::std::string;
  }
  return szmanufacturer_;
}
inline ::std::string* DeviceInfo::release_szmanufacturer() {
  clear_has_szmanufacturer();
  if (szmanufacturer_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = szmanufacturer_;
    szmanufacturer_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string szProductName = 2 [default = "NULL"];
inline bool DeviceInfo::has_szproductname() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DeviceInfo::set_has_szproductname() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DeviceInfo::clear_has_szproductname() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DeviceInfo::clear_szproductname() {
  if (szproductname_ != &_default_szproductname_) {
    szproductname_->assign(_default_szproductname_);
  }
  clear_has_szproductname();
}
inline const ::std::string& DeviceInfo::szproductname() const {
  return *szproductname_;
}
inline void DeviceInfo::set_szproductname(const ::std::string& value) {
  set_has_szproductname();
  if (szproductname_ == &_default_szproductname_) {
    szproductname_ = new ::std::string;
  }
  szproductname_->assign(value);
}
inline void DeviceInfo::set_szproductname(const char* value) {
  set_has_szproductname();
  if (szproductname_ == &_default_szproductname_) {
    szproductname_ = new ::std::string;
  }
  szproductname_->assign(value);
}
inline void DeviceInfo::set_szproductname(const char* value, size_t size) {
  set_has_szproductname();
  if (szproductname_ == &_default_szproductname_) {
    szproductname_ = new ::std::string;
  }
  szproductname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DeviceInfo::mutable_szproductname() {
  set_has_szproductname();
  if (szproductname_ == &_default_szproductname_) {
    szproductname_ = new ::std::string(_default_szproductname_);
  }
  return szproductname_;
}
inline ::std::string* DeviceInfo::release_szproductname() {
  clear_has_szproductname();
  if (szproductname_ == &_default_szproductname_) {
    return NULL;
  } else {
    ::std::string* temp = szproductname_;
    szproductname_ = const_cast< ::std::string*>(&_default_szproductname_);
    return temp;
  }
}

// optional string szSoftwareVersion = 3 [default = "NULL"];
inline bool DeviceInfo::has_szsoftwareversion() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DeviceInfo::set_has_szsoftwareversion() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DeviceInfo::clear_has_szsoftwareversion() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DeviceInfo::clear_szsoftwareversion() {
  if (szsoftwareversion_ != &_default_szsoftwareversion_) {
    szsoftwareversion_->assign(_default_szsoftwareversion_);
  }
  clear_has_szsoftwareversion();
}
inline const ::std::string& DeviceInfo::szsoftwareversion() const {
  return *szsoftwareversion_;
}
inline void DeviceInfo::set_szsoftwareversion(const ::std::string& value) {
  set_has_szsoftwareversion();
  if (szsoftwareversion_ == &_default_szsoftwareversion_) {
    szsoftwareversion_ = new ::std::string;
  }
  szsoftwareversion_->assign(value);
}
inline void DeviceInfo::set_szsoftwareversion(const char* value) {
  set_has_szsoftwareversion();
  if (szsoftwareversion_ == &_default_szsoftwareversion_) {
    szsoftwareversion_ = new ::std::string;
  }
  szsoftwareversion_->assign(value);
}
inline void DeviceInfo::set_szsoftwareversion(const char* value, size_t size) {
  set_has_szsoftwareversion();
  if (szsoftwareversion_ == &_default_szsoftwareversion_) {
    szsoftwareversion_ = new ::std::string;
  }
  szsoftwareversion_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DeviceInfo::mutable_szsoftwareversion() {
  set_has_szsoftwareversion();
  if (szsoftwareversion_ == &_default_szsoftwareversion_) {
    szsoftwareversion_ = new ::std::string(_default_szsoftwareversion_);
  }
  return szsoftwareversion_;
}
inline ::std::string* DeviceInfo::release_szsoftwareversion() {
  clear_has_szsoftwareversion();
  if (szsoftwareversion_ == &_default_szsoftwareversion_) {
    return NULL;
  } else {
    ::std::string* temp = szsoftwareversion_;
    szsoftwareversion_ = const_cast< ::std::string*>(&_default_szsoftwareversion_);
    return temp;
  }
}

// optional string szHardwareVersion = 4 [default = "NULL"];
inline bool DeviceInfo::has_szhardwareversion() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DeviceInfo::set_has_szhardwareversion() {
  _has_bits_[0] |= 0x00000010u;
}
inline void DeviceInfo::clear_has_szhardwareversion() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void DeviceInfo::clear_szhardwareversion() {
  if (szhardwareversion_ != &_default_szhardwareversion_) {
    szhardwareversion_->assign(_default_szhardwareversion_);
  }
  clear_has_szhardwareversion();
}
inline const ::std::string& DeviceInfo::szhardwareversion() const {
  return *szhardwareversion_;
}
inline void DeviceInfo::set_szhardwareversion(const ::std::string& value) {
  set_has_szhardwareversion();
  if (szhardwareversion_ == &_default_szhardwareversion_) {
    szhardwareversion_ = new ::std::string;
  }
  szhardwareversion_->assign(value);
}
inline void DeviceInfo::set_szhardwareversion(const char* value) {
  set_has_szhardwareversion();
  if (szhardwareversion_ == &_default_szhardwareversion_) {
    szhardwareversion_ = new ::std::string;
  }
  szhardwareversion_->assign(value);
}
inline void DeviceInfo::set_szhardwareversion(const char* value, size_t size) {
  set_has_szhardwareversion();
  if (szhardwareversion_ == &_default_szhardwareversion_) {
    szhardwareversion_ = new ::std::string;
  }
  szhardwareversion_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DeviceInfo::mutable_szhardwareversion() {
  set_has_szhardwareversion();
  if (szhardwareversion_ == &_default_szhardwareversion_) {
    szhardwareversion_ = new ::std::string(_default_szhardwareversion_);
  }
  return szhardwareversion_;
}
inline ::std::string* DeviceInfo::release_szhardwareversion() {
  clear_has_szhardwareversion();
  if (szhardwareversion_ == &_default_szhardwareversion_) {
    return NULL;
  } else {
    ::std::string* temp = szhardwareversion_;
    szhardwareversion_ = const_cast< ::std::string*>(&_default_szhardwareversion_);
    return temp;
  }
}

// required uint32 iPUType = 5;
inline bool DeviceInfo::has_iputype() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void DeviceInfo::set_has_iputype() {
  _has_bits_[0] |= 0x00000020u;
}
inline void DeviceInfo::clear_has_iputype() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void DeviceInfo::clear_iputype() {
  iputype_ = 0u;
  clear_has_iputype();
}
inline ::google::protobuf::uint32 DeviceInfo::iputype() const {
  return iputype_;
}
inline void DeviceInfo::set_iputype(::google::protobuf::uint32 value) {
  set_has_iputype();
  iputype_ = value;
}

// repeated uint32 iLanguage = 6;
inline int DeviceInfo::ilanguage_size() const {
  return ilanguage_.size();
}
inline void DeviceInfo::clear_ilanguage() {
  ilanguage_.Clear();
}
inline ::google::protobuf::uint32 DeviceInfo::ilanguage(int index) const {
  return ilanguage_.Get(index);
}
inline void DeviceInfo::set_ilanguage(int index, ::google::protobuf::uint32 value) {
  ilanguage_.Set(index, value);
}
inline void DeviceInfo::add_ilanguage(::google::protobuf::uint32 value) {
  ilanguage_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
DeviceInfo::ilanguage() const {
  return ilanguage_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
DeviceInfo::mutable_ilanguage() {
  return &ilanguage_;
}

// optional uint32 iLanguageIndex = 7;
inline bool DeviceInfo::has_ilanguageindex() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void DeviceInfo::set_has_ilanguageindex() {
  _has_bits_[0] |= 0x00000080u;
}
inline void DeviceInfo::clear_has_ilanguageindex() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void DeviceInfo::clear_ilanguageindex() {
  ilanguageindex_ = 0u;
  clear_has_ilanguageindex();
}
inline ::google::protobuf::uint32 DeviceInfo::ilanguageindex() const {
  return ilanguageindex_;
}
inline void DeviceInfo::set_ilanguageindex(::google::protobuf::uint32 value) {
  set_has_ilanguageindex();
  ilanguageindex_ = value;
}

// optional string szName = 8;
inline bool DeviceInfo::has_szname() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void DeviceInfo::set_has_szname() {
  _has_bits_[0] |= 0x00000100u;
}
inline void DeviceInfo::clear_has_szname() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void DeviceInfo::clear_szname() {
  if (szname_ != &::google::protobuf::internal::kEmptyString) {
    szname_->clear();
  }
  clear_has_szname();
}
inline const ::std::string& DeviceInfo::szname() const {
  return *szname_;
}
inline void DeviceInfo::set_szname(const ::std::string& value) {
  set_has_szname();
  if (szname_ == &::google::protobuf::internal::kEmptyString) {
    szname_ = new ::std::string;
  }
  szname_->assign(value);
}
inline void DeviceInfo::set_szname(const char* value) {
  set_has_szname();
  if (szname_ == &::google::protobuf::internal::kEmptyString) {
    szname_ = new ::std::string;
  }
  szname_->assign(value);
}
inline void DeviceInfo::set_szname(const char* value, size_t size) {
  set_has_szname();
  if (szname_ == &::google::protobuf::internal::kEmptyString) {
    szname_ = new ::std::string;
  }
  szname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DeviceInfo::mutable_szname() {
  set_has_szname();
  if (szname_ == &::google::protobuf::internal::kEmptyString) {
    szname_ = new ::std::string;
  }
  return szname_;
}
inline ::std::string* DeviceInfo::release_szname() {
  clear_has_szname();
  if (szname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = szname_;
    szname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional uint32 iWIFICount = 9;
inline bool DeviceInfo::has_iwificount() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void DeviceInfo::set_has_iwificount() {
  _has_bits_[0] |= 0x00000200u;
}
inline void DeviceInfo::clear_has_iwificount() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void DeviceInfo::clear_iwificount() {
  iwificount_ = 0u;
  clear_has_iwificount();
}
inline ::google::protobuf::uint32 DeviceInfo::iwificount() const {
  return iwificount_;
}
inline void DeviceInfo::set_iwificount(::google::protobuf::uint32 value) {
  set_has_iwificount();
  iwificount_ = value;
}

// optional uint32 iRadioCount = 10;
inline bool DeviceInfo::has_iradiocount() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void DeviceInfo::set_has_iradiocount() {
  _has_bits_[0] |= 0x00000400u;
}
inline void DeviceInfo::clear_has_iradiocount() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void DeviceInfo::clear_iradiocount() {
  iradiocount_ = 0u;
  clear_has_iradiocount();
}
inline ::google::protobuf::uint32 DeviceInfo::iradiocount() const {
  return iradiocount_;
}
inline void DeviceInfo::set_iradiocount(::google::protobuf::uint32 value) {
  set_has_iradiocount();
  iradiocount_ = value;
}

// optional uint32 iChannelCount = 11;
inline bool DeviceInfo::has_ichannelcount() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void DeviceInfo::set_has_ichannelcount() {
  _has_bits_[0] |= 0x00000800u;
}
inline void DeviceInfo::clear_has_ichannelcount() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void DeviceInfo::clear_ichannelcount() {
  ichannelcount_ = 0u;
  clear_has_ichannelcount();
}
inline ::google::protobuf::uint32 DeviceInfo::ichannelcount() const {
  return ichannelcount_;
}
inline void DeviceInfo::set_ichannelcount(::google::protobuf::uint32 value) {
  set_has_ichannelcount();
  ichannelcount_ = value;
}

// optional uint32 iVideoInCount = 12;
inline bool DeviceInfo::has_ivideoincount() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void DeviceInfo::set_has_ivideoincount() {
  _has_bits_[0] |= 0x00001000u;
}
inline void DeviceInfo::clear_has_ivideoincount() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void DeviceInfo::clear_ivideoincount() {
  ivideoincount_ = 0u;
  clear_has_ivideoincount();
}
inline ::google::protobuf::uint32 DeviceInfo::ivideoincount() const {
  return ivideoincount_;
}
inline void DeviceInfo::set_ivideoincount(::google::protobuf::uint32 value) {
  set_has_ivideoincount();
  ivideoincount_ = value;
}

// optional uint32 iAudioInCount = 13;
inline bool DeviceInfo::has_iaudioincount() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void DeviceInfo::set_has_iaudioincount() {
  _has_bits_[0] |= 0x00002000u;
}
inline void DeviceInfo::clear_has_iaudioincount() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void DeviceInfo::clear_iaudioincount() {
  iaudioincount_ = 0u;
  clear_has_iaudioincount();
}
inline ::google::protobuf::uint32 DeviceInfo::iaudioincount() const {
  return iaudioincount_;
}
inline void DeviceInfo::set_iaudioincount(::google::protobuf::uint32 value) {
  set_has_iaudioincount();
  iaudioincount_ = value;
}

// optional uint32 iAudioOutCount = 14;
inline bool DeviceInfo::has_iaudiooutcount() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void DeviceInfo::set_has_iaudiooutcount() {
  _has_bits_[0] |= 0x00004000u;
}
inline void DeviceInfo::clear_has_iaudiooutcount() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void DeviceInfo::clear_iaudiooutcount() {
  iaudiooutcount_ = 0u;
  clear_has_iaudiooutcount();
}
inline ::google::protobuf::uint32 DeviceInfo::iaudiooutcount() const {
  return iaudiooutcount_;
}
inline void DeviceInfo::set_iaudiooutcount(::google::protobuf::uint32 value) {
  set_has_iaudiooutcount();
  iaudiooutcount_ = value;
}

// optional uint32 iPTZCount = 15;
inline bool DeviceInfo::has_iptzcount() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void DeviceInfo::set_has_iptzcount() {
  _has_bits_[0] |= 0x00008000u;
}
inline void DeviceInfo::clear_has_iptzcount() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void DeviceInfo::clear_iptzcount() {
  iptzcount_ = 0u;
  clear_has_iptzcount();
}
inline ::google::protobuf::uint32 DeviceInfo::iptzcount() const {
  return iptzcount_;
}
inline void DeviceInfo::set_iptzcount(::google::protobuf::uint32 value) {
  set_has_iptzcount();
  iptzcount_ = value;
}

// optional uint32 iSerialPortCount = 16;
inline bool DeviceInfo::has_iserialportcount() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void DeviceInfo::set_has_iserialportcount() {
  _has_bits_[0] |= 0x00010000u;
}
inline void DeviceInfo::clear_has_iserialportcount() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void DeviceInfo::clear_iserialportcount() {
  iserialportcount_ = 0u;
  clear_has_iserialportcount();
}
inline ::google::protobuf::uint32 DeviceInfo::iserialportcount() const {
  return iserialportcount_;
}
inline void DeviceInfo::set_iserialportcount(::google::protobuf::uint32 value) {
  set_has_iserialportcount();
  iserialportcount_ = value;
}

// optional uint32 iAlertInCount = 17;
inline bool DeviceInfo::has_ialertincount() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void DeviceInfo::set_has_ialertincount() {
  _has_bits_[0] |= 0x00020000u;
}
inline void DeviceInfo::clear_has_ialertincount() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void DeviceInfo::clear_ialertincount() {
  ialertincount_ = 0u;
  clear_has_ialertincount();
}
inline ::google::protobuf::uint32 DeviceInfo::ialertincount() const {
  return ialertincount_;
}
inline void DeviceInfo::set_ialertincount(::google::protobuf::uint32 value) {
  set_has_ialertincount();
  ialertincount_ = value;
}

// optional uint32 iAlertOutCount = 18;
inline bool DeviceInfo::has_ialertoutcount() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void DeviceInfo::set_has_ialertoutcount() {
  _has_bits_[0] |= 0x00040000u;
}
inline void DeviceInfo::clear_has_ialertoutcount() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void DeviceInfo::clear_ialertoutcount() {
  ialertoutcount_ = 0u;
  clear_has_ialertoutcount();
}
inline ::google::protobuf::uint32 DeviceInfo::ialertoutcount() const {
  return ialertoutcount_;
}
inline void DeviceInfo::set_ialertoutcount(::google::protobuf::uint32 value) {
  set_has_ialertoutcount();
  ialertoutcount_ = value;
}

// optional uint32 iStorageCount = 19;
inline bool DeviceInfo::has_istoragecount() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void DeviceInfo::set_has_istoragecount() {
  _has_bits_[0] |= 0x00080000u;
}
inline void DeviceInfo::clear_has_istoragecount() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void DeviceInfo::clear_istoragecount() {
  istoragecount_ = 0u;
  clear_has_istoragecount();
}
inline ::google::protobuf::uint32 DeviceInfo::istoragecount() const {
  return istoragecount_;
}
inline void DeviceInfo::set_istoragecount(::google::protobuf::uint32 value) {
  set_has_istoragecount();
  istoragecount_ = value;
}

// optional uint32 iGPSCount = 20;
inline bool DeviceInfo::has_igpscount() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void DeviceInfo::set_has_igpscount() {
  _has_bits_[0] |= 0x00100000u;
}
inline void DeviceInfo::clear_has_igpscount() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void DeviceInfo::clear_igpscount() {
  igpscount_ = 0u;
  clear_has_igpscount();
}
inline ::google::protobuf::uint32 DeviceInfo::igpscount() const {
  return igpscount_;
}
inline void DeviceInfo::set_igpscount(::google::protobuf::uint32 value) {
  set_has_igpscount();
  igpscount_ = value;
}

// optional uint32 bSupportSMS = 21;
inline bool DeviceInfo::has_bsupportsms() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void DeviceInfo::set_has_bsupportsms() {
  _has_bits_[0] |= 0x00200000u;
}
inline void DeviceInfo::clear_has_bsupportsms() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void DeviceInfo::clear_bsupportsms() {
  bsupportsms_ = 0u;
  clear_has_bsupportsms();
}
inline ::google::protobuf::uint32 DeviceInfo::bsupportsms() const {
  return bsupportsms_;
}
inline void DeviceInfo::set_bsupportsms(::google::protobuf::uint32 value) {
  set_has_bsupportsms();
  bsupportsms_ = value;
}

// optional uint32 iPresetCount = 22;
inline bool DeviceInfo::has_ipresetcount() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void DeviceInfo::set_has_ipresetcount() {
  _has_bits_[0] |= 0x00400000u;
}
inline void DeviceInfo::clear_has_ipresetcount() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void DeviceInfo::clear_ipresetcount() {
  ipresetcount_ = 0u;
  clear_has_ipresetcount();
}
inline ::google::protobuf::uint32 DeviceInfo::ipresetcount() const {
  return ipresetcount_;
}
inline void DeviceInfo::set_ipresetcount(::google::protobuf::uint32 value) {
  set_has_ipresetcount();
  ipresetcount_ = value;
}

// optional uint32 iCruiseCount = 23;
inline bool DeviceInfo::has_icruisecount() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void DeviceInfo::set_has_icruisecount() {
  _has_bits_[0] |= 0x00800000u;
}
inline void DeviceInfo::clear_has_icruisecount() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void DeviceInfo::clear_icruisecount() {
  icruisecount_ = 0u;
  clear_has_icruisecount();
}
inline ::google::protobuf::uint32 DeviceInfo::icruisecount() const {
  return icruisecount_;
}
inline void DeviceInfo::set_icruisecount(::google::protobuf::uint32 value) {
  set_has_icruisecount();
  icruisecount_ = value;
}

// optional uint32 iAlarmLinkActionCount = 24;
inline bool DeviceInfo::has_ialarmlinkactioncount() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void DeviceInfo::set_has_ialarmlinkactioncount() {
  _has_bits_[0] |= 0x01000000u;
}
inline void DeviceInfo::clear_has_ialarmlinkactioncount() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void DeviceInfo::clear_ialarmlinkactioncount() {
  ialarmlinkactioncount_ = 0u;
  clear_has_ialarmlinkactioncount();
}
inline ::google::protobuf::uint32 DeviceInfo::ialarmlinkactioncount() const {
  return ialarmlinkactioncount_;
}
inline void DeviceInfo::set_ialarmlinkactioncount(::google::protobuf::uint32 value) {
  set_has_ialarmlinkactioncount();
  ialarmlinkactioncount_ = value;
}

// optional int32 iLongitude = 26;
inline bool DeviceInfo::has_ilongitude() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void DeviceInfo::set_has_ilongitude() {
  _has_bits_[0] |= 0x02000000u;
}
inline void DeviceInfo::clear_has_ilongitude() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void DeviceInfo::clear_ilongitude() {
  ilongitude_ = 0;
  clear_has_ilongitude();
}
inline ::google::protobuf::int32 DeviceInfo::ilongitude() const {
  return ilongitude_;
}
inline void DeviceInfo::set_ilongitude(::google::protobuf::int32 value) {
  set_has_ilongitude();
  ilongitude_ = value;
}

// optional int32 iLatitude = 27;
inline bool DeviceInfo::has_ilatitude() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void DeviceInfo::set_has_ilatitude() {
  _has_bits_[0] |= 0x04000000u;
}
inline void DeviceInfo::clear_has_ilatitude() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void DeviceInfo::clear_ilatitude() {
  ilatitude_ = 0;
  clear_has_ilatitude();
}
inline ::google::protobuf::int32 DeviceInfo::ilatitude() const {
  return ilatitude_;
}
inline void DeviceInfo::set_ilatitude(::google::protobuf::int32 value) {
  set_has_ilatitude();
  ilatitude_ = value;
}

// -------------------------------------------------------------------

// UpdateStatus

// optional uint32 iDownloadPercent = 1;
inline bool UpdateStatus::has_idownloadpercent() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UpdateStatus::set_has_idownloadpercent() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UpdateStatus::clear_has_idownloadpercent() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UpdateStatus::clear_idownloadpercent() {
  idownloadpercent_ = 0u;
  clear_has_idownloadpercent();
}
inline ::google::protobuf::uint32 UpdateStatus::idownloadpercent() const {
  return idownloadpercent_;
}
inline void UpdateStatus::set_idownloadpercent(::google::protobuf::uint32 value) {
  set_has_idownloadpercent();
  idownloadpercent_ = value;
}

// optional uint32 iSpeed = 2;
inline bool UpdateStatus::has_ispeed() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UpdateStatus::set_has_ispeed() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UpdateStatus::clear_has_ispeed() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UpdateStatus::clear_ispeed() {
  ispeed_ = 0u;
  clear_has_ispeed();
}
inline ::google::protobuf::uint32 UpdateStatus::ispeed() const {
  return ispeed_;
}
inline void UpdateStatus::set_ispeed(::google::protobuf::uint32 value) {
  set_has_ispeed();
  ispeed_ = value;
}

// optional string szSoftwareVersion = 3;
inline bool UpdateStatus::has_szsoftwareversion() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UpdateStatus::set_has_szsoftwareversion() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UpdateStatus::clear_has_szsoftwareversion() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UpdateStatus::clear_szsoftwareversion() {
  if (szsoftwareversion_ != &::google::protobuf::internal::kEmptyString) {
    szsoftwareversion_->clear();
  }
  clear_has_szsoftwareversion();
}
inline const ::std::string& UpdateStatus::szsoftwareversion() const {
  return *szsoftwareversion_;
}
inline void UpdateStatus::set_szsoftwareversion(const ::std::string& value) {
  set_has_szsoftwareversion();
  if (szsoftwareversion_ == &::google::protobuf::internal::kEmptyString) {
    szsoftwareversion_ = new ::std::string;
  }
  szsoftwareversion_->assign(value);
}
inline void UpdateStatus::set_szsoftwareversion(const char* value) {
  set_has_szsoftwareversion();
  if (szsoftwareversion_ == &::google::protobuf::internal::kEmptyString) {
    szsoftwareversion_ = new ::std::string;
  }
  szsoftwareversion_->assign(value);
}
inline void UpdateStatus::set_szsoftwareversion(const char* value, size_t size) {
  set_has_szsoftwareversion();
  if (szsoftwareversion_ == &::google::protobuf::internal::kEmptyString) {
    szsoftwareversion_ = new ::std::string;
  }
  szsoftwareversion_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UpdateStatus::mutable_szsoftwareversion() {
  set_has_szsoftwareversion();
  if (szsoftwareversion_ == &::google::protobuf::internal::kEmptyString) {
    szsoftwareversion_ = new ::std::string;
  }
  return szsoftwareversion_;
}
inline ::std::string* UpdateStatus::release_szsoftwareversion() {
  clear_has_szsoftwareversion();
  if (szsoftwareversion_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = szsoftwareversion_;
    szsoftwareversion_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional .BVCU.PUConfig.WallTime stUpdateFinishTime = 4;
inline bool UpdateStatus::has_stupdatefinishtime() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UpdateStatus::set_has_stupdatefinishtime() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UpdateStatus::clear_has_stupdatefinishtime() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UpdateStatus::clear_stupdatefinishtime() {
  if (stupdatefinishtime_ != NULL) stupdatefinishtime_->::BVCU::PUConfig::WallTime::Clear();
  clear_has_stupdatefinishtime();
}
inline const ::BVCU::PUConfig::WallTime& UpdateStatus::stupdatefinishtime() const {
  return stupdatefinishtime_ != NULL ? *stupdatefinishtime_ : *default_instance_->stupdatefinishtime_;
}
inline ::BVCU::PUConfig::WallTime* UpdateStatus::mutable_stupdatefinishtime() {
  set_has_stupdatefinishtime();
  if (stupdatefinishtime_ == NULL) stupdatefinishtime_ = new ::BVCU::PUConfig::WallTime;
  return stupdatefinishtime_;
}
inline ::BVCU::PUConfig::WallTime* UpdateStatus::release_stupdatefinishtime() {
  clear_has_stupdatefinishtime();
  ::BVCU::PUConfig::WallTime* temp = stupdatefinishtime_;
  stupdatefinishtime_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// Upgrade

// optional string szFTPID = 1;
inline bool Upgrade::has_szftpid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Upgrade::set_has_szftpid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Upgrade::clear_has_szftpid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Upgrade::clear_szftpid() {
  if (szftpid_ != &::google::protobuf::internal::kEmptyString) {
    szftpid_->clear();
  }
  clear_has_szftpid();
}
inline const ::std::string& Upgrade::szftpid() const {
  return *szftpid_;
}
inline void Upgrade::set_szftpid(const ::std::string& value) {
  set_has_szftpid();
  if (szftpid_ == &::google::protobuf::internal::kEmptyString) {
    szftpid_ = new ::std::string;
  }
  szftpid_->assign(value);
}
inline void Upgrade::set_szftpid(const char* value) {
  set_has_szftpid();
  if (szftpid_ == &::google::protobuf::internal::kEmptyString) {
    szftpid_ = new ::std::string;
  }
  szftpid_->assign(value);
}
inline void Upgrade::set_szftpid(const char* value, size_t size) {
  set_has_szftpid();
  if (szftpid_ == &::google::protobuf::internal::kEmptyString) {
    szftpid_ = new ::std::string;
  }
  szftpid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Upgrade::mutable_szftpid() {
  set_has_szftpid();
  if (szftpid_ == &::google::protobuf::internal::kEmptyString) {
    szftpid_ = new ::std::string;
  }
  return szftpid_;
}
inline ::std::string* Upgrade::release_szftpid() {
  clear_has_szftpid();
  if (szftpid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = szftpid_;
    szftpid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string szFilePath = 2;
inline bool Upgrade::has_szfilepath() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Upgrade::set_has_szfilepath() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Upgrade::clear_has_szfilepath() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Upgrade::clear_szfilepath() {
  if (szfilepath_ != &::google::protobuf::internal::kEmptyString) {
    szfilepath_->clear();
  }
  clear_has_szfilepath();
}
inline const ::std::string& Upgrade::szfilepath() const {
  return *szfilepath_;
}
inline void Upgrade::set_szfilepath(const ::std::string& value) {
  set_has_szfilepath();
  if (szfilepath_ == &::google::protobuf::internal::kEmptyString) {
    szfilepath_ = new ::std::string;
  }
  szfilepath_->assign(value);
}
inline void Upgrade::set_szfilepath(const char* value) {
  set_has_szfilepath();
  if (szfilepath_ == &::google::protobuf::internal::kEmptyString) {
    szfilepath_ = new ::std::string;
  }
  szfilepath_->assign(value);
}
inline void Upgrade::set_szfilepath(const char* value, size_t size) {
  set_has_szfilepath();
  if (szfilepath_ == &::google::protobuf::internal::kEmptyString) {
    szfilepath_ = new ::std::string;
  }
  szfilepath_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Upgrade::mutable_szfilepath() {
  set_has_szfilepath();
  if (szfilepath_ == &::google::protobuf::internal::kEmptyString) {
    szfilepath_ = new ::std::string;
  }
  return szfilepath_;
}
inline ::std::string* Upgrade::release_szfilepath() {
  clear_has_szfilepath();
  if (szfilepath_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = szfilepath_;
    szfilepath_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string szFileName = 3;
inline bool Upgrade::has_szfilename() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Upgrade::set_has_szfilename() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Upgrade::clear_has_szfilename() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Upgrade::clear_szfilename() {
  if (szfilename_ != &::google::protobuf::internal::kEmptyString) {
    szfilename_->clear();
  }
  clear_has_szfilename();
}
inline const ::std::string& Upgrade::szfilename() const {
  return *szfilename_;
}
inline void Upgrade::set_szfilename(const ::std::string& value) {
  set_has_szfilename();
  if (szfilename_ == &::google::protobuf::internal::kEmptyString) {
    szfilename_ = new ::std::string;
  }
  szfilename_->assign(value);
}
inline void Upgrade::set_szfilename(const char* value) {
  set_has_szfilename();
  if (szfilename_ == &::google::protobuf::internal::kEmptyString) {
    szfilename_ = new ::std::string;
  }
  szfilename_->assign(value);
}
inline void Upgrade::set_szfilename(const char* value, size_t size) {
  set_has_szfilename();
  if (szfilename_ == &::google::protobuf::internal::kEmptyString) {
    szfilename_ = new ::std::string;
  }
  szfilename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Upgrade::mutable_szfilename() {
  set_has_szfilename();
  if (szfilename_ == &::google::protobuf::internal::kEmptyString) {
    szfilename_ = new ::std::string;
  }
  return szfilename_;
}
inline ::std::string* Upgrade::release_szfilename() {
  clear_has_szfilename();
  if (szfilename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = szfilename_;
    szfilename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional uint32 bPromptly = 4;
inline bool Upgrade::has_bpromptly() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Upgrade::set_has_bpromptly() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Upgrade::clear_has_bpromptly() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Upgrade::clear_bpromptly() {
  bpromptly_ = 0u;
  clear_has_bpromptly();
}
inline ::google::protobuf::uint32 Upgrade::bpromptly() const {
  return bpromptly_;
}
inline void Upgrade::set_bpromptly(::google::protobuf::uint32 value) {
  set_has_bpromptly();
  bpromptly_ = value;
}

// -------------------------------------------------------------------

// GroupInfo

// optional string szID = 1;
inline bool GroupInfo::has_szid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GroupInfo::set_has_szid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GroupInfo::clear_has_szid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GroupInfo::clear_szid() {
  if (szid_ != &::google::protobuf::internal::kEmptyString) {
    szid_->clear();
  }
  clear_has_szid();
}
inline const ::std::string& GroupInfo::szid() const {
  return *szid_;
}
inline void GroupInfo::set_szid(const ::std::string& value) {
  set_has_szid();
  if (szid_ == &::google::protobuf::internal::kEmptyString) {
    szid_ = new ::std::string;
  }
  szid_->assign(value);
}
inline void GroupInfo::set_szid(const char* value) {
  set_has_szid();
  if (szid_ == &::google::protobuf::internal::kEmptyString) {
    szid_ = new ::std::string;
  }
  szid_->assign(value);
}
inline void GroupInfo::set_szid(const char* value, size_t size) {
  set_has_szid();
  if (szid_ == &::google::protobuf::internal::kEmptyString) {
    szid_ = new ::std::string;
  }
  szid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GroupInfo::mutable_szid() {
  set_has_szid();
  if (szid_ == &::google::protobuf::internal::kEmptyString) {
    szid_ = new ::std::string;
  }
  return szid_;
}
inline ::std::string* GroupInfo::release_szid() {
  clear_has_szid();
  if (szid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = szid_;
    szid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string szName = 2;
inline bool GroupInfo::has_szname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GroupInfo::set_has_szname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GroupInfo::clear_has_szname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GroupInfo::clear_szname() {
  if (szname_ != &::google::protobuf::internal::kEmptyString) {
    szname_->clear();
  }
  clear_has_szname();
}
inline const ::std::string& GroupInfo::szname() const {
  return *szname_;
}
inline void GroupInfo::set_szname(const ::std::string& value) {
  set_has_szname();
  if (szname_ == &::google::protobuf::internal::kEmptyString) {
    szname_ = new ::std::string;
  }
  szname_->assign(value);
}
inline void GroupInfo::set_szname(const char* value) {
  set_has_szname();
  if (szname_ == &::google::protobuf::internal::kEmptyString) {
    szname_ = new ::std::string;
  }
  szname_->assign(value);
}
inline void GroupInfo::set_szname(const char* value, size_t size) {
  set_has_szname();
  if (szname_ == &::google::protobuf::internal::kEmptyString) {
    szname_ = new ::std::string;
  }
  szname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GroupInfo::mutable_szname() {
  set_has_szname();
  if (szname_ == &::google::protobuf::internal::kEmptyString) {
    szname_ = new ::std::string;
  }
  return szname_;
}
inline ::std::string* GroupInfo::release_szname() {
  clear_has_szname();
  if (szname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = szname_;
    szname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string szParentID = 3;
inline bool GroupInfo::has_szparentid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GroupInfo::set_has_szparentid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GroupInfo::clear_has_szparentid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GroupInfo::clear_szparentid() {
  if (szparentid_ != &::google::protobuf::internal::kEmptyString) {
    szparentid_->clear();
  }
  clear_has_szparentid();
}
inline const ::std::string& GroupInfo::szparentid() const {
  return *szparentid_;
}
inline void GroupInfo::set_szparentid(const ::std::string& value) {
  set_has_szparentid();
  if (szparentid_ == &::google::protobuf::internal::kEmptyString) {
    szparentid_ = new ::std::string;
  }
  szparentid_->assign(value);
}
inline void GroupInfo::set_szparentid(const char* value) {
  set_has_szparentid();
  if (szparentid_ == &::google::protobuf::internal::kEmptyString) {
    szparentid_ = new ::std::string;
  }
  szparentid_->assign(value);
}
inline void GroupInfo::set_szparentid(const char* value, size_t size) {
  set_has_szparentid();
  if (szparentid_ == &::google::protobuf::internal::kEmptyString) {
    szparentid_ = new ::std::string;
  }
  szparentid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GroupInfo::mutable_szparentid() {
  set_has_szparentid();
  if (szparentid_ == &::google::protobuf::internal::kEmptyString) {
    szparentid_ = new ::std::string;
  }
  return szparentid_;
}
inline ::std::string* GroupInfo::release_szparentid() {
  clear_has_szparentid();
  if (szparentid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = szparentid_;
    szparentid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string szDescription = 4;
inline bool GroupInfo::has_szdescription() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GroupInfo::set_has_szdescription() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GroupInfo::clear_has_szdescription() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GroupInfo::clear_szdescription() {
  if (szdescription_ != &::google::protobuf::internal::kEmptyString) {
    szdescription_->clear();
  }
  clear_has_szdescription();
}
inline const ::std::string& GroupInfo::szdescription() const {
  return *szdescription_;
}
inline void GroupInfo::set_szdescription(const ::std::string& value) {
  set_has_szdescription();
  if (szdescription_ == &::google::protobuf::internal::kEmptyString) {
    szdescription_ = new ::std::string;
  }
  szdescription_->assign(value);
}
inline void GroupInfo::set_szdescription(const char* value) {
  set_has_szdescription();
  if (szdescription_ == &::google::protobuf::internal::kEmptyString) {
    szdescription_ = new ::std::string;
  }
  szdescription_->assign(value);
}
inline void GroupInfo::set_szdescription(const char* value, size_t size) {
  set_has_szdescription();
  if (szdescription_ == &::google::protobuf::internal::kEmptyString) {
    szdescription_ = new ::std::string;
  }
  szdescription_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GroupInfo::mutable_szdescription() {
  set_has_szdescription();
  if (szdescription_ == &::google::protobuf::internal::kEmptyString) {
    szdescription_ = new ::std::string;
  }
  return szdescription_;
}
inline ::std::string* GroupInfo::release_szdescription() {
  clear_has_szdescription();
  if (szdescription_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = szdescription_;
    szdescription_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated string pPUID = 5;
inline int GroupInfo::ppuid_size() const {
  return ppuid_.size();
}
inline void GroupInfo::clear_ppuid() {
  ppuid_.Clear();
}
inline const ::std::string& GroupInfo::ppuid(int index) const {
  return ppuid_.Get(index);
}
inline ::std::string* GroupInfo::mutable_ppuid(int index) {
  return ppuid_.Mutable(index);
}
inline void GroupInfo::set_ppuid(int index, const ::std::string& value) {
  ppuid_.Mutable(index)->assign(value);
}
inline void GroupInfo::set_ppuid(int index, const char* value) {
  ppuid_.Mutable(index)->assign(value);
}
inline void GroupInfo::set_ppuid(int index, const char* value, size_t size) {
  ppuid_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GroupInfo::add_ppuid() {
  return ppuid_.Add();
}
inline void GroupInfo::add_ppuid(const ::std::string& value) {
  ppuid_.Add()->assign(value);
}
inline void GroupInfo::add_ppuid(const char* value) {
  ppuid_.Add()->assign(value);
}
inline void GroupInfo::add_ppuid(const char* value, size_t size) {
  ppuid_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
GroupInfo::ppuid() const {
  return ppuid_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
GroupInfo::mutable_ppuid() {
  return &ppuid_;
}

// -------------------------------------------------------------------

// Power

// optional uint32 iTurnOffDelay = 1;
inline bool Power::has_iturnoffdelay() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Power::set_has_iturnoffdelay() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Power::clear_has_iturnoffdelay() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Power::clear_iturnoffdelay() {
  iturnoffdelay_ = 0u;
  clear_has_iturnoffdelay();
}
inline ::google::protobuf::uint32 Power::iturnoffdelay() const {
  return iturnoffdelay_;
}
inline void Power::set_iturnoffdelay(::google::protobuf::uint32 value) {
  set_has_iturnoffdelay();
  iturnoffdelay_ = value;
}

// optional uint32 bEnableTimer = 2;
inline bool Power::has_benabletimer() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Power::set_has_benabletimer() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Power::clear_has_benabletimer() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Power::clear_benabletimer() {
  benabletimer_ = 0u;
  clear_has_benabletimer();
}
inline ::google::protobuf::uint32 Power::benabletimer() const {
  return benabletimer_;
}
inline void Power::set_benabletimer(::google::protobuf::uint32 value) {
  set_has_benabletimer();
  benabletimer_ = value;
}

// optional .BVCU.PUConfig.WeekTimeSlice stTurnOn = 3;
inline bool Power::has_stturnon() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Power::set_has_stturnon() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Power::clear_has_stturnon() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Power::clear_stturnon() {
  if (stturnon_ != NULL) stturnon_->::BVCU::PUConfig::WeekTimeSlice::Clear();
  clear_has_stturnon();
}
inline const ::BVCU::PUConfig::WeekTimeSlice& Power::stturnon() const {
  return stturnon_ != NULL ? *stturnon_ : *default_instance_->stturnon_;
}
inline ::BVCU::PUConfig::WeekTimeSlice* Power::mutable_stturnon() {
  set_has_stturnon();
  if (stturnon_ == NULL) stturnon_ = new ::BVCU::PUConfig::WeekTimeSlice;
  return stturnon_;
}
inline ::BVCU::PUConfig::WeekTimeSlice* Power::release_stturnon() {
  clear_has_stturnon();
  ::BVCU::PUConfig::WeekTimeSlice* temp = stturnon_;
  stturnon_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// VideoColorCtl

// optional .BVCU.PUConfig.DayTimeSlice stTime = 1;
inline bool VideoColorCtl::has_sttime() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VideoColorCtl::set_has_sttime() {
  _has_bits_[0] |= 0x00000001u;
}
inline void VideoColorCtl::clear_has_sttime() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void VideoColorCtl::clear_sttime() {
  if (sttime_ != NULL) sttime_->::BVCU::PUConfig::DayTimeSlice::Clear();
  clear_has_sttime();
}
inline const ::BVCU::PUConfig::DayTimeSlice& VideoColorCtl::sttime() const {
  return sttime_ != NULL ? *sttime_ : *default_instance_->sttime_;
}
inline ::BVCU::PUConfig::DayTimeSlice* VideoColorCtl::mutable_sttime() {
  set_has_sttime();
  if (sttime_ == NULL) sttime_ = new ::BVCU::PUConfig::DayTimeSlice;
  return sttime_;
}
inline ::BVCU::PUConfig::DayTimeSlice* VideoColorCtl::release_sttime() {
  clear_has_sttime();
  ::BVCU::PUConfig::DayTimeSlice* temp = sttime_;
  sttime_ = NULL;
  return temp;
}

// optional uint32 cBrightness = 2;
inline bool VideoColorCtl::has_cbrightness() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void VideoColorCtl::set_has_cbrightness() {
  _has_bits_[0] |= 0x00000002u;
}
inline void VideoColorCtl::clear_has_cbrightness() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void VideoColorCtl::clear_cbrightness() {
  cbrightness_ = 0u;
  clear_has_cbrightness();
}
inline ::google::protobuf::uint32 VideoColorCtl::cbrightness() const {
  return cbrightness_;
}
inline void VideoColorCtl::set_cbrightness(::google::protobuf::uint32 value) {
  set_has_cbrightness();
  cbrightness_ = value;
}

// optional uint32 cContrast = 3;
inline bool VideoColorCtl::has_ccontrast() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void VideoColorCtl::set_has_ccontrast() {
  _has_bits_[0] |= 0x00000004u;
}
inline void VideoColorCtl::clear_has_ccontrast() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void VideoColorCtl::clear_ccontrast() {
  ccontrast_ = 0u;
  clear_has_ccontrast();
}
inline ::google::protobuf::uint32 VideoColorCtl::ccontrast() const {
  return ccontrast_;
}
inline void VideoColorCtl::set_ccontrast(::google::protobuf::uint32 value) {
  set_has_ccontrast();
  ccontrast_ = value;
}

// optional uint32 cSaturation = 4;
inline bool VideoColorCtl::has_csaturation() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void VideoColorCtl::set_has_csaturation() {
  _has_bits_[0] |= 0x00000008u;
}
inline void VideoColorCtl::clear_has_csaturation() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void VideoColorCtl::clear_csaturation() {
  csaturation_ = 0u;
  clear_has_csaturation();
}
inline ::google::protobuf::uint32 VideoColorCtl::csaturation() const {
  return csaturation_;
}
inline void VideoColorCtl::set_csaturation(::google::protobuf::uint32 value) {
  set_has_csaturation();
  csaturation_ = value;
}

// optional uint32 cHue = 5;
inline bool VideoColorCtl::has_chue() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void VideoColorCtl::set_has_chue() {
  _has_bits_[0] |= 0x00000010u;
}
inline void VideoColorCtl::clear_has_chue() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void VideoColorCtl::clear_chue() {
  chue_ = 0u;
  clear_has_chue();
}
inline ::google::protobuf::uint32 VideoColorCtl::chue() const {
  return chue_;
}
inline void VideoColorCtl::set_chue(::google::protobuf::uint32 value) {
  set_has_chue();
  chue_ = value;
}

// -------------------------------------------------------------------

// MotionDetect

// optional uint32 bSupport = 1;
inline bool MotionDetect::has_bsupport() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MotionDetect::set_has_bsupport() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MotionDetect::clear_has_bsupport() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MotionDetect::clear_bsupport() {
  bsupport_ = 0u;
  clear_has_bsupport();
}
inline ::google::protobuf::uint32 MotionDetect::bsupport() const {
  return bsupport_;
}
inline void MotionDetect::set_bsupport(::google::protobuf::uint32 value) {
  set_has_bsupport();
  bsupport_ = value;
}

// repeated .BVCU.PUConfig.ImageRect rcROI = 2;
inline int MotionDetect::rcroi_size() const {
  return rcroi_.size();
}
inline void MotionDetect::clear_rcroi() {
  rcroi_.Clear();
}
inline const ::BVCU::PUConfig::ImageRect& MotionDetect::rcroi(int index) const {
  return rcroi_.Get(index);
}
inline ::BVCU::PUConfig::ImageRect* MotionDetect::mutable_rcroi(int index) {
  return rcroi_.Mutable(index);
}
inline ::BVCU::PUConfig::ImageRect* MotionDetect::add_rcroi() {
  return rcroi_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::BVCU::PUConfig::ImageRect >&
MotionDetect::rcroi() const {
  return rcroi_;
}
inline ::google::protobuf::RepeatedPtrField< ::BVCU::PUConfig::ImageRect >*
MotionDetect::mutable_rcroi() {
  return &rcroi_;
}

// optional uint32 iSensitivity = 3;
inline bool MotionDetect::has_isensitivity() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MotionDetect::set_has_isensitivity() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MotionDetect::clear_has_isensitivity() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MotionDetect::clear_isensitivity() {
  isensitivity_ = 0u;
  clear_has_isensitivity();
}
inline ::google::protobuf::uint32 MotionDetect::isensitivity() const {
  return isensitivity_;
}
inline void MotionDetect::set_isensitivity(::google::protobuf::uint32 value) {
  set_has_isensitivity();
  isensitivity_ = value;
}

// optional uint32 iInterval = 4;
inline bool MotionDetect::has_iinterval() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MotionDetect::set_has_iinterval() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MotionDetect::clear_has_iinterval() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MotionDetect::clear_iinterval() {
  iinterval_ = 0u;
  clear_has_iinterval();
}
inline ::google::protobuf::uint32 MotionDetect::iinterval() const {
  return iinterval_;
}
inline void MotionDetect::set_iinterval(::google::protobuf::uint32 value) {
  set_has_iinterval();
  iinterval_ = value;
}

// -------------------------------------------------------------------

// VideoShelter

// optional uint32 bSupport = 1;
inline bool VideoShelter::has_bsupport() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VideoShelter::set_has_bsupport() {
  _has_bits_[0] |= 0x00000001u;
}
inline void VideoShelter::clear_has_bsupport() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void VideoShelter::clear_bsupport() {
  bsupport_ = 0u;
  clear_has_bsupport();
}
inline ::google::protobuf::uint32 VideoShelter::bsupport() const {
  return bsupport_;
}
inline void VideoShelter::set_bsupport(::google::protobuf::uint32 value) {
  set_has_bsupport();
  bsupport_ = value;
}

// repeated .BVCU.PUConfig.ImageRect rcROI = 2;
inline int VideoShelter::rcroi_size() const {
  return rcroi_.size();
}
inline void VideoShelter::clear_rcroi() {
  rcroi_.Clear();
}
inline const ::BVCU::PUConfig::ImageRect& VideoShelter::rcroi(int index) const {
  return rcroi_.Get(index);
}
inline ::BVCU::PUConfig::ImageRect* VideoShelter::mutable_rcroi(int index) {
  return rcroi_.Mutable(index);
}
inline ::BVCU::PUConfig::ImageRect* VideoShelter::add_rcroi() {
  return rcroi_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::BVCU::PUConfig::ImageRect >&
VideoShelter::rcroi() const {
  return rcroi_;
}
inline ::google::protobuf::RepeatedPtrField< ::BVCU::PUConfig::ImageRect >*
VideoShelter::mutable_rcroi() {
  return &rcroi_;
}

// -------------------------------------------------------------------

// VideoOcclusionDetect

// optional uint32 bSupport = 1;
inline bool VideoOcclusionDetect::has_bsupport() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VideoOcclusionDetect::set_has_bsupport() {
  _has_bits_[0] |= 0x00000001u;
}
inline void VideoOcclusionDetect::clear_has_bsupport() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void VideoOcclusionDetect::clear_bsupport() {
  bsupport_ = 0u;
  clear_has_bsupport();
}
inline ::google::protobuf::uint32 VideoOcclusionDetect::bsupport() const {
  return bsupport_;
}
inline void VideoOcclusionDetect::set_bsupport(::google::protobuf::uint32 value) {
  set_has_bsupport();
  bsupport_ = value;
}

// repeated .BVCU.PUConfig.ImageRect rcROI = 2;
inline int VideoOcclusionDetect::rcroi_size() const {
  return rcroi_.size();
}
inline void VideoOcclusionDetect::clear_rcroi() {
  rcroi_.Clear();
}
inline const ::BVCU::PUConfig::ImageRect& VideoOcclusionDetect::rcroi(int index) const {
  return rcroi_.Get(index);
}
inline ::BVCU::PUConfig::ImageRect* VideoOcclusionDetect::mutable_rcroi(int index) {
  return rcroi_.Mutable(index);
}
inline ::BVCU::PUConfig::ImageRect* VideoOcclusionDetect::add_rcroi() {
  return rcroi_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::BVCU::PUConfig::ImageRect >&
VideoOcclusionDetect::rcroi() const {
  return rcroi_;
}
inline ::google::protobuf::RepeatedPtrField< ::BVCU::PUConfig::ImageRect >*
VideoOcclusionDetect::mutable_rcroi() {
  return &rcroi_;
}

// -------------------------------------------------------------------

// VideoIn

// repeated .BVCU.PUConfig.VideoColorCtl stVCC = 1;
inline int VideoIn::stvcc_size() const {
  return stvcc_.size();
}
inline void VideoIn::clear_stvcc() {
  stvcc_.Clear();
}
inline const ::BVCU::PUConfig::VideoColorCtl& VideoIn::stvcc(int index) const {
  return stvcc_.Get(index);
}
inline ::BVCU::PUConfig::VideoColorCtl* VideoIn::mutable_stvcc(int index) {
  return stvcc_.Mutable(index);
}
inline ::BVCU::PUConfig::VideoColorCtl* VideoIn::add_stvcc() {
  return stvcc_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::BVCU::PUConfig::VideoColorCtl >&
VideoIn::stvcc() const {
  return stvcc_;
}
inline ::google::protobuf::RepeatedPtrField< ::BVCU::PUConfig::VideoColorCtl >*
VideoIn::mutable_stvcc() {
  return &stvcc_;
}

// optional .BVCU.PUConfig.MotionDetect stMD = 2;
inline bool VideoIn::has_stmd() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void VideoIn::set_has_stmd() {
  _has_bits_[0] |= 0x00000002u;
}
inline void VideoIn::clear_has_stmd() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void VideoIn::clear_stmd() {
  if (stmd_ != NULL) stmd_->::BVCU::PUConfig::MotionDetect::Clear();
  clear_has_stmd();
}
inline const ::BVCU::PUConfig::MotionDetect& VideoIn::stmd() const {
  return stmd_ != NULL ? *stmd_ : *default_instance_->stmd_;
}
inline ::BVCU::PUConfig::MotionDetect* VideoIn::mutable_stmd() {
  set_has_stmd();
  if (stmd_ == NULL) stmd_ = new ::BVCU::PUConfig::MotionDetect;
  return stmd_;
}
inline ::BVCU::PUConfig::MotionDetect* VideoIn::release_stmd() {
  clear_has_stmd();
  ::BVCU::PUConfig::MotionDetect* temp = stmd_;
  stmd_ = NULL;
  return temp;
}

// optional .BVCU.PUConfig.VideoShelter stShelter = 3;
inline bool VideoIn::has_stshelter() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void VideoIn::set_has_stshelter() {
  _has_bits_[0] |= 0x00000004u;
}
inline void VideoIn::clear_has_stshelter() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void VideoIn::clear_stshelter() {
  if (stshelter_ != NULL) stshelter_->::BVCU::PUConfig::VideoShelter::Clear();
  clear_has_stshelter();
}
inline const ::BVCU::PUConfig::VideoShelter& VideoIn::stshelter() const {
  return stshelter_ != NULL ? *stshelter_ : *default_instance_->stshelter_;
}
inline ::BVCU::PUConfig::VideoShelter* VideoIn::mutable_stshelter() {
  set_has_stshelter();
  if (stshelter_ == NULL) stshelter_ = new ::BVCU::PUConfig::VideoShelter;
  return stshelter_;
}
inline ::BVCU::PUConfig::VideoShelter* VideoIn::release_stshelter() {
  clear_has_stshelter();
  ::BVCU::PUConfig::VideoShelter* temp = stshelter_;
  stshelter_ = NULL;
  return temp;
}

// optional .BVCU.PUConfig.VideoOcclusionDetect stOcclusion = 4;
inline bool VideoIn::has_stocclusion() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void VideoIn::set_has_stocclusion() {
  _has_bits_[0] |= 0x00000008u;
}
inline void VideoIn::clear_has_stocclusion() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void VideoIn::clear_stocclusion() {
  if (stocclusion_ != NULL) stocclusion_->::BVCU::PUConfig::VideoOcclusionDetect::Clear();
  clear_has_stocclusion();
}
inline const ::BVCU::PUConfig::VideoOcclusionDetect& VideoIn::stocclusion() const {
  return stocclusion_ != NULL ? *stocclusion_ : *default_instance_->stocclusion_;
}
inline ::BVCU::PUConfig::VideoOcclusionDetect* VideoIn::mutable_stocclusion() {
  set_has_stocclusion();
  if (stocclusion_ == NULL) stocclusion_ = new ::BVCU::PUConfig::VideoOcclusionDetect;
  return stocclusion_;
}
inline ::BVCU::PUConfig::VideoOcclusionDetect* VideoIn::release_stocclusion() {
  clear_has_stocclusion();
  ::BVCU::PUConfig::VideoOcclusionDetect* temp = stocclusion_;
  stocclusion_ = NULL;
  return temp;
}

// repeated .BVCU.PUConfig.VideoFormat stVideoFormat = 5;
inline int VideoIn::stvideoformat_size() const {
  return stvideoformat_.size();
}
inline void VideoIn::clear_stvideoformat() {
  stvideoformat_.Clear();
}
inline const ::BVCU::PUConfig::VideoFormat& VideoIn::stvideoformat(int index) const {
  return stvideoformat_.Get(index);
}
inline ::BVCU::PUConfig::VideoFormat* VideoIn::mutable_stvideoformat(int index) {
  return stvideoformat_.Mutable(index);
}
inline ::BVCU::PUConfig::VideoFormat* VideoIn::add_stvideoformat() {
  return stvideoformat_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::BVCU::PUConfig::VideoFormat >&
VideoIn::stvideoformat() const {
  return stvideoformat_;
}
inline ::google::protobuf::RepeatedPtrField< ::BVCU::PUConfig::VideoFormat >*
VideoIn::mutable_stvideoformat() {
  return &stvideoformat_;
}

// optional uint32 iVideoFormatIndex = 6;
inline bool VideoIn::has_ivideoformatindex() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void VideoIn::set_has_ivideoformatindex() {
  _has_bits_[0] |= 0x00000020u;
}
inline void VideoIn::clear_has_ivideoformatindex() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void VideoIn::clear_ivideoformatindex() {
  ivideoformatindex_ = 0u;
  clear_has_ivideoformatindex();
}
inline ::google::protobuf::uint32 VideoIn::ivideoformatindex() const {
  return ivideoformatindex_;
}
inline void VideoIn::set_ivideoformatindex(::google::protobuf::uint32 value) {
  set_has_ivideoformatindex();
  ivideoformatindex_ = value;
}

// optional int32 iOSDIcon = 7;
inline bool VideoIn::has_iosdicon() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void VideoIn::set_has_iosdicon() {
  _has_bits_[0] |= 0x00000040u;
}
inline void VideoIn::clear_has_iosdicon() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void VideoIn::clear_iosdicon() {
  iosdicon_ = 0;
  clear_has_iosdicon();
}
inline ::google::protobuf::int32 VideoIn::iosdicon() const {
  return iosdicon_;
}
inline void VideoIn::set_iosdicon(::google::protobuf::int32 value) {
  set_has_iosdicon();
  iosdicon_ = value;
}

// optional string szOSDIcon = 8;
inline bool VideoIn::has_szosdicon() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void VideoIn::set_has_szosdicon() {
  _has_bits_[0] |= 0x00000080u;
}
inline void VideoIn::clear_has_szosdicon() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void VideoIn::clear_szosdicon() {
  if (szosdicon_ != &::google::protobuf::internal::kEmptyString) {
    szosdicon_->clear();
  }
  clear_has_szosdicon();
}
inline const ::std::string& VideoIn::szosdicon() const {
  return *szosdicon_;
}
inline void VideoIn::set_szosdicon(const ::std::string& value) {
  set_has_szosdicon();
  if (szosdicon_ == &::google::protobuf::internal::kEmptyString) {
    szosdicon_ = new ::std::string;
  }
  szosdicon_->assign(value);
}
inline void VideoIn::set_szosdicon(const char* value) {
  set_has_szosdicon();
  if (szosdicon_ == &::google::protobuf::internal::kEmptyString) {
    szosdicon_ = new ::std::string;
  }
  szosdicon_->assign(value);
}
inline void VideoIn::set_szosdicon(const char* value, size_t size) {
  set_has_szosdicon();
  if (szosdicon_ == &::google::protobuf::internal::kEmptyString) {
    szosdicon_ = new ::std::string;
  }
  szosdicon_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* VideoIn::mutable_szosdicon() {
  set_has_szosdicon();
  if (szosdicon_ == &::google::protobuf::internal::kEmptyString) {
    szosdicon_ = new ::std::string;
  }
  return szosdicon_;
}
inline ::std::string* VideoIn::release_szosdicon() {
  clear_has_szosdicon();
  if (szosdicon_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = szosdicon_;
    szosdicon_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional .BVCU.PUConfig.ImagePos stOSDIconPos = 9;
inline bool VideoIn::has_stosdiconpos() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void VideoIn::set_has_stosdiconpos() {
  _has_bits_[0] |= 0x00000100u;
}
inline void VideoIn::clear_has_stosdiconpos() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void VideoIn::clear_stosdiconpos() {
  if (stosdiconpos_ != NULL) stosdiconpos_->::BVCU::PUConfig::ImagePos::Clear();
  clear_has_stosdiconpos();
}
inline const ::BVCU::PUConfig::ImagePos& VideoIn::stosdiconpos() const {
  return stosdiconpos_ != NULL ? *stosdiconpos_ : *default_instance_->stosdiconpos_;
}
inline ::BVCU::PUConfig::ImagePos* VideoIn::mutable_stosdiconpos() {
  set_has_stosdiconpos();
  if (stosdiconpos_ == NULL) stosdiconpos_ = new ::BVCU::PUConfig::ImagePos;
  return stosdiconpos_;
}
inline ::BVCU::PUConfig::ImagePos* VideoIn::release_stosdiconpos() {
  clear_has_stosdiconpos();
  ::BVCU::PUConfig::ImagePos* temp = stosdiconpos_;
  stosdiconpos_ = NULL;
  return temp;
}

// optional string szOSDTitle = 10;
inline bool VideoIn::has_szosdtitle() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void VideoIn::set_has_szosdtitle() {
  _has_bits_[0] |= 0x00000200u;
}
inline void VideoIn::clear_has_szosdtitle() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void VideoIn::clear_szosdtitle() {
  if (szosdtitle_ != &::google::protobuf::internal::kEmptyString) {
    szosdtitle_->clear();
  }
  clear_has_szosdtitle();
}
inline const ::std::string& VideoIn::szosdtitle() const {
  return *szosdtitle_;
}
inline void VideoIn::set_szosdtitle(const ::std::string& value) {
  set_has_szosdtitle();
  if (szosdtitle_ == &::google::protobuf::internal::kEmptyString) {
    szosdtitle_ = new ::std::string;
  }
  szosdtitle_->assign(value);
}
inline void VideoIn::set_szosdtitle(const char* value) {
  set_has_szosdtitle();
  if (szosdtitle_ == &::google::protobuf::internal::kEmptyString) {
    szosdtitle_ = new ::std::string;
  }
  szosdtitle_->assign(value);
}
inline void VideoIn::set_szosdtitle(const char* value, size_t size) {
  set_has_szosdtitle();
  if (szosdtitle_ == &::google::protobuf::internal::kEmptyString) {
    szosdtitle_ = new ::std::string;
  }
  szosdtitle_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* VideoIn::mutable_szosdtitle() {
  set_has_szosdtitle();
  if (szosdtitle_ == &::google::protobuf::internal::kEmptyString) {
    szosdtitle_ = new ::std::string;
  }
  return szosdtitle_;
}
inline ::std::string* VideoIn::release_szosdtitle() {
  clear_has_szosdtitle();
  if (szosdtitle_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = szosdtitle_;
    szosdtitle_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional .BVCU.PUConfig.ImagePos stOSDTitlePos = 11;
inline bool VideoIn::has_stosdtitlepos() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void VideoIn::set_has_stosdtitlepos() {
  _has_bits_[0] |= 0x00000400u;
}
inline void VideoIn::clear_has_stosdtitlepos() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void VideoIn::clear_stosdtitlepos() {
  if (stosdtitlepos_ != NULL) stosdtitlepos_->::BVCU::PUConfig::ImagePos::Clear();
  clear_has_stosdtitlepos();
}
inline const ::BVCU::PUConfig::ImagePos& VideoIn::stosdtitlepos() const {
  return stosdtitlepos_ != NULL ? *stosdtitlepos_ : *default_instance_->stosdtitlepos_;
}
inline ::BVCU::PUConfig::ImagePos* VideoIn::mutable_stosdtitlepos() {
  set_has_stosdtitlepos();
  if (stosdtitlepos_ == NULL) stosdtitlepos_ = new ::BVCU::PUConfig::ImagePos;
  return stosdtitlepos_;
}
inline ::BVCU::PUConfig::ImagePos* VideoIn::release_stosdtitlepos() {
  clear_has_stosdtitlepos();
  ::BVCU::PUConfig::ImagePos* temp = stosdtitlepos_;
  stosdtitlepos_ = NULL;
  return temp;
}

// optional uint32 iOSDTitleFontSize = 12;
inline bool VideoIn::has_iosdtitlefontsize() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void VideoIn::set_has_iosdtitlefontsize() {
  _has_bits_[0] |= 0x00000800u;
}
inline void VideoIn::clear_has_iosdtitlefontsize() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void VideoIn::clear_iosdtitlefontsize() {
  iosdtitlefontsize_ = 0u;
  clear_has_iosdtitlefontsize();
}
inline ::google::protobuf::uint32 VideoIn::iosdtitlefontsize() const {
  return iosdtitlefontsize_;
}
inline void VideoIn::set_iosdtitlefontsize(::google::protobuf::uint32 value) {
  set_has_iosdtitlefontsize();
  iosdtitlefontsize_ = value;
}

// optional uint32 cOSDTime = 13;
inline bool VideoIn::has_cosdtime() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void VideoIn::set_has_cosdtime() {
  _has_bits_[0] |= 0x00001000u;
}
inline void VideoIn::clear_has_cosdtime() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void VideoIn::clear_cosdtime() {
  cosdtime_ = 0u;
  clear_has_cosdtime();
}
inline ::google::protobuf::uint32 VideoIn::cosdtime() const {
  return cosdtime_;
}
inline void VideoIn::set_cosdtime(::google::protobuf::uint32 value) {
  set_has_cosdtime();
  cosdtime_ = value;
}

// optional uint32 cOSDTimeSplitChar = 14;
inline bool VideoIn::has_cosdtimesplitchar() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void VideoIn::set_has_cosdtimesplitchar() {
  _has_bits_[0] |= 0x00002000u;
}
inline void VideoIn::clear_has_cosdtimesplitchar() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void VideoIn::clear_cosdtimesplitchar() {
  cosdtimesplitchar_ = 0u;
  clear_has_cosdtimesplitchar();
}
inline ::google::protobuf::uint32 VideoIn::cosdtimesplitchar() const {
  return cosdtimesplitchar_;
}
inline void VideoIn::set_cosdtimesplitchar(::google::protobuf::uint32 value) {
  set_has_cosdtimesplitchar();
  cosdtimesplitchar_ = value;
}

// optional uint32 iOSDTimeFontSize = 15;
inline bool VideoIn::has_iosdtimefontsize() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void VideoIn::set_has_iosdtimefontsize() {
  _has_bits_[0] |= 0x00004000u;
}
inline void VideoIn::clear_has_iosdtimefontsize() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void VideoIn::clear_iosdtimefontsize() {
  iosdtimefontsize_ = 0u;
  clear_has_iosdtimefontsize();
}
inline ::google::protobuf::uint32 VideoIn::iosdtimefontsize() const {
  return iosdtimefontsize_;
}
inline void VideoIn::set_iosdtimefontsize(::google::protobuf::uint32 value) {
  set_has_iosdtimefontsize();
  iosdtimefontsize_ = value;
}

// optional .BVCU.PUConfig.ImagePos stOSDTimePos = 16;
inline bool VideoIn::has_stosdtimepos() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void VideoIn::set_has_stosdtimepos() {
  _has_bits_[0] |= 0x00008000u;
}
inline void VideoIn::clear_has_stosdtimepos() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void VideoIn::clear_stosdtimepos() {
  if (stosdtimepos_ != NULL) stosdtimepos_->::BVCU::PUConfig::ImagePos::Clear();
  clear_has_stosdtimepos();
}
inline const ::BVCU::PUConfig::ImagePos& VideoIn::stosdtimepos() const {
  return stosdtimepos_ != NULL ? *stosdtimepos_ : *default_instance_->stosdtimepos_;
}
inline ::BVCU::PUConfig::ImagePos* VideoIn::mutable_stosdtimepos() {
  set_has_stosdtimepos();
  if (stosdtimepos_ == NULL) stosdtimepos_ = new ::BVCU::PUConfig::ImagePos;
  return stosdtimepos_;
}
inline ::BVCU::PUConfig::ImagePos* VideoIn::release_stosdtimepos() {
  clear_has_stosdtimepos();
  ::BVCU::PUConfig::ImagePos* temp = stosdtimepos_;
  stosdtimepos_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// AudioIn

// optional uint32 iInput = 1;
inline bool AudioIn::has_iinput() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AudioIn::set_has_iinput() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AudioIn::clear_has_iinput() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AudioIn::clear_iinput() {
  iinput_ = 0u;
  clear_has_iinput();
}
inline ::google::protobuf::uint32 AudioIn::iinput() const {
  return iinput_;
}
inline void AudioIn::set_iinput(::google::protobuf::uint32 value) {
  set_has_iinput();
  iinput_ = value;
}

// optional uint32 iChannelCount = 2;
inline bool AudioIn::has_ichannelcount() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AudioIn::set_has_ichannelcount() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AudioIn::clear_has_ichannelcount() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AudioIn::clear_ichannelcount() {
  ichannelcount_ = 0u;
  clear_has_ichannelcount();
}
inline ::google::protobuf::uint32 AudioIn::ichannelcount() const {
  return ichannelcount_;
}
inline void AudioIn::set_ichannelcount(::google::protobuf::uint32 value) {
  set_has_ichannelcount();
  ichannelcount_ = value;
}

// optional uint32 iSamplesPerSec = 3;
inline bool AudioIn::has_isamplespersec() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AudioIn::set_has_isamplespersec() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AudioIn::clear_has_isamplespersec() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AudioIn::clear_isamplespersec() {
  isamplespersec_ = 0u;
  clear_has_isamplespersec();
}
inline ::google::protobuf::uint32 AudioIn::isamplespersec() const {
  return isamplespersec_;
}
inline void AudioIn::set_isamplespersec(::google::protobuf::uint32 value) {
  set_has_isamplespersec();
  isamplespersec_ = value;
}

// optional uint32 iBitsPerSample = 4;
inline bool AudioIn::has_ibitspersample() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AudioIn::set_has_ibitspersample() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AudioIn::clear_has_ibitspersample() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AudioIn::clear_ibitspersample() {
  ibitspersample_ = 0u;
  clear_has_ibitspersample();
}
inline ::google::protobuf::uint32 AudioIn::ibitspersample() const {
  return ibitspersample_;
}
inline void AudioIn::set_ibitspersample(::google::protobuf::uint32 value) {
  set_has_ibitspersample();
  ibitspersample_ = value;
}

// optional uint32 iVolume = 5;
inline bool AudioIn::has_ivolume() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AudioIn::set_has_ivolume() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AudioIn::clear_has_ivolume() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AudioIn::clear_ivolume() {
  ivolume_ = 0u;
  clear_has_ivolume();
}
inline ::google::protobuf::uint32 AudioIn::ivolume() const {
  return ivolume_;
}
inline void AudioIn::set_ivolume(::google::protobuf::uint32 value) {
  set_has_ivolume();
  ivolume_ = value;
}

// -------------------------------------------------------------------

// AudioDecoderParam

// optional uint32 bEnable = 1;
inline bool AudioDecoderParam::has_benable() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AudioDecoderParam::set_has_benable() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AudioDecoderParam::clear_has_benable() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AudioDecoderParam::clear_benable() {
  benable_ = 0u;
  clear_has_benable();
}
inline ::google::protobuf::uint32 AudioDecoderParam::benable() const {
  return benable_;
}
inline void AudioDecoderParam::set_benable(::google::protobuf::uint32 value) {
  set_has_benable();
  benable_ = value;
}

// repeated uint32 iAudioCodecAll = 2;
inline int AudioDecoderParam::iaudiocodecall_size() const {
  return iaudiocodecall_.size();
}
inline void AudioDecoderParam::clear_iaudiocodecall() {
  iaudiocodecall_.Clear();
}
inline ::google::protobuf::uint32 AudioDecoderParam::iaudiocodecall(int index) const {
  return iaudiocodecall_.Get(index);
}
inline void AudioDecoderParam::set_iaudiocodecall(int index, ::google::protobuf::uint32 value) {
  iaudiocodecall_.Set(index, value);
}
inline void AudioDecoderParam::add_iaudiocodecall(::google::protobuf::uint32 value) {
  iaudiocodecall_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
AudioDecoderParam::iaudiocodecall() const {
  return iaudiocodecall_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
AudioDecoderParam::mutable_iaudiocodecall() {
  return &iaudiocodecall_;
}

// optional uint32 iAudioCodecIndex = 3;
inline bool AudioDecoderParam::has_iaudiocodecindex() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AudioDecoderParam::set_has_iaudiocodecindex() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AudioDecoderParam::clear_has_iaudiocodecindex() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AudioDecoderParam::clear_iaudiocodecindex() {
  iaudiocodecindex_ = 0u;
  clear_has_iaudiocodecindex();
}
inline ::google::protobuf::uint32 AudioDecoderParam::iaudiocodecindex() const {
  return iaudiocodecindex_;
}
inline void AudioDecoderParam::set_iaudiocodecindex(::google::protobuf::uint32 value) {
  set_has_iaudiocodecindex();
  iaudiocodecindex_ = value;
}

// -------------------------------------------------------------------

// AudioOut

// optional .BVCU.PUConfig.AudioDecoderParam stADParam = 1;
inline bool AudioOut::has_stadparam() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AudioOut::set_has_stadparam() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AudioOut::clear_has_stadparam() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AudioOut::clear_stadparam() {
  if (stadparam_ != NULL) stadparam_->::BVCU::PUConfig::AudioDecoderParam::Clear();
  clear_has_stadparam();
}
inline const ::BVCU::PUConfig::AudioDecoderParam& AudioOut::stadparam() const {
  return stadparam_ != NULL ? *stadparam_ : *default_instance_->stadparam_;
}
inline ::BVCU::PUConfig::AudioDecoderParam* AudioOut::mutable_stadparam() {
  set_has_stadparam();
  if (stadparam_ == NULL) stadparam_ = new ::BVCU::PUConfig::AudioDecoderParam;
  return stadparam_;
}
inline ::BVCU::PUConfig::AudioDecoderParam* AudioOut::release_stadparam() {
  clear_has_stadparam();
  ::BVCU::PUConfig::AudioDecoderParam* temp = stadparam_;
  stadparam_ = NULL;
  return temp;
}

// optional uint32 iChannelCount = 2;
inline bool AudioOut::has_ichannelcount() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AudioOut::set_has_ichannelcount() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AudioOut::clear_has_ichannelcount() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AudioOut::clear_ichannelcount() {
  ichannelcount_ = 0u;
  clear_has_ichannelcount();
}
inline ::google::protobuf::uint32 AudioOut::ichannelcount() const {
  return ichannelcount_;
}
inline void AudioOut::set_ichannelcount(::google::protobuf::uint32 value) {
  set_has_ichannelcount();
  ichannelcount_ = value;
}

// optional uint32 iSamplesPerSec = 3;
inline bool AudioOut::has_isamplespersec() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AudioOut::set_has_isamplespersec() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AudioOut::clear_has_isamplespersec() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AudioOut::clear_isamplespersec() {
  isamplespersec_ = 0u;
  clear_has_isamplespersec();
}
inline ::google::protobuf::uint32 AudioOut::isamplespersec() const {
  return isamplespersec_;
}
inline void AudioOut::set_isamplespersec(::google::protobuf::uint32 value) {
  set_has_isamplespersec();
  isamplespersec_ = value;
}

// optional uint32 iBitsPerSample = 4;
inline bool AudioOut::has_ibitspersample() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AudioOut::set_has_ibitspersample() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AudioOut::clear_has_ibitspersample() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AudioOut::clear_ibitspersample() {
  ibitspersample_ = 0u;
  clear_has_ibitspersample();
}
inline ::google::protobuf::uint32 AudioOut::ibitspersample() const {
  return ibitspersample_;
}
inline void AudioOut::set_ibitspersample(::google::protobuf::uint32 value) {
  set_has_ibitspersample();
  ibitspersample_ = value;
}

// optional uint32 iVolume = 5;
inline bool AudioOut::has_ivolume() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AudioOut::set_has_ivolume() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AudioOut::clear_has_ivolume() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AudioOut::clear_ivolume() {
  ivolume_ = 0u;
  clear_has_ivolume();
}
inline ::google::protobuf::uint32 AudioOut::ivolume() const {
  return ivolume_;
}
inline void AudioOut::set_ivolume(::google::protobuf::uint32 value) {
  set_has_ivolume();
  ivolume_ = value;
}

// -------------------------------------------------------------------

// AlertIn

// optional uint32 bType = 1;
inline bool AlertIn::has_btype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AlertIn::set_has_btype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AlertIn::clear_has_btype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AlertIn::clear_btype() {
  btype_ = 0u;
  clear_has_btype();
}
inline ::google::protobuf::uint32 AlertIn::btype() const {
  return btype_;
}
inline void AlertIn::set_btype(::google::protobuf::uint32 value) {
  set_has_btype();
  btype_ = value;
}

// optional uint32 iInterval = 2;
inline bool AlertIn::has_iinterval() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AlertIn::set_has_iinterval() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AlertIn::clear_has_iinterval() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AlertIn::clear_iinterval() {
  iinterval_ = 0u;
  clear_has_iinterval();
}
inline ::google::protobuf::uint32 AlertIn::iinterval() const {
  return iinterval_;
}
inline void AlertIn::set_iinterval(::google::protobuf::uint32 value) {
  set_has_iinterval();
  iinterval_ = value;
}

// -------------------------------------------------------------------

// AlertOut

// optional uint32 bAction = 1;
inline bool AlertOut::has_baction() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AlertOut::set_has_baction() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AlertOut::clear_has_baction() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AlertOut::clear_baction() {
  baction_ = 0u;
  clear_has_baction();
}
inline ::google::protobuf::uint32 AlertOut::baction() const {
  return baction_;
}
inline void AlertOut::set_baction(::google::protobuf::uint32 value) {
  set_has_baction();
  baction_ = value;
}

// optional uint32 iDuration = 2;
inline bool AlertOut::has_iduration() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AlertOut::set_has_iduration() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AlertOut::clear_has_iduration() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AlertOut::clear_iduration() {
  iduration_ = 0u;
  clear_has_iduration();
}
inline ::google::protobuf::uint32 AlertOut::iduration() const {
  return iduration_;
}
inline void AlertOut::set_iduration(::google::protobuf::uint32 value) {
  set_has_iduration();
  iduration_ = value;
}

// -------------------------------------------------------------------

// GPSParam

// optional uint32 bEnable = 1;
inline bool GPSParam::has_benable() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GPSParam::set_has_benable() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GPSParam::clear_has_benable() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GPSParam::clear_benable() {
  benable_ = 0u;
  clear_has_benable();
}
inline ::google::protobuf::uint32 GPSParam::benable() const {
  return benable_;
}
inline void GPSParam::set_benable(::google::protobuf::uint32 value) {
  set_has_benable();
  benable_ = value;
}

// optional uint32 iReportInterval = 2;
inline bool GPSParam::has_ireportinterval() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GPSParam::set_has_ireportinterval() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GPSParam::clear_has_ireportinterval() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GPSParam::clear_ireportinterval() {
  ireportinterval_ = 0u;
  clear_has_ireportinterval();
}
inline ::google::protobuf::uint32 GPSParam::ireportinterval() const {
  return ireportinterval_;
}
inline void GPSParam::set_ireportinterval(::google::protobuf::uint32 value) {
  set_has_ireportinterval();
  ireportinterval_ = value;
}

// -------------------------------------------------------------------

// GPSData

// optional .BVCU.PUConfig.WallTime stTime = 1;
inline bool GPSData::has_sttime() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GPSData::set_has_sttime() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GPSData::clear_has_sttime() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GPSData::clear_sttime() {
  if (sttime_ != NULL) sttime_->::BVCU::PUConfig::WallTime::Clear();
  clear_has_sttime();
}
inline const ::BVCU::PUConfig::WallTime& GPSData::sttime() const {
  return sttime_ != NULL ? *sttime_ : *default_instance_->sttime_;
}
inline ::BVCU::PUConfig::WallTime* GPSData::mutable_sttime() {
  set_has_sttime();
  if (sttime_ == NULL) sttime_ = new ::BVCU::PUConfig::WallTime;
  return sttime_;
}
inline ::BVCU::PUConfig::WallTime* GPSData::release_sttime() {
  clear_has_sttime();
  ::BVCU::PUConfig::WallTime* temp = sttime_;
  sttime_ = NULL;
  return temp;
}

// optional uint32 iLongitude = 2;
inline bool GPSData::has_ilongitude() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GPSData::set_has_ilongitude() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GPSData::clear_has_ilongitude() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GPSData::clear_ilongitude() {
  ilongitude_ = 0u;
  clear_has_ilongitude();
}
inline ::google::protobuf::uint32 GPSData::ilongitude() const {
  return ilongitude_;
}
inline void GPSData::set_ilongitude(::google::protobuf::uint32 value) {
  set_has_ilongitude();
  ilongitude_ = value;
}

// optional uint32 iLatitude = 3;
inline bool GPSData::has_ilatitude() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GPSData::set_has_ilatitude() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GPSData::clear_has_ilatitude() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GPSData::clear_ilatitude() {
  ilatitude_ = 0u;
  clear_has_ilatitude();
}
inline ::google::protobuf::uint32 GPSData::ilatitude() const {
  return ilatitude_;
}
inline void GPSData::set_ilatitude(::google::protobuf::uint32 value) {
  set_has_ilatitude();
  ilatitude_ = value;
}

// optional uint32 iHeight = 4;
inline bool GPSData::has_iheight() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GPSData::set_has_iheight() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GPSData::clear_has_iheight() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GPSData::clear_iheight() {
  iheight_ = 0u;
  clear_has_iheight();
}
inline ::google::protobuf::uint32 GPSData::iheight() const {
  return iheight_;
}
inline void GPSData::set_iheight(::google::protobuf::uint32 value) {
  set_has_iheight();
  iheight_ = value;
}

// optional uint32 iAngle = 5;
inline bool GPSData::has_iangle() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GPSData::set_has_iangle() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GPSData::clear_has_iangle() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GPSData::clear_iangle() {
  iangle_ = 0u;
  clear_has_iangle();
}
inline ::google::protobuf::uint32 GPSData::iangle() const {
  return iangle_;
}
inline void GPSData::set_iangle(::google::protobuf::uint32 value) {
  set_has_iangle();
  iangle_ = value;
}

// optional uint32 iSpeed = 6;
inline bool GPSData::has_ispeed() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void GPSData::set_has_ispeed() {
  _has_bits_[0] |= 0x00000020u;
}
inline void GPSData::clear_has_ispeed() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void GPSData::clear_ispeed() {
  ispeed_ = 0u;
  clear_has_ispeed();
}
inline ::google::protobuf::uint32 GPSData::ispeed() const {
  return ispeed_;
}
inline void GPSData::set_ispeed(::google::protobuf::uint32 value) {
  set_has_ispeed();
  ispeed_ = value;
}

// optional uint32 iStarCount = 7;
inline bool GPSData::has_istarcount() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void GPSData::set_has_istarcount() {
  _has_bits_[0] |= 0x00000040u;
}
inline void GPSData::clear_has_istarcount() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void GPSData::clear_istarcount() {
  istarcount_ = 0u;
  clear_has_istarcount();
}
inline ::google::protobuf::uint32 GPSData::istarcount() const {
  return istarcount_;
}
inline void GPSData::set_istarcount(::google::protobuf::uint32 value) {
  set_has_istarcount();
  istarcount_ = value;
}

// optional uint32 bAntennaState = 8;
inline bool GPSData::has_bantennastate() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void GPSData::set_has_bantennastate() {
  _has_bits_[0] |= 0x00000080u;
}
inline void GPSData::clear_has_bantennastate() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void GPSData::clear_bantennastate() {
  bantennastate_ = 0u;
  clear_has_bantennastate();
}
inline ::google::protobuf::uint32 GPSData::bantennastate() const {
  return bantennastate_;
}
inline void GPSData::set_bantennastate(::google::protobuf::uint32 value) {
  set_has_bantennastate();
  bantennastate_ = value;
}

// optional uint32 bOrientationState = 9;
inline bool GPSData::has_borientationstate() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void GPSData::set_has_borientationstate() {
  _has_bits_[0] |= 0x00000100u;
}
inline void GPSData::clear_has_borientationstate() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void GPSData::clear_borientationstate() {
  borientationstate_ = 0u;
  clear_has_borientationstate();
}
inline ::google::protobuf::uint32 GPSData::borientationstate() const {
  return borientationstate_;
}
inline void GPSData::set_borientationstate(::google::protobuf::uint32 value) {
  set_has_borientationstate();
  borientationstate_ = value;
}

// -------------------------------------------------------------------

// SnapshotParam

// optional .BVCU.PUConfig.ImageSize iImageSize = 1;
inline bool SnapshotParam::has_iimagesize() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SnapshotParam::set_has_iimagesize() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SnapshotParam::clear_has_iimagesize() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SnapshotParam::clear_iimagesize() {
  if (iimagesize_ != NULL) iimagesize_->::BVCU::PUConfig::ImageSize::Clear();
  clear_has_iimagesize();
}
inline const ::BVCU::PUConfig::ImageSize& SnapshotParam::iimagesize() const {
  return iimagesize_ != NULL ? *iimagesize_ : *default_instance_->iimagesize_;
}
inline ::BVCU::PUConfig::ImageSize* SnapshotParam::mutable_iimagesize() {
  set_has_iimagesize();
  if (iimagesize_ == NULL) iimagesize_ = new ::BVCU::PUConfig::ImageSize;
  return iimagesize_;
}
inline ::BVCU::PUConfig::ImageSize* SnapshotParam::release_iimagesize() {
  clear_has_iimagesize();
  ::BVCU::PUConfig::ImageSize* temp = iimagesize_;
  iimagesize_ = NULL;
  return temp;
}

// optional uint32 iQuality = 2;
inline bool SnapshotParam::has_iquality() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SnapshotParam::set_has_iquality() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SnapshotParam::clear_has_iquality() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SnapshotParam::clear_iquality() {
  iquality_ = 0u;
  clear_has_iquality();
}
inline ::google::protobuf::uint32 SnapshotParam::iquality() const {
  return iquality_;
}
inline void SnapshotParam::set_iquality(::google::protobuf::uint32 value) {
  set_has_iquality();
  iquality_ = value;
}

// optional uint32 iSequencePicCount = 3;
inline bool SnapshotParam::has_isequencepiccount() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SnapshotParam::set_has_isequencepiccount() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SnapshotParam::clear_has_isequencepiccount() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SnapshotParam::clear_isequencepiccount() {
  isequencepiccount_ = 0u;
  clear_has_isequencepiccount();
}
inline ::google::protobuf::uint32 SnapshotParam::isequencepiccount() const {
  return isequencepiccount_;
}
inline void SnapshotParam::set_isequencepiccount(::google::protobuf::uint32 value) {
  set_has_isequencepiccount();
  isequencepiccount_ = value;
}

// optional uint32 iSequenceInterval = 4;
inline bool SnapshotParam::has_isequenceinterval() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SnapshotParam::set_has_isequenceinterval() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SnapshotParam::clear_has_isequenceinterval() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SnapshotParam::clear_isequenceinterval() {
  isequenceinterval_ = 0u;
  clear_has_isequenceinterval();
}
inline ::google::protobuf::uint32 SnapshotParam::isequenceinterval() const {
  return isequenceinterval_;
}
inline void SnapshotParam::set_isequenceinterval(::google::protobuf::uint32 value) {
  set_has_isequenceinterval();
  isequenceinterval_ = value;
}

// optional uint32 iSequenceDelay = 5;
inline bool SnapshotParam::has_isequencedelay() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SnapshotParam::set_has_isequencedelay() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SnapshotParam::clear_has_isequencedelay() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SnapshotParam::clear_isequencedelay() {
  isequencedelay_ = 0u;
  clear_has_isequencedelay();
}
inline ::google::protobuf::uint32 SnapshotParam::isequencedelay() const {
  return isequencedelay_;
}
inline void SnapshotParam::set_isequencedelay(::google::protobuf::uint32 value) {
  set_has_isequencedelay();
  isequencedelay_ = value;
}

// optional uint32 iOverlay = 6;
inline bool SnapshotParam::has_ioverlay() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SnapshotParam::set_has_ioverlay() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SnapshotParam::clear_has_ioverlay() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SnapshotParam::clear_ioverlay() {
  ioverlay_ = 0u;
  clear_has_ioverlay();
}
inline ::google::protobuf::uint32 SnapshotParam::ioverlay() const {
  return ioverlay_;
}
inline void SnapshotParam::set_ioverlay(::google::protobuf::uint32 value) {
  set_has_ioverlay();
  ioverlay_ = value;
}

// -------------------------------------------------------------------

// AudioEncoderParam

// optional uint32 iCodecID = 1;
inline bool AudioEncoderParam::has_icodecid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AudioEncoderParam::set_has_icodecid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AudioEncoderParam::clear_has_icodecid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AudioEncoderParam::clear_icodecid() {
  icodecid_ = 0u;
  clear_has_icodecid();
}
inline ::google::protobuf::uint32 AudioEncoderParam::icodecid() const {
  return icodecid_;
}
inline void AudioEncoderParam::set_icodecid(::google::protobuf::uint32 value) {
  set_has_icodecid();
  icodecid_ = value;
}

// repeated uint32 iChannelCount = 2;
inline int AudioEncoderParam::ichannelcount_size() const {
  return ichannelcount_.size();
}
inline void AudioEncoderParam::clear_ichannelcount() {
  ichannelcount_.Clear();
}
inline ::google::protobuf::uint32 AudioEncoderParam::ichannelcount(int index) const {
  return ichannelcount_.Get(index);
}
inline void AudioEncoderParam::set_ichannelcount(int index, ::google::protobuf::uint32 value) {
  ichannelcount_.Set(index, value);
}
inline void AudioEncoderParam::add_ichannelcount(::google::protobuf::uint32 value) {
  ichannelcount_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
AudioEncoderParam::ichannelcount() const {
  return ichannelcount_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
AudioEncoderParam::mutable_ichannelcount() {
  return &ichannelcount_;
}

// repeated uint32 iBitsPerSample = 3;
inline int AudioEncoderParam::ibitspersample_size() const {
  return ibitspersample_.size();
}
inline void AudioEncoderParam::clear_ibitspersample() {
  ibitspersample_.Clear();
}
inline ::google::protobuf::uint32 AudioEncoderParam::ibitspersample(int index) const {
  return ibitspersample_.Get(index);
}
inline void AudioEncoderParam::set_ibitspersample(int index, ::google::protobuf::uint32 value) {
  ibitspersample_.Set(index, value);
}
inline void AudioEncoderParam::add_ibitspersample(::google::protobuf::uint32 value) {
  ibitspersample_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
AudioEncoderParam::ibitspersample() const {
  return ibitspersample_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
AudioEncoderParam::mutable_ibitspersample() {
  return &ibitspersample_;
}

// repeated uint32 iSamplesPerSec = 4;
inline int AudioEncoderParam::isamplespersec_size() const {
  return isamplespersec_.size();
}
inline void AudioEncoderParam::clear_isamplespersec() {
  isamplespersec_.Clear();
}
inline ::google::protobuf::uint32 AudioEncoderParam::isamplespersec(int index) const {
  return isamplespersec_.Get(index);
}
inline void AudioEncoderParam::set_isamplespersec(int index, ::google::protobuf::uint32 value) {
  isamplespersec_.Set(index, value);
}
inline void AudioEncoderParam::add_isamplespersec(::google::protobuf::uint32 value) {
  isamplespersec_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
AudioEncoderParam::isamplespersec() const {
  return isamplespersec_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
AudioEncoderParam::mutable_isamplespersec() {
  return &isamplespersec_;
}

// repeated uint32 iBitRate = 5;
inline int AudioEncoderParam::ibitrate_size() const {
  return ibitrate_.size();
}
inline void AudioEncoderParam::clear_ibitrate() {
  ibitrate_.Clear();
}
inline ::google::protobuf::uint32 AudioEncoderParam::ibitrate(int index) const {
  return ibitrate_.Get(index);
}
inline void AudioEncoderParam::set_ibitrate(int index, ::google::protobuf::uint32 value) {
  ibitrate_.Set(index, value);
}
inline void AudioEncoderParam::add_ibitrate(::google::protobuf::uint32 value) {
  ibitrate_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
AudioEncoderParam::ibitrate() const {
  return ibitrate_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
AudioEncoderParam::mutable_ibitrate() {
  return &ibitrate_;
}

// optional uint32 iChannelCountIndex = 6;
inline bool AudioEncoderParam::has_ichannelcountindex() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void AudioEncoderParam::set_has_ichannelcountindex() {
  _has_bits_[0] |= 0x00000020u;
}
inline void AudioEncoderParam::clear_has_ichannelcountindex() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void AudioEncoderParam::clear_ichannelcountindex() {
  ichannelcountindex_ = 0u;
  clear_has_ichannelcountindex();
}
inline ::google::protobuf::uint32 AudioEncoderParam::ichannelcountindex() const {
  return ichannelcountindex_;
}
inline void AudioEncoderParam::set_ichannelcountindex(::google::protobuf::uint32 value) {
  set_has_ichannelcountindex();
  ichannelcountindex_ = value;
}

// optional uint32 iBitsPerSampleIndex = 7;
inline bool AudioEncoderParam::has_ibitspersampleindex() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void AudioEncoderParam::set_has_ibitspersampleindex() {
  _has_bits_[0] |= 0x00000040u;
}
inline void AudioEncoderParam::clear_has_ibitspersampleindex() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void AudioEncoderParam::clear_ibitspersampleindex() {
  ibitspersampleindex_ = 0u;
  clear_has_ibitspersampleindex();
}
inline ::google::protobuf::uint32 AudioEncoderParam::ibitspersampleindex() const {
  return ibitspersampleindex_;
}
inline void AudioEncoderParam::set_ibitspersampleindex(::google::protobuf::uint32 value) {
  set_has_ibitspersampleindex();
  ibitspersampleindex_ = value;
}

// optional uint32 iSamplesPerSecIndex = 8;
inline bool AudioEncoderParam::has_isamplespersecindex() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void AudioEncoderParam::set_has_isamplespersecindex() {
  _has_bits_[0] |= 0x00000080u;
}
inline void AudioEncoderParam::clear_has_isamplespersecindex() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void AudioEncoderParam::clear_isamplespersecindex() {
  isamplespersecindex_ = 0u;
  clear_has_isamplespersecindex();
}
inline ::google::protobuf::uint32 AudioEncoderParam::isamplespersecindex() const {
  return isamplespersecindex_;
}
inline void AudioEncoderParam::set_isamplespersecindex(::google::protobuf::uint32 value) {
  set_has_isamplespersecindex();
  isamplespersecindex_ = value;
}

// optional uint32 iBitRateIndex = 9;
inline bool AudioEncoderParam::has_ibitrateindex() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void AudioEncoderParam::set_has_ibitrateindex() {
  _has_bits_[0] |= 0x00000100u;
}
inline void AudioEncoderParam::clear_has_ibitrateindex() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void AudioEncoderParam::clear_ibitrateindex() {
  ibitrateindex_ = 0u;
  clear_has_ibitrateindex();
}
inline ::google::protobuf::uint32 AudioEncoderParam::ibitrateindex() const {
  return ibitrateindex_;
}
inline void AudioEncoderParam::set_ibitrateindex(::google::protobuf::uint32 value) {
  set_has_ibitrateindex();
  ibitrateindex_ = value;
}

// -------------------------------------------------------------------

// EncoderParam

// optional .BVCU.PUConfig.DayTimeSlice stTime = 1;
inline bool EncoderParam::has_sttime() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EncoderParam::set_has_sttime() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EncoderParam::clear_has_sttime() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EncoderParam::clear_sttime() {
  if (sttime_ != NULL) sttime_->::BVCU::PUConfig::DayTimeSlice::Clear();
  clear_has_sttime();
}
inline const ::BVCU::PUConfig::DayTimeSlice& EncoderParam::sttime() const {
  return sttime_ != NULL ? *sttime_ : *default_instance_->sttime_;
}
inline ::BVCU::PUConfig::DayTimeSlice* EncoderParam::mutable_sttime() {
  set_has_sttime();
  if (sttime_ == NULL) sttime_ = new ::BVCU::PUConfig::DayTimeSlice;
  return sttime_;
}
inline ::BVCU::PUConfig::DayTimeSlice* EncoderParam::release_sttime() {
  clear_has_sttime();
  ::BVCU::PUConfig::DayTimeSlice* temp = sttime_;
  sttime_ = NULL;
  return temp;
}

// optional uint32 bVideoEnable = 2 [default = 1];
inline bool EncoderParam::has_bvideoenable() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EncoderParam::set_has_bvideoenable() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EncoderParam::clear_has_bvideoenable() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EncoderParam::clear_bvideoenable() {
  bvideoenable_ = 1u;
  clear_has_bvideoenable();
}
inline ::google::protobuf::uint32 EncoderParam::bvideoenable() const {
  return bvideoenable_;
}
inline void EncoderParam::set_bvideoenable(::google::protobuf::uint32 value) {
  set_has_bvideoenable();
  bvideoenable_ = value;
}

// repeated uint32 iVideoCodecAll = 3;
inline int EncoderParam::ivideocodecall_size() const {
  return ivideocodecall_.size();
}
inline void EncoderParam::clear_ivideocodecall() {
  ivideocodecall_.Clear();
}
inline ::google::protobuf::uint32 EncoderParam::ivideocodecall(int index) const {
  return ivideocodecall_.Get(index);
}
inline void EncoderParam::set_ivideocodecall(int index, ::google::protobuf::uint32 value) {
  ivideocodecall_.Set(index, value);
}
inline void EncoderParam::add_ivideocodecall(::google::protobuf::uint32 value) {
  ivideocodecall_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
EncoderParam::ivideocodecall() const {
  return ivideocodecall_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
EncoderParam::mutable_ivideocodecall() {
  return &ivideocodecall_;
}

// optional uint32 iVideoCodecIndex = 4;
inline bool EncoderParam::has_ivideocodecindex() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void EncoderParam::set_has_ivideocodecindex() {
  _has_bits_[0] |= 0x00000008u;
}
inline void EncoderParam::clear_has_ivideocodecindex() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void EncoderParam::clear_ivideocodecindex() {
  ivideocodecindex_ = 0u;
  clear_has_ivideocodecindex();
}
inline ::google::protobuf::uint32 EncoderParam::ivideocodecindex() const {
  return ivideocodecindex_;
}
inline void EncoderParam::set_ivideocodecindex(::google::protobuf::uint32 value) {
  set_has_ivideocodecindex();
  ivideocodecindex_ = value;
}

// optional uint32 iRateControl = 5;
inline bool EncoderParam::has_iratecontrol() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void EncoderParam::set_has_iratecontrol() {
  _has_bits_[0] |= 0x00000010u;
}
inline void EncoderParam::clear_has_iratecontrol() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void EncoderParam::clear_iratecontrol() {
  iratecontrol_ = 0u;
  clear_has_iratecontrol();
}
inline ::google::protobuf::uint32 EncoderParam::iratecontrol() const {
  return iratecontrol_;
}
inline void EncoderParam::set_iratecontrol(::google::protobuf::uint32 value) {
  set_has_iratecontrol();
  iratecontrol_ = value;
}

// repeated .BVCU.PUConfig.ImageRect iImageRectAll = 6;
inline int EncoderParam::iimagerectall_size() const {
  return iimagerectall_.size();
}
inline void EncoderParam::clear_iimagerectall() {
  iimagerectall_.Clear();
}
inline const ::BVCU::PUConfig::ImageRect& EncoderParam::iimagerectall(int index) const {
  return iimagerectall_.Get(index);
}
inline ::BVCU::PUConfig::ImageRect* EncoderParam::mutable_iimagerectall(int index) {
  return iimagerectall_.Mutable(index);
}
inline ::BVCU::PUConfig::ImageRect* EncoderParam::add_iimagerectall() {
  return iimagerectall_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::BVCU::PUConfig::ImageRect >&
EncoderParam::iimagerectall() const {
  return iimagerectall_;
}
inline ::google::protobuf::RepeatedPtrField< ::BVCU::PUConfig::ImageRect >*
EncoderParam::mutable_iimagerectall() {
  return &iimagerectall_;
}

// optional uint32 iImageRectIndex = 7;
inline bool EncoderParam::has_iimagerectindex() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void EncoderParam::set_has_iimagerectindex() {
  _has_bits_[0] |= 0x00000040u;
}
inline void EncoderParam::clear_has_iimagerectindex() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void EncoderParam::clear_iimagerectindex() {
  iimagerectindex_ = 0u;
  clear_has_iimagerectindex();
}
inline ::google::protobuf::uint32 EncoderParam::iimagerectindex() const {
  return iimagerectindex_;
}
inline void EncoderParam::set_iimagerectindex(::google::protobuf::uint32 value) {
  set_has_iimagerectindex();
  iimagerectindex_ = value;
}

// optional uint32 iFramesPerSec = 8 [default = 25000];
inline bool EncoderParam::has_iframespersec() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void EncoderParam::set_has_iframespersec() {
  _has_bits_[0] |= 0x00000080u;
}
inline void EncoderParam::clear_has_iframespersec() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void EncoderParam::clear_iframespersec() {
  iframespersec_ = 25000u;
  clear_has_iframespersec();
}
inline ::google::protobuf::uint32 EncoderParam::iframespersec() const {
  return iframespersec_;
}
inline void EncoderParam::set_iframespersec(::google::protobuf::uint32 value) {
  set_has_iframespersec();
  iframespersec_ = value;
}

// optional uint32 iKeyFrameInterval = 9 [default = 125];
inline bool EncoderParam::has_ikeyframeinterval() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void EncoderParam::set_has_ikeyframeinterval() {
  _has_bits_[0] |= 0x00000100u;
}
inline void EncoderParam::clear_has_ikeyframeinterval() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void EncoderParam::clear_ikeyframeinterval() {
  ikeyframeinterval_ = 125u;
  clear_has_ikeyframeinterval();
}
inline ::google::protobuf::uint32 EncoderParam::ikeyframeinterval() const {
  return ikeyframeinterval_;
}
inline void EncoderParam::set_ikeyframeinterval(::google::protobuf::uint32 value) {
  set_has_ikeyframeinterval();
  ikeyframeinterval_ = value;
}

// optional uint32 iImageQuality = 10 [default = 1];
inline bool EncoderParam::has_iimagequality() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void EncoderParam::set_has_iimagequality() {
  _has_bits_[0] |= 0x00000200u;
}
inline void EncoderParam::clear_has_iimagequality() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void EncoderParam::clear_iimagequality() {
  iimagequality_ = 1u;
  clear_has_iimagequality();
}
inline ::google::protobuf::uint32 EncoderParam::iimagequality() const {
  return iimagequality_;
}
inline void EncoderParam::set_iimagequality(::google::protobuf::uint32 value) {
  set_has_iimagequality();
  iimagequality_ = value;
}

// repeated uint32 iKbpsLimitMin = 11;
inline int EncoderParam::ikbpslimitmin_size() const {
  return ikbpslimitmin_.size();
}
inline void EncoderParam::clear_ikbpslimitmin() {
  ikbpslimitmin_.Clear();
}
inline ::google::protobuf::uint32 EncoderParam::ikbpslimitmin(int index) const {
  return ikbpslimitmin_.Get(index);
}
inline void EncoderParam::set_ikbpslimitmin(int index, ::google::protobuf::uint32 value) {
  ikbpslimitmin_.Set(index, value);
}
inline void EncoderParam::add_ikbpslimitmin(::google::protobuf::uint32 value) {
  ikbpslimitmin_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
EncoderParam::ikbpslimitmin() const {
  return ikbpslimitmin_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
EncoderParam::mutable_ikbpslimitmin() {
  return &ikbpslimitmin_;
}

// optional uint32 iKbpsLimitMax = 12;
inline bool EncoderParam::has_ikbpslimitmax() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void EncoderParam::set_has_ikbpslimitmax() {
  _has_bits_[0] |= 0x00000800u;
}
inline void EncoderParam::clear_has_ikbpslimitmax() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void EncoderParam::clear_ikbpslimitmax() {
  ikbpslimitmax_ = 0u;
  clear_has_ikbpslimitmax();
}
inline ::google::protobuf::uint32 EncoderParam::ikbpslimitmax() const {
  return ikbpslimitmax_;
}
inline void EncoderParam::set_ikbpslimitmax(::google::protobuf::uint32 value) {
  set_has_ikbpslimitmax();
  ikbpslimitmax_ = value;
}

// optional uint32 iKbpsLimitCurrent = 13;
inline bool EncoderParam::has_ikbpslimitcurrent() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void EncoderParam::set_has_ikbpslimitcurrent() {
  _has_bits_[0] |= 0x00001000u;
}
inline void EncoderParam::clear_has_ikbpslimitcurrent() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void EncoderParam::clear_ikbpslimitcurrent() {
  ikbpslimitcurrent_ = 0u;
  clear_has_ikbpslimitcurrent();
}
inline ::google::protobuf::uint32 EncoderParam::ikbpslimitcurrent() const {
  return ikbpslimitcurrent_;
}
inline void EncoderParam::set_ikbpslimitcurrent(::google::protobuf::uint32 value) {
  set_has_ikbpslimitcurrent();
  ikbpslimitcurrent_ = value;
}

// optional uint32 bAudioEnable = 14 [default = 1];
inline bool EncoderParam::has_baudioenable() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void EncoderParam::set_has_baudioenable() {
  _has_bits_[0] |= 0x00002000u;
}
inline void EncoderParam::clear_has_baudioenable() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void EncoderParam::clear_baudioenable() {
  baudioenable_ = 1u;
  clear_has_baudioenable();
}
inline ::google::protobuf::uint32 EncoderParam::baudioenable() const {
  return baudioenable_;
}
inline void EncoderParam::set_baudioenable(::google::protobuf::uint32 value) {
  set_has_baudioenable();
  baudioenable_ = value;
}

// repeated .BVCU.PUConfig.AudioEncoderParam iAudioCodecAll = 15;
inline int EncoderParam::iaudiocodecall_size() const {
  return iaudiocodecall_.size();
}
inline void EncoderParam::clear_iaudiocodecall() {
  iaudiocodecall_.Clear();
}
inline const ::BVCU::PUConfig::AudioEncoderParam& EncoderParam::iaudiocodecall(int index) const {
  return iaudiocodecall_.Get(index);
}
inline ::BVCU::PUConfig::AudioEncoderParam* EncoderParam::mutable_iaudiocodecall(int index) {
  return iaudiocodecall_.Mutable(index);
}
inline ::BVCU::PUConfig::AudioEncoderParam* EncoderParam::add_iaudiocodecall() {
  return iaudiocodecall_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::BVCU::PUConfig::AudioEncoderParam >&
EncoderParam::iaudiocodecall() const {
  return iaudiocodecall_;
}
inline ::google::protobuf::RepeatedPtrField< ::BVCU::PUConfig::AudioEncoderParam >*
EncoderParam::mutable_iaudiocodecall() {
  return &iaudiocodecall_;
}

// optional uint32 iAudioCodecIndex = 16;
inline bool EncoderParam::has_iaudiocodecindex() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void EncoderParam::set_has_iaudiocodecindex() {
  _has_bits_[0] |= 0x00008000u;
}
inline void EncoderParam::clear_has_iaudiocodecindex() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void EncoderParam::clear_iaudiocodecindex() {
  iaudiocodecindex_ = 0u;
  clear_has_iaudiocodecindex();
}
inline ::google::protobuf::uint32 EncoderParam::iaudiocodecindex() const {
  return iaudiocodecindex_;
}
inline void EncoderParam::set_iaudiocodecindex(::google::protobuf::uint32 value) {
  set_has_iaudiocodecindex();
  iaudiocodecindex_ = value;
}

// -------------------------------------------------------------------

// EncoderStreamParam

// optional uint32 bEnableTransfer = 1 [default = 1];
inline bool EncoderStreamParam::has_benabletransfer() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EncoderStreamParam::set_has_benabletransfer() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EncoderStreamParam::clear_has_benabletransfer() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EncoderStreamParam::clear_benabletransfer() {
  benabletransfer_ = 1u;
  clear_has_benabletransfer();
}
inline ::google::protobuf::uint32 EncoderStreamParam::benabletransfer() const {
  return benabletransfer_;
}
inline void EncoderStreamParam::set_benabletransfer(::google::protobuf::uint32 value) {
  set_has_benabletransfer();
  benabletransfer_ = value;
}

// optional uint32 iStreamType = 2;
inline bool EncoderStreamParam::has_istreamtype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EncoderStreamParam::set_has_istreamtype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EncoderStreamParam::clear_has_istreamtype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EncoderStreamParam::clear_istreamtype() {
  istreamtype_ = 0u;
  clear_has_istreamtype();
}
inline ::google::protobuf::uint32 EncoderStreamParam::istreamtype() const {
  return istreamtype_;
}
inline void EncoderStreamParam::set_istreamtype(::google::protobuf::uint32 value) {
  set_has_istreamtype();
  istreamtype_ = value;
}

// repeated .BVCU.PUConfig.EncoderParam pstParams = 3;
inline int EncoderStreamParam::pstparams_size() const {
  return pstparams_.size();
}
inline void EncoderStreamParam::clear_pstparams() {
  pstparams_.Clear();
}
inline const ::BVCU::PUConfig::EncoderParam& EncoderStreamParam::pstparams(int index) const {
  return pstparams_.Get(index);
}
inline ::BVCU::PUConfig::EncoderParam* EncoderStreamParam::mutable_pstparams(int index) {
  return pstparams_.Mutable(index);
}
inline ::BVCU::PUConfig::EncoderParam* EncoderStreamParam::add_pstparams() {
  return pstparams_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::BVCU::PUConfig::EncoderParam >&
EncoderStreamParam::pstparams() const {
  return pstparams_;
}
inline ::google::protobuf::RepeatedPtrField< ::BVCU::PUConfig::EncoderParam >*
EncoderStreamParam::mutable_pstparams() {
  return &pstparams_;
}

// -------------------------------------------------------------------

// EncoderChannel

// optional string szName = 1;
inline bool EncoderChannel::has_szname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EncoderChannel::set_has_szname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EncoderChannel::clear_has_szname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EncoderChannel::clear_szname() {
  if (szname_ != &::google::protobuf::internal::kEmptyString) {
    szname_->clear();
  }
  clear_has_szname();
}
inline const ::std::string& EncoderChannel::szname() const {
  return *szname_;
}
inline void EncoderChannel::set_szname(const ::std::string& value) {
  set_has_szname();
  if (szname_ == &::google::protobuf::internal::kEmptyString) {
    szname_ = new ::std::string;
  }
  szname_->assign(value);
}
inline void EncoderChannel::set_szname(const char* value) {
  set_has_szname();
  if (szname_ == &::google::protobuf::internal::kEmptyString) {
    szname_ = new ::std::string;
  }
  szname_->assign(value);
}
inline void EncoderChannel::set_szname(const char* value, size_t size) {
  set_has_szname();
  if (szname_ == &::google::protobuf::internal::kEmptyString) {
    szname_ = new ::std::string;
  }
  szname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EncoderChannel::mutable_szname() {
  set_has_szname();
  if (szname_ == &::google::protobuf::internal::kEmptyString) {
    szname_ = new ::std::string;
  }
  return szname_;
}
inline ::std::string* EncoderChannel::release_szname() {
  clear_has_szname();
  if (szname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = szname_;
    szname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated .BVCU.PUConfig.EncoderStreamParam stParam = 2;
inline int EncoderChannel::stparam_size() const {
  return stparam_.size();
}
inline void EncoderChannel::clear_stparam() {
  stparam_.Clear();
}
inline const ::BVCU::PUConfig::EncoderStreamParam& EncoderChannel::stparam(int index) const {
  return stparam_.Get(index);
}
inline ::BVCU::PUConfig::EncoderStreamParam* EncoderChannel::mutable_stparam(int index) {
  return stparam_.Mutable(index);
}
inline ::BVCU::PUConfig::EncoderStreamParam* EncoderChannel::add_stparam() {
  return stparam_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::BVCU::PUConfig::EncoderStreamParam >&
EncoderChannel::stparam() const {
  return stparam_;
}
inline ::google::protobuf::RepeatedPtrField< ::BVCU::PUConfig::EncoderStreamParam >*
EncoderChannel::mutable_stparam() {
  return &stparam_;
}

// optional int32 iVideoInIndex = 3;
inline bool EncoderChannel::has_ivideoinindex() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EncoderChannel::set_has_ivideoinindex() {
  _has_bits_[0] |= 0x00000004u;
}
inline void EncoderChannel::clear_has_ivideoinindex() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void EncoderChannel::clear_ivideoinindex() {
  ivideoinindex_ = 0;
  clear_has_ivideoinindex();
}
inline ::google::protobuf::int32 EncoderChannel::ivideoinindex() const {
  return ivideoinindex_;
}
inline void EncoderChannel::set_ivideoinindex(::google::protobuf::int32 value) {
  set_has_ivideoinindex();
  ivideoinindex_ = value;
}

// optional int32 iAudioInIndex = 4;
inline bool EncoderChannel::has_iaudioinindex() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void EncoderChannel::set_has_iaudioinindex() {
  _has_bits_[0] |= 0x00000008u;
}
inline void EncoderChannel::clear_has_iaudioinindex() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void EncoderChannel::clear_iaudioinindex() {
  iaudioinindex_ = 0;
  clear_has_iaudioinindex();
}
inline ::google::protobuf::int32 EncoderChannel::iaudioinindex() const {
  return iaudioinindex_;
}
inline void EncoderChannel::set_iaudioinindex(::google::protobuf::int32 value) {
  set_has_iaudioinindex();
  iaudioinindex_ = value;
}

// optional int32 iAudioOutIndex = 5;
inline bool EncoderChannel::has_iaudiooutindex() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void EncoderChannel::set_has_iaudiooutindex() {
  _has_bits_[0] |= 0x00000010u;
}
inline void EncoderChannel::clear_has_iaudiooutindex() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void EncoderChannel::clear_iaudiooutindex() {
  iaudiooutindex_ = 0;
  clear_has_iaudiooutindex();
}
inline ::google::protobuf::int32 EncoderChannel::iaudiooutindex() const {
  return iaudiooutindex_;
}
inline void EncoderChannel::set_iaudiooutindex(::google::protobuf::int32 value) {
  set_has_iaudiooutindex();
  iaudiooutindex_ = value;
}

// optional int32 iPTZIndex = 6;
inline bool EncoderChannel::has_iptzindex() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void EncoderChannel::set_has_iptzindex() {
  _has_bits_[0] |= 0x00000020u;
}
inline void EncoderChannel::clear_has_iptzindex() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void EncoderChannel::clear_iptzindex() {
  iptzindex_ = 0;
  clear_has_iptzindex();
}
inline ::google::protobuf::int32 EncoderChannel::iptzindex() const {
  return iptzindex_;
}
inline void EncoderChannel::set_iptzindex(::google::protobuf::int32 value) {
  set_has_iptzindex();
  iptzindex_ = value;
}

// -------------------------------------------------------------------

// RS232

// required uint32 iBaudRate = 1;
inline bool RS232::has_ibaudrate() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RS232::set_has_ibaudrate() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RS232::clear_has_ibaudrate() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RS232::clear_ibaudrate() {
  ibaudrate_ = 0u;
  clear_has_ibaudrate();
}
inline ::google::protobuf::uint32 RS232::ibaudrate() const {
  return ibaudrate_;
}
inline void RS232::set_ibaudrate(::google::protobuf::uint32 value) {
  set_has_ibaudrate();
  ibaudrate_ = value;
}

// required uint32 iDataBit = 2;
inline bool RS232::has_idatabit() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RS232::set_has_idatabit() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RS232::clear_has_idatabit() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RS232::clear_idatabit() {
  idatabit_ = 0u;
  clear_has_idatabit();
}
inline ::google::protobuf::uint32 RS232::idatabit() const {
  return idatabit_;
}
inline void RS232::set_idatabit(::google::protobuf::uint32 value) {
  set_has_idatabit();
  idatabit_ = value;
}

// required uint32 iStopBit = 3;
inline bool RS232::has_istopbit() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RS232::set_has_istopbit() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RS232::clear_has_istopbit() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RS232::clear_istopbit() {
  istopbit_ = 0u;
  clear_has_istopbit();
}
inline ::google::protobuf::uint32 RS232::istopbit() const {
  return istopbit_;
}
inline void RS232::set_istopbit(::google::protobuf::uint32 value) {
  set_has_istopbit();
  istopbit_ = value;
}

// optional uint32 iParity = 4;
inline bool RS232::has_iparity() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RS232::set_has_iparity() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RS232::clear_has_iparity() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RS232::clear_iparity() {
  iparity_ = 0u;
  clear_has_iparity();
}
inline ::google::protobuf::uint32 RS232::iparity() const {
  return iparity_;
}
inline void RS232::set_iparity(::google::protobuf::uint32 value) {
  set_has_iparity();
  iparity_ = value;
}

// optional uint32 iFlowControl = 5;
inline bool RS232::has_iflowcontrol() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RS232::set_has_iflowcontrol() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RS232::clear_has_iflowcontrol() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RS232::clear_iflowcontrol() {
  iflowcontrol_ = 0u;
  clear_has_iflowcontrol();
}
inline ::google::protobuf::uint32 RS232::iflowcontrol() const {
  return iflowcontrol_;
}
inline void RS232::set_iflowcontrol(::google::protobuf::uint32 value) {
  set_has_iflowcontrol();
  iflowcontrol_ = value;
}

// -------------------------------------------------------------------

// SerialPort

// required .BVCU.PUConfig.RS232 stRS232 = 1;
inline bool SerialPort::has_strs232() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SerialPort::set_has_strs232() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SerialPort::clear_has_strs232() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SerialPort::clear_strs232() {
  if (strs232_ != NULL) strs232_->::BVCU::PUConfig::RS232::Clear();
  clear_has_strs232();
}
inline const ::BVCU::PUConfig::RS232& SerialPort::strs232() const {
  return strs232_ != NULL ? *strs232_ : *default_instance_->strs232_;
}
inline ::BVCU::PUConfig::RS232* SerialPort::mutable_strs232() {
  set_has_strs232();
  if (strs232_ == NULL) strs232_ = new ::BVCU::PUConfig::RS232;
  return strs232_;
}
inline ::BVCU::PUConfig::RS232* SerialPort::release_strs232() {
  clear_has_strs232();
  ::BVCU::PUConfig::RS232* temp = strs232_;
  strs232_ = NULL;
  return temp;
}

// required int32 iAddress = 2;
inline bool SerialPort::has_iaddress() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SerialPort::set_has_iaddress() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SerialPort::clear_has_iaddress() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SerialPort::clear_iaddress() {
  iaddress_ = 0;
  clear_has_iaddress();
}
inline ::google::protobuf::int32 SerialPort::iaddress() const {
  return iaddress_;
}
inline void SerialPort::set_iaddress(::google::protobuf::int32 value) {
  set_has_iaddress();
  iaddress_ = value;
}

// required int32 iType = 3;
inline bool SerialPort::has_itype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SerialPort::set_has_itype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SerialPort::clear_has_itype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SerialPort::clear_itype() {
  itype_ = 0;
  clear_has_itype();
}
inline ::google::protobuf::int32 SerialPort::itype() const {
  return itype_;
}
inline void SerialPort::set_itype(::google::protobuf::int32 value) {
  set_has_itype();
  itype_ = value;
}

// -------------------------------------------------------------------

// Preset

// optional int32 iID = 1;
inline bool Preset::has_iid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Preset::set_has_iid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Preset::clear_has_iid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Preset::clear_iid() {
  iid_ = 0;
  clear_has_iid();
}
inline ::google::protobuf::int32 Preset::iid() const {
  return iid_;
}
inline void Preset::set_iid(::google::protobuf::int32 value) {
  set_has_iid();
  iid_ = value;
}

// optional string szPreset = 2;
inline bool Preset::has_szpreset() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Preset::set_has_szpreset() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Preset::clear_has_szpreset() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Preset::clear_szpreset() {
  if (szpreset_ != &::google::protobuf::internal::kEmptyString) {
    szpreset_->clear();
  }
  clear_has_szpreset();
}
inline const ::std::string& Preset::szpreset() const {
  return *szpreset_;
}
inline void Preset::set_szpreset(const ::std::string& value) {
  set_has_szpreset();
  if (szpreset_ == &::google::protobuf::internal::kEmptyString) {
    szpreset_ = new ::std::string;
  }
  szpreset_->assign(value);
}
inline void Preset::set_szpreset(const char* value) {
  set_has_szpreset();
  if (szpreset_ == &::google::protobuf::internal::kEmptyString) {
    szpreset_ = new ::std::string;
  }
  szpreset_->assign(value);
}
inline void Preset::set_szpreset(const char* value, size_t size) {
  set_has_szpreset();
  if (szpreset_ == &::google::protobuf::internal::kEmptyString) {
    szpreset_ = new ::std::string;
  }
  szpreset_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Preset::mutable_szpreset() {
  set_has_szpreset();
  if (szpreset_ == &::google::protobuf::internal::kEmptyString) {
    szpreset_ = new ::std::string;
  }
  return szpreset_;
}
inline ::std::string* Preset::release_szpreset() {
  clear_has_szpreset();
  if (szpreset_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = szpreset_;
    szpreset_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// CruisePoint

// required uint32 iPreset = 1;
inline bool CruisePoint::has_ipreset() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CruisePoint::set_has_ipreset() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CruisePoint::clear_has_ipreset() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CruisePoint::clear_ipreset() {
  ipreset_ = 0u;
  clear_has_ipreset();
}
inline ::google::protobuf::uint32 CruisePoint::ipreset() const {
  return ipreset_;
}
inline void CruisePoint::set_ipreset(::google::protobuf::uint32 value) {
  set_has_ipreset();
  ipreset_ = value;
}

// optional uint32 iSpeed = 2 [default = 5];
inline bool CruisePoint::has_ispeed() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CruisePoint::set_has_ispeed() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CruisePoint::clear_has_ispeed() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CruisePoint::clear_ispeed() {
  ispeed_ = 5u;
  clear_has_ispeed();
}
inline ::google::protobuf::uint32 CruisePoint::ispeed() const {
  return ispeed_;
}
inline void CruisePoint::set_ispeed(::google::protobuf::uint32 value) {
  set_has_ispeed();
  ispeed_ = value;
}

// optional uint32 iDuration = 3 [default = 5];
inline bool CruisePoint::has_iduration() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CruisePoint::set_has_iduration() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CruisePoint::clear_has_iduration() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CruisePoint::clear_iduration() {
  iduration_ = 5u;
  clear_has_iduration();
}
inline ::google::protobuf::uint32 CruisePoint::iduration() const {
  return iduration_;
}
inline void CruisePoint::set_iduration(::google::protobuf::uint32 value) {
  set_has_iduration();
  iduration_ = value;
}

// -------------------------------------------------------------------

// Cruise

// optional int32 iID = 1;
inline bool Cruise::has_iid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Cruise::set_has_iid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Cruise::clear_has_iid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Cruise::clear_iid() {
  iid_ = 0;
  clear_has_iid();
}
inline ::google::protobuf::int32 Cruise::iid() const {
  return iid_;
}
inline void Cruise::set_iid(::google::protobuf::int32 value) {
  set_has_iid();
  iid_ = value;
}

// optional string szName = 2;
inline bool Cruise::has_szname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Cruise::set_has_szname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Cruise::clear_has_szname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Cruise::clear_szname() {
  if (szname_ != &::google::protobuf::internal::kEmptyString) {
    szname_->clear();
  }
  clear_has_szname();
}
inline const ::std::string& Cruise::szname() const {
  return *szname_;
}
inline void Cruise::set_szname(const ::std::string& value) {
  set_has_szname();
  if (szname_ == &::google::protobuf::internal::kEmptyString) {
    szname_ = new ::std::string;
  }
  szname_->assign(value);
}
inline void Cruise::set_szname(const char* value) {
  set_has_szname();
  if (szname_ == &::google::protobuf::internal::kEmptyString) {
    szname_ = new ::std::string;
  }
  szname_->assign(value);
}
inline void Cruise::set_szname(const char* value, size_t size) {
  set_has_szname();
  if (szname_ == &::google::protobuf::internal::kEmptyString) {
    szname_ = new ::std::string;
  }
  szname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Cruise::mutable_szname() {
  set_has_szname();
  if (szname_ == &::google::protobuf::internal::kEmptyString) {
    szname_ = new ::std::string;
  }
  return szname_;
}
inline ::std::string* Cruise::release_szname() {
  clear_has_szname();
  if (szname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = szname_;
    szname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated .BVCU.PUConfig.CruisePoint stPoints = 3;
inline int Cruise::stpoints_size() const {
  return stpoints_.size();
}
inline void Cruise::clear_stpoints() {
  stpoints_.Clear();
}
inline const ::BVCU::PUConfig::CruisePoint& Cruise::stpoints(int index) const {
  return stpoints_.Get(index);
}
inline ::BVCU::PUConfig::CruisePoint* Cruise::mutable_stpoints(int index) {
  return stpoints_.Mutable(index);
}
inline ::BVCU::PUConfig::CruisePoint* Cruise::add_stpoints() {
  return stpoints_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::BVCU::PUConfig::CruisePoint >&
Cruise::stpoints() const {
  return stpoints_;
}
inline ::google::protobuf::RepeatedPtrField< ::BVCU::PUConfig::CruisePoint >*
Cruise::mutable_stpoints() {
  return &stpoints_;
}

// -------------------------------------------------------------------

// PTZControl

// required uint32 iPTZCommand = 1;
inline bool PTZControl::has_iptzcommand() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PTZControl::set_has_iptzcommand() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PTZControl::clear_has_iptzcommand() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PTZControl::clear_iptzcommand() {
  iptzcommand_ = 0u;
  clear_has_iptzcommand();
}
inline ::google::protobuf::uint32 PTZControl::iptzcommand() const {
  return iptzcommand_;
}
inline void PTZControl::set_iptzcommand(::google::protobuf::uint32 value) {
  set_has_iptzcommand();
  iptzcommand_ = value;
}

// optional uint32 bStop = 2;
inline bool PTZControl::has_bstop() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PTZControl::set_has_bstop() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PTZControl::clear_has_bstop() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PTZControl::clear_bstop() {
  bstop_ = 0u;
  clear_has_bstop();
}
inline ::google::protobuf::uint32 PTZControl::bstop() const {
  return bstop_;
}
inline void PTZControl::set_bstop(::google::protobuf::uint32 value) {
  set_has_bstop();
  bstop_ = value;
}

// optional uint32 iParam1 = 3;
inline bool PTZControl::has_iparam1() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PTZControl::set_has_iparam1() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PTZControl::clear_has_iparam1() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PTZControl::clear_iparam1() {
  iparam1_ = 0u;
  clear_has_iparam1();
}
inline ::google::protobuf::uint32 PTZControl::iparam1() const {
  return iparam1_;
}
inline void PTZControl::set_iparam1(::google::protobuf::uint32 value) {
  set_has_iparam1();
  iparam1_ = value;
}

// optional uint32 iParam2 = 4;
inline bool PTZControl::has_iparam2() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PTZControl::set_has_iparam2() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PTZControl::clear_has_iparam2() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PTZControl::clear_iparam2() {
  iparam2_ = 0u;
  clear_has_iparam2();
}
inline ::google::protobuf::uint32 PTZControl::iparam2() const {
  return iparam2_;
}
inline void PTZControl::set_iparam2(::google::protobuf::uint32 value) {
  set_has_iparam2();
  iparam2_ = value;
}

// optional uint32 iParam3 = 5;
inline bool PTZControl::has_iparam3() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PTZControl::set_has_iparam3() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PTZControl::clear_has_iparam3() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PTZControl::clear_iparam3() {
  iparam3_ = 0u;
  clear_has_iparam3();
}
inline ::google::protobuf::uint32 PTZControl::iparam3() const {
  return iparam3_;
}
inline void PTZControl::set_iparam3(::google::protobuf::uint32 value) {
  set_has_iparam3();
  iparam3_ = value;
}

// optional string szPresetName = 6;
inline bool PTZControl::has_szpresetname() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PTZControl::set_has_szpresetname() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PTZControl::clear_has_szpresetname() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PTZControl::clear_szpresetname() {
  if (szpresetname_ != &::google::protobuf::internal::kEmptyString) {
    szpresetname_->clear();
  }
  clear_has_szpresetname();
}
inline const ::std::string& PTZControl::szpresetname() const {
  return *szpresetname_;
}
inline void PTZControl::set_szpresetname(const ::std::string& value) {
  set_has_szpresetname();
  if (szpresetname_ == &::google::protobuf::internal::kEmptyString) {
    szpresetname_ = new ::std::string;
  }
  szpresetname_->assign(value);
}
inline void PTZControl::set_szpresetname(const char* value) {
  set_has_szpresetname();
  if (szpresetname_ == &::google::protobuf::internal::kEmptyString) {
    szpresetname_ = new ::std::string;
  }
  szpresetname_->assign(value);
}
inline void PTZControl::set_szpresetname(const char* value, size_t size) {
  set_has_szpresetname();
  if (szpresetname_ == &::google::protobuf::internal::kEmptyString) {
    szpresetname_ = new ::std::string;
  }
  szpresetname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PTZControl::mutable_szpresetname() {
  set_has_szpresetname();
  if (szpresetname_ == &::google::protobuf::internal::kEmptyString) {
    szpresetname_ = new ::std::string;
  }
  return szpresetname_;
}
inline ::std::string* PTZControl::release_szpresetname() {
  clear_has_szpresetname();
  if (szpresetname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = szpresetname_;
    szpresetname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional .BVCU.PUConfig.Cruise ggCruise = 7;
inline bool PTZControl::has_ggcruise() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void PTZControl::set_has_ggcruise() {
  _has_bits_[0] |= 0x00000040u;
}
inline void PTZControl::clear_has_ggcruise() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void PTZControl::clear_ggcruise() {
  if (ggcruise_ != NULL) ggcruise_->::BVCU::PUConfig::Cruise::Clear();
  clear_has_ggcruise();
}
inline const ::BVCU::PUConfig::Cruise& PTZControl::ggcruise() const {
  return ggcruise_ != NULL ? *ggcruise_ : *default_instance_->ggcruise_;
}
inline ::BVCU::PUConfig::Cruise* PTZControl::mutable_ggcruise() {
  set_has_ggcruise();
  if (ggcruise_ == NULL) ggcruise_ = new ::BVCU::PUConfig::Cruise;
  return ggcruise_;
}
inline ::BVCU::PUConfig::Cruise* PTZControl::release_ggcruise() {
  clear_has_ggcruise();
  ::BVCU::PUConfig::Cruise* temp = ggcruise_;
  ggcruise_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// PTZAttr

// repeated uint32 iPTZProtocolAll = 1;
inline int PTZAttr::iptzprotocolall_size() const {
  return iptzprotocolall_.size();
}
inline void PTZAttr::clear_iptzprotocolall() {
  iptzprotocolall_.Clear();
}
inline ::google::protobuf::uint32 PTZAttr::iptzprotocolall(int index) const {
  return iptzprotocolall_.Get(index);
}
inline void PTZAttr::set_iptzprotocolall(int index, ::google::protobuf::uint32 value) {
  iptzprotocolall_.Set(index, value);
}
inline void PTZAttr::add_iptzprotocolall(::google::protobuf::uint32 value) {
  iptzprotocolall_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
PTZAttr::iptzprotocolall() const {
  return iptzprotocolall_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
PTZAttr::mutable_iptzprotocolall() {
  return &iptzprotocolall_;
}

// required uint32 iPTZProtocolIndex = 2;
inline bool PTZAttr::has_iptzprotocolindex() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PTZAttr::set_has_iptzprotocolindex() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PTZAttr::clear_has_iptzprotocolindex() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PTZAttr::clear_iptzprotocolindex() {
  iptzprotocolindex_ = 0u;
  clear_has_iptzprotocolindex();
}
inline ::google::protobuf::uint32 PTZAttr::iptzprotocolindex() const {
  return iptzprotocolindex_;
}
inline void PTZAttr::set_iptzprotocolindex(::google::protobuf::uint32 value) {
  set_has_iptzprotocolindex();
  iptzprotocolindex_ = value;
}

// required uint32 iAddress = 3;
inline bool PTZAttr::has_iaddress() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PTZAttr::set_has_iaddress() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PTZAttr::clear_has_iaddress() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PTZAttr::clear_iaddress() {
  iaddress_ = 0u;
  clear_has_iaddress();
}
inline ::google::protobuf::uint32 PTZAttr::iaddress() const {
  return iaddress_;
}
inline void PTZAttr::set_iaddress(::google::protobuf::uint32 value) {
  set_has_iaddress();
  iaddress_ = value;
}

// optional .BVCU.PUConfig.RS232 stRS232 = 4;
inline bool PTZAttr::has_strs232() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PTZAttr::set_has_strs232() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PTZAttr::clear_has_strs232() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PTZAttr::clear_strs232() {
  if (strs232_ != NULL) strs232_->::BVCU::PUConfig::RS232::Clear();
  clear_has_strs232();
}
inline const ::BVCU::PUConfig::RS232& PTZAttr::strs232() const {
  return strs232_ != NULL ? *strs232_ : *default_instance_->strs232_;
}
inline ::BVCU::PUConfig::RS232* PTZAttr::mutable_strs232() {
  set_has_strs232();
  if (strs232_ == NULL) strs232_ = new ::BVCU::PUConfig::RS232;
  return strs232_;
}
inline ::BVCU::PUConfig::RS232* PTZAttr::release_strs232() {
  clear_has_strs232();
  ::BVCU::PUConfig::RS232* temp = strs232_;
  strs232_ = NULL;
  return temp;
}

// optional uint32 bChangePreset = 5;
inline bool PTZAttr::has_bchangepreset() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PTZAttr::set_has_bchangepreset() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PTZAttr::clear_has_bchangepreset() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PTZAttr::clear_bchangepreset() {
  bchangepreset_ = 0u;
  clear_has_bchangepreset();
}
inline ::google::protobuf::uint32 PTZAttr::bchangepreset() const {
  return bchangepreset_;
}
inline void PTZAttr::set_bchangepreset(::google::protobuf::uint32 value) {
  set_has_bchangepreset();
  bchangepreset_ = value;
}

// optional uint32 bChangeCruise = 6;
inline bool PTZAttr::has_bchangecruise() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PTZAttr::set_has_bchangecruise() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PTZAttr::clear_has_bchangecruise() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PTZAttr::clear_bchangecruise() {
  bchangecruise_ = 0u;
  clear_has_bchangecruise();
}
inline ::google::protobuf::uint32 PTZAttr::bchangecruise() const {
  return bchangecruise_;
}
inline void PTZAttr::set_bchangecruise(::google::protobuf::uint32 value) {
  set_has_bchangecruise();
  bchangecruise_ = value;
}

// repeated .BVCU.PUConfig.Preset stPreset = 7;
inline int PTZAttr::stpreset_size() const {
  return stpreset_.size();
}
inline void PTZAttr::clear_stpreset() {
  stpreset_.Clear();
}
inline const ::BVCU::PUConfig::Preset& PTZAttr::stpreset(int index) const {
  return stpreset_.Get(index);
}
inline ::BVCU::PUConfig::Preset* PTZAttr::mutable_stpreset(int index) {
  return stpreset_.Mutable(index);
}
inline ::BVCU::PUConfig::Preset* PTZAttr::add_stpreset() {
  return stpreset_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::BVCU::PUConfig::Preset >&
PTZAttr::stpreset() const {
  return stpreset_;
}
inline ::google::protobuf::RepeatedPtrField< ::BVCU::PUConfig::Preset >*
PTZAttr::mutable_stpreset() {
  return &stpreset_;
}

// repeated .BVCU.PUConfig.Cruise stCruise = 8;
inline int PTZAttr::stcruise_size() const {
  return stcruise_.size();
}
inline void PTZAttr::clear_stcruise() {
  stcruise_.Clear();
}
inline const ::BVCU::PUConfig::Cruise& PTZAttr::stcruise(int index) const {
  return stcruise_.Get(index);
}
inline ::BVCU::PUConfig::Cruise* PTZAttr::mutable_stcruise(int index) {
  return stcruise_.Mutable(index);
}
inline ::BVCU::PUConfig::Cruise* PTZAttr::add_stcruise() {
  return stcruise_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::BVCU::PUConfig::Cruise >&
PTZAttr::stcruise() const {
  return stcruise_;
}
inline ::google::protobuf::RepeatedPtrField< ::BVCU::PUConfig::Cruise >*
PTZAttr::mutable_stcruise() {
  return &stcruise_;
}

// optional int32 iActiveCruiseID = 9 [default = -1];
inline bool PTZAttr::has_iactivecruiseid() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void PTZAttr::set_has_iactivecruiseid() {
  _has_bits_[0] |= 0x00000100u;
}
inline void PTZAttr::clear_has_iactivecruiseid() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void PTZAttr::clear_iactivecruiseid() {
  iactivecruiseid_ = -1;
  clear_has_iactivecruiseid();
}
inline ::google::protobuf::int32 PTZAttr::iactivecruiseid() const {
  return iactivecruiseid_;
}
inline void PTZAttr::set_iactivecruiseid(::google::protobuf::int32 value) {
  set_has_iactivecruiseid();
  iactivecruiseid_ = value;
}

// -------------------------------------------------------------------

// Ethernet

// optional int32 bDHCP = 1;
inline bool Ethernet::has_bdhcp() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Ethernet::set_has_bdhcp() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Ethernet::clear_has_bdhcp() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Ethernet::clear_bdhcp() {
  bdhcp_ = 0;
  clear_has_bdhcp();
}
inline ::google::protobuf::int32 Ethernet::bdhcp() const {
  return bdhcp_;
}
inline void Ethernet::set_bdhcp(::google::protobuf::int32 value) {
  set_has_bdhcp();
  bdhcp_ = value;
}

// optional int32 bPPPoE = 2;
inline bool Ethernet::has_bpppoe() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Ethernet::set_has_bpppoe() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Ethernet::clear_has_bpppoe() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Ethernet::clear_bpppoe() {
  bpppoe_ = 0;
  clear_has_bpppoe();
}
inline ::google::protobuf::int32 Ethernet::bpppoe() const {
  return bpppoe_;
}
inline void Ethernet::set_bpppoe(::google::protobuf::int32 value) {
  set_has_bpppoe();
  bpppoe_ = value;
}

// optional uint32 bAutoDNS = 3;
inline bool Ethernet::has_bautodns() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Ethernet::set_has_bautodns() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Ethernet::clear_has_bautodns() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Ethernet::clear_bautodns() {
  bautodns_ = 0u;
  clear_has_bautodns();
}
inline ::google::protobuf::uint32 Ethernet::bautodns() const {
  return bautodns_;
}
inline void Ethernet::set_bautodns(::google::protobuf::uint32 value) {
  set_has_bautodns();
  bautodns_ = value;
}

// optional string szIP = 4;
inline bool Ethernet::has_szip() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Ethernet::set_has_szip() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Ethernet::clear_has_szip() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Ethernet::clear_szip() {
  if (szip_ != &::google::protobuf::internal::kEmptyString) {
    szip_->clear();
  }
  clear_has_szip();
}
inline const ::std::string& Ethernet::szip() const {
  return *szip_;
}
inline void Ethernet::set_szip(const ::std::string& value) {
  set_has_szip();
  if (szip_ == &::google::protobuf::internal::kEmptyString) {
    szip_ = new ::std::string;
  }
  szip_->assign(value);
}
inline void Ethernet::set_szip(const char* value) {
  set_has_szip();
  if (szip_ == &::google::protobuf::internal::kEmptyString) {
    szip_ = new ::std::string;
  }
  szip_->assign(value);
}
inline void Ethernet::set_szip(const char* value, size_t size) {
  set_has_szip();
  if (szip_ == &::google::protobuf::internal::kEmptyString) {
    szip_ = new ::std::string;
  }
  szip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Ethernet::mutable_szip() {
  set_has_szip();
  if (szip_ == &::google::protobuf::internal::kEmptyString) {
    szip_ = new ::std::string;
  }
  return szip_;
}
inline ::std::string* Ethernet::release_szip() {
  clear_has_szip();
  if (szip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = szip_;
    szip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string szNetMask = 5;
inline bool Ethernet::has_sznetmask() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Ethernet::set_has_sznetmask() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Ethernet::clear_has_sznetmask() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Ethernet::clear_sznetmask() {
  if (sznetmask_ != &::google::protobuf::internal::kEmptyString) {
    sznetmask_->clear();
  }
  clear_has_sznetmask();
}
inline const ::std::string& Ethernet::sznetmask() const {
  return *sznetmask_;
}
inline void Ethernet::set_sznetmask(const ::std::string& value) {
  set_has_sznetmask();
  if (sznetmask_ == &::google::protobuf::internal::kEmptyString) {
    sznetmask_ = new ::std::string;
  }
  sznetmask_->assign(value);
}
inline void Ethernet::set_sznetmask(const char* value) {
  set_has_sznetmask();
  if (sznetmask_ == &::google::protobuf::internal::kEmptyString) {
    sznetmask_ = new ::std::string;
  }
  sznetmask_->assign(value);
}
inline void Ethernet::set_sznetmask(const char* value, size_t size) {
  set_has_sznetmask();
  if (sznetmask_ == &::google::protobuf::internal::kEmptyString) {
    sznetmask_ = new ::std::string;
  }
  sznetmask_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Ethernet::mutable_sznetmask() {
  set_has_sznetmask();
  if (sznetmask_ == &::google::protobuf::internal::kEmptyString) {
    sznetmask_ = new ::std::string;
  }
  return sznetmask_;
}
inline ::std::string* Ethernet::release_sznetmask() {
  clear_has_sznetmask();
  if (sznetmask_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sznetmask_;
    sznetmask_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string szGateway = 6;
inline bool Ethernet::has_szgateway() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Ethernet::set_has_szgateway() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Ethernet::clear_has_szgateway() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Ethernet::clear_szgateway() {
  if (szgateway_ != &::google::protobuf::internal::kEmptyString) {
    szgateway_->clear();
  }
  clear_has_szgateway();
}
inline const ::std::string& Ethernet::szgateway() const {
  return *szgateway_;
}
inline void Ethernet::set_szgateway(const ::std::string& value) {
  set_has_szgateway();
  if (szgateway_ == &::google::protobuf::internal::kEmptyString) {
    szgateway_ = new ::std::string;
  }
  szgateway_->assign(value);
}
inline void Ethernet::set_szgateway(const char* value) {
  set_has_szgateway();
  if (szgateway_ == &::google::protobuf::internal::kEmptyString) {
    szgateway_ = new ::std::string;
  }
  szgateway_->assign(value);
}
inline void Ethernet::set_szgateway(const char* value, size_t size) {
  set_has_szgateway();
  if (szgateway_ == &::google::protobuf::internal::kEmptyString) {
    szgateway_ = new ::std::string;
  }
  szgateway_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Ethernet::mutable_szgateway() {
  set_has_szgateway();
  if (szgateway_ == &::google::protobuf::internal::kEmptyString) {
    szgateway_ = new ::std::string;
  }
  return szgateway_;
}
inline ::std::string* Ethernet::release_szgateway() {
  clear_has_szgateway();
  if (szgateway_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = szgateway_;
    szgateway_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated string szDNS = 7;
inline int Ethernet::szdns_size() const {
  return szdns_.size();
}
inline void Ethernet::clear_szdns() {
  szdns_.Clear();
}
inline const ::std::string& Ethernet::szdns(int index) const {
  return szdns_.Get(index);
}
inline ::std::string* Ethernet::mutable_szdns(int index) {
  return szdns_.Mutable(index);
}
inline void Ethernet::set_szdns(int index, const ::std::string& value) {
  szdns_.Mutable(index)->assign(value);
}
inline void Ethernet::set_szdns(int index, const char* value) {
  szdns_.Mutable(index)->assign(value);
}
inline void Ethernet::set_szdns(int index, const char* value, size_t size) {
  szdns_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Ethernet::add_szdns() {
  return szdns_.Add();
}
inline void Ethernet::add_szdns(const ::std::string& value) {
  szdns_.Add()->assign(value);
}
inline void Ethernet::add_szdns(const char* value) {
  szdns_.Add()->assign(value);
}
inline void Ethernet::add_szdns(const char* value, size_t size) {
  szdns_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Ethernet::szdns() const {
  return szdns_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Ethernet::mutable_szdns() {
  return &szdns_;
}

// optional string szPPPoEUserName = 8;
inline bool Ethernet::has_szpppoeusername() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Ethernet::set_has_szpppoeusername() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Ethernet::clear_has_szpppoeusername() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Ethernet::clear_szpppoeusername() {
  if (szpppoeusername_ != &::google::protobuf::internal::kEmptyString) {
    szpppoeusername_->clear();
  }
  clear_has_szpppoeusername();
}
inline const ::std::string& Ethernet::szpppoeusername() const {
  return *szpppoeusername_;
}
inline void Ethernet::set_szpppoeusername(const ::std::string& value) {
  set_has_szpppoeusername();
  if (szpppoeusername_ == &::google::protobuf::internal::kEmptyString) {
    szpppoeusername_ = new ::std::string;
  }
  szpppoeusername_->assign(value);
}
inline void Ethernet::set_szpppoeusername(const char* value) {
  set_has_szpppoeusername();
  if (szpppoeusername_ == &::google::protobuf::internal::kEmptyString) {
    szpppoeusername_ = new ::std::string;
  }
  szpppoeusername_->assign(value);
}
inline void Ethernet::set_szpppoeusername(const char* value, size_t size) {
  set_has_szpppoeusername();
  if (szpppoeusername_ == &::google::protobuf::internal::kEmptyString) {
    szpppoeusername_ = new ::std::string;
  }
  szpppoeusername_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Ethernet::mutable_szpppoeusername() {
  set_has_szpppoeusername();
  if (szpppoeusername_ == &::google::protobuf::internal::kEmptyString) {
    szpppoeusername_ = new ::std::string;
  }
  return szpppoeusername_;
}
inline ::std::string* Ethernet::release_szpppoeusername() {
  clear_has_szpppoeusername();
  if (szpppoeusername_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = szpppoeusername_;
    szpppoeusername_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string szPPPoEPassword = 9;
inline bool Ethernet::has_szpppoepassword() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Ethernet::set_has_szpppoepassword() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Ethernet::clear_has_szpppoepassword() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Ethernet::clear_szpppoepassword() {
  if (szpppoepassword_ != &::google::protobuf::internal::kEmptyString) {
    szpppoepassword_->clear();
  }
  clear_has_szpppoepassword();
}
inline const ::std::string& Ethernet::szpppoepassword() const {
  return *szpppoepassword_;
}
inline void Ethernet::set_szpppoepassword(const ::std::string& value) {
  set_has_szpppoepassword();
  if (szpppoepassword_ == &::google::protobuf::internal::kEmptyString) {
    szpppoepassword_ = new ::std::string;
  }
  szpppoepassword_->assign(value);
}
inline void Ethernet::set_szpppoepassword(const char* value) {
  set_has_szpppoepassword();
  if (szpppoepassword_ == &::google::protobuf::internal::kEmptyString) {
    szpppoepassword_ = new ::std::string;
  }
  szpppoepassword_->assign(value);
}
inline void Ethernet::set_szpppoepassword(const char* value, size_t size) {
  set_has_szpppoepassword();
  if (szpppoepassword_ == &::google::protobuf::internal::kEmptyString) {
    szpppoepassword_ = new ::std::string;
  }
  szpppoepassword_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Ethernet::mutable_szpppoepassword() {
  set_has_szpppoepassword();
  if (szpppoepassword_ == &::google::protobuf::internal::kEmptyString) {
    szpppoepassword_ = new ::std::string;
  }
  return szpppoepassword_;
}
inline ::std::string* Ethernet::release_szpppoepassword() {
  clear_has_szpppoepassword();
  if (szpppoepassword_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = szpppoepassword_;
    szpppoepassword_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// WifiHotSpot

// repeated string szProviderAll = 1;
inline int WifiHotSpot::szproviderall_size() const {
  return szproviderall_.size();
}
inline void WifiHotSpot::clear_szproviderall() {
  szproviderall_.Clear();
}
inline const ::std::string& WifiHotSpot::szproviderall(int index) const {
  return szproviderall_.Get(index);
}
inline ::std::string* WifiHotSpot::mutable_szproviderall(int index) {
  return szproviderall_.Mutable(index);
}
inline void WifiHotSpot::set_szproviderall(int index, const ::std::string& value) {
  szproviderall_.Mutable(index)->assign(value);
}
inline void WifiHotSpot::set_szproviderall(int index, const char* value) {
  szproviderall_.Mutable(index)->assign(value);
}
inline void WifiHotSpot::set_szproviderall(int index, const char* value, size_t size) {
  szproviderall_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* WifiHotSpot::add_szproviderall() {
  return szproviderall_.Add();
}
inline void WifiHotSpot::add_szproviderall(const ::std::string& value) {
  szproviderall_.Add()->assign(value);
}
inline void WifiHotSpot::add_szproviderall(const char* value) {
  szproviderall_.Add()->assign(value);
}
inline void WifiHotSpot::add_szproviderall(const char* value, size_t size) {
  szproviderall_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
WifiHotSpot::szproviderall() const {
  return szproviderall_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
WifiHotSpot::mutable_szproviderall() {
  return &szproviderall_;
}

// optional uint32 iProviderIndex = 2;
inline bool WifiHotSpot::has_iproviderindex() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void WifiHotSpot::set_has_iproviderindex() {
  _has_bits_[0] |= 0x00000002u;
}
inline void WifiHotSpot::clear_has_iproviderindex() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void WifiHotSpot::clear_iproviderindex() {
  iproviderindex_ = 0u;
  clear_has_iproviderindex();
}
inline ::google::protobuf::uint32 WifiHotSpot::iproviderindex() const {
  return iproviderindex_;
}
inline void WifiHotSpot::set_iproviderindex(::google::protobuf::uint32 value) {
  set_has_iproviderindex();
  iproviderindex_ = value;
}

// repeated string szAreaAll = 3;
inline int WifiHotSpot::szareaall_size() const {
  return szareaall_.size();
}
inline void WifiHotSpot::clear_szareaall() {
  szareaall_.Clear();
}
inline const ::std::string& WifiHotSpot::szareaall(int index) const {
  return szareaall_.Get(index);
}
inline ::std::string* WifiHotSpot::mutable_szareaall(int index) {
  return szareaall_.Mutable(index);
}
inline void WifiHotSpot::set_szareaall(int index, const ::std::string& value) {
  szareaall_.Mutable(index)->assign(value);
}
inline void WifiHotSpot::set_szareaall(int index, const char* value) {
  szareaall_.Mutable(index)->assign(value);
}
inline void WifiHotSpot::set_szareaall(int index, const char* value, size_t size) {
  szareaall_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* WifiHotSpot::add_szareaall() {
  return szareaall_.Add();
}
inline void WifiHotSpot::add_szareaall(const ::std::string& value) {
  szareaall_.Add()->assign(value);
}
inline void WifiHotSpot::add_szareaall(const char* value) {
  szareaall_.Add()->assign(value);
}
inline void WifiHotSpot::add_szareaall(const char* value, size_t size) {
  szareaall_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
WifiHotSpot::szareaall() const {
  return szareaall_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
WifiHotSpot::mutable_szareaall() {
  return &szareaall_;
}

// optional uint32 iAreaIndex = 4;
inline bool WifiHotSpot::has_iareaindex() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void WifiHotSpot::set_has_iareaindex() {
  _has_bits_[0] |= 0x00000008u;
}
inline void WifiHotSpot::clear_has_iareaindex() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void WifiHotSpot::clear_iareaindex() {
  iareaindex_ = 0u;
  clear_has_iareaindex();
}
inline ::google::protobuf::uint32 WifiHotSpot::iareaindex() const {
  return iareaindex_;
}
inline void WifiHotSpot::set_iareaindex(::google::protobuf::uint32 value) {
  set_has_iareaindex();
  iareaindex_ = value;
}

// optional string szUserName = 5;
inline bool WifiHotSpot::has_szusername() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void WifiHotSpot::set_has_szusername() {
  _has_bits_[0] |= 0x00000010u;
}
inline void WifiHotSpot::clear_has_szusername() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void WifiHotSpot::clear_szusername() {
  if (szusername_ != &::google::protobuf::internal::kEmptyString) {
    szusername_->clear();
  }
  clear_has_szusername();
}
inline const ::std::string& WifiHotSpot::szusername() const {
  return *szusername_;
}
inline void WifiHotSpot::set_szusername(const ::std::string& value) {
  set_has_szusername();
  if (szusername_ == &::google::protobuf::internal::kEmptyString) {
    szusername_ = new ::std::string;
  }
  szusername_->assign(value);
}
inline void WifiHotSpot::set_szusername(const char* value) {
  set_has_szusername();
  if (szusername_ == &::google::protobuf::internal::kEmptyString) {
    szusername_ = new ::std::string;
  }
  szusername_->assign(value);
}
inline void WifiHotSpot::set_szusername(const char* value, size_t size) {
  set_has_szusername();
  if (szusername_ == &::google::protobuf::internal::kEmptyString) {
    szusername_ = new ::std::string;
  }
  szusername_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* WifiHotSpot::mutable_szusername() {
  set_has_szusername();
  if (szusername_ == &::google::protobuf::internal::kEmptyString) {
    szusername_ = new ::std::string;
  }
  return szusername_;
}
inline ::std::string* WifiHotSpot::release_szusername() {
  clear_has_szusername();
  if (szusername_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = szusername_;
    szusername_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bytes szPassword = 6;
inline bool WifiHotSpot::has_szpassword() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void WifiHotSpot::set_has_szpassword() {
  _has_bits_[0] |= 0x00000020u;
}
inline void WifiHotSpot::clear_has_szpassword() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void WifiHotSpot::clear_szpassword() {
  if (szpassword_ != &::google::protobuf::internal::kEmptyString) {
    szpassword_->clear();
  }
  clear_has_szpassword();
}
inline const ::std::string& WifiHotSpot::szpassword() const {
  return *szpassword_;
}
inline void WifiHotSpot::set_szpassword(const ::std::string& value) {
  set_has_szpassword();
  if (szpassword_ == &::google::protobuf::internal::kEmptyString) {
    szpassword_ = new ::std::string;
  }
  szpassword_->assign(value);
}
inline void WifiHotSpot::set_szpassword(const char* value) {
  set_has_szpassword();
  if (szpassword_ == &::google::protobuf::internal::kEmptyString) {
    szpassword_ = new ::std::string;
  }
  szpassword_->assign(value);
}
inline void WifiHotSpot::set_szpassword(const void* value, size_t size) {
  set_has_szpassword();
  if (szpassword_ == &::google::protobuf::internal::kEmptyString) {
    szpassword_ = new ::std::string;
  }
  szpassword_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* WifiHotSpot::mutable_szpassword() {
  set_has_szpassword();
  if (szpassword_ == &::google::protobuf::internal::kEmptyString) {
    szpassword_ = new ::std::string;
  }
  return szpassword_;
}
inline ::std::string* WifiHotSpot::release_szpassword() {
  clear_has_szpassword();
  if (szpassword_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = szpassword_;
    szpassword_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// WifiGeneral

// optional string szSSID = 1;
inline bool WifiGeneral::has_szssid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void WifiGeneral::set_has_szssid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void WifiGeneral::clear_has_szssid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void WifiGeneral::clear_szssid() {
  if (szssid_ != &::google::protobuf::internal::kEmptyString) {
    szssid_->clear();
  }
  clear_has_szssid();
}
inline const ::std::string& WifiGeneral::szssid() const {
  return *szssid_;
}
inline void WifiGeneral::set_szssid(const ::std::string& value) {
  set_has_szssid();
  if (szssid_ == &::google::protobuf::internal::kEmptyString) {
    szssid_ = new ::std::string;
  }
  szssid_->assign(value);
}
inline void WifiGeneral::set_szssid(const char* value) {
  set_has_szssid();
  if (szssid_ == &::google::protobuf::internal::kEmptyString) {
    szssid_ = new ::std::string;
  }
  szssid_->assign(value);
}
inline void WifiGeneral::set_szssid(const char* value, size_t size) {
  set_has_szssid();
  if (szssid_ == &::google::protobuf::internal::kEmptyString) {
    szssid_ = new ::std::string;
  }
  szssid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* WifiGeneral::mutable_szssid() {
  set_has_szssid();
  if (szssid_ == &::google::protobuf::internal::kEmptyString) {
    szssid_ = new ::std::string;
  }
  return szssid_;
}
inline ::std::string* WifiGeneral::release_szssid() {
  clear_has_szssid();
  if (szssid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = szssid_;
    szssid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional uint32 iSecurityType = 2;
inline bool WifiGeneral::has_isecuritytype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void WifiGeneral::set_has_isecuritytype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void WifiGeneral::clear_has_isecuritytype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void WifiGeneral::clear_isecuritytype() {
  isecuritytype_ = 0u;
  clear_has_isecuritytype();
}
inline ::google::protobuf::uint32 WifiGeneral::isecuritytype() const {
  return isecuritytype_;
}
inline void WifiGeneral::set_isecuritytype(::google::protobuf::uint32 value) {
  set_has_isecuritytype();
  isecuritytype_ = value;
}

// optional uint32 iCryptType = 3;
inline bool WifiGeneral::has_icrypttype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void WifiGeneral::set_has_icrypttype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void WifiGeneral::clear_has_icrypttype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void WifiGeneral::clear_icrypttype() {
  icrypttype_ = 0u;
  clear_has_icrypttype();
}
inline ::google::protobuf::uint32 WifiGeneral::icrypttype() const {
  return icrypttype_;
}
inline void WifiGeneral::set_icrypttype(::google::protobuf::uint32 value) {
  set_has_icrypttype();
  icrypttype_ = value;
}

// repeated bytes szWEPKey = 4;
inline int WifiGeneral::szwepkey_size() const {
  return szwepkey_.size();
}
inline void WifiGeneral::clear_szwepkey() {
  szwepkey_.Clear();
}
inline const ::std::string& WifiGeneral::szwepkey(int index) const {
  return szwepkey_.Get(index);
}
inline ::std::string* WifiGeneral::mutable_szwepkey(int index) {
  return szwepkey_.Mutable(index);
}
inline void WifiGeneral::set_szwepkey(int index, const ::std::string& value) {
  szwepkey_.Mutable(index)->assign(value);
}
inline void WifiGeneral::set_szwepkey(int index, const char* value) {
  szwepkey_.Mutable(index)->assign(value);
}
inline void WifiGeneral::set_szwepkey(int index, const void* value, size_t size) {
  szwepkey_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* WifiGeneral::add_szwepkey() {
  return szwepkey_.Add();
}
inline void WifiGeneral::add_szwepkey(const ::std::string& value) {
  szwepkey_.Add()->assign(value);
}
inline void WifiGeneral::add_szwepkey(const char* value) {
  szwepkey_.Add()->assign(value);
}
inline void WifiGeneral::add_szwepkey(const void* value, size_t size) {
  szwepkey_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
WifiGeneral::szwepkey() const {
  return szwepkey_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
WifiGeneral::mutable_szwepkey() {
  return &szwepkey_;
}

// optional bytes szWPAKey = 5;
inline bool WifiGeneral::has_szwpakey() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void WifiGeneral::set_has_szwpakey() {
  _has_bits_[0] |= 0x00000010u;
}
inline void WifiGeneral::clear_has_szwpakey() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void WifiGeneral::clear_szwpakey() {
  if (szwpakey_ != &::google::protobuf::internal::kEmptyString) {
    szwpakey_->clear();
  }
  clear_has_szwpakey();
}
inline const ::std::string& WifiGeneral::szwpakey() const {
  return *szwpakey_;
}
inline void WifiGeneral::set_szwpakey(const ::std::string& value) {
  set_has_szwpakey();
  if (szwpakey_ == &::google::protobuf::internal::kEmptyString) {
    szwpakey_ = new ::std::string;
  }
  szwpakey_->assign(value);
}
inline void WifiGeneral::set_szwpakey(const char* value) {
  set_has_szwpakey();
  if (szwpakey_ == &::google::protobuf::internal::kEmptyString) {
    szwpakey_ = new ::std::string;
  }
  szwpakey_->assign(value);
}
inline void WifiGeneral::set_szwpakey(const void* value, size_t size) {
  set_has_szwpakey();
  if (szwpakey_ == &::google::protobuf::internal::kEmptyString) {
    szwpakey_ = new ::std::string;
  }
  szwpakey_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* WifiGeneral::mutable_szwpakey() {
  set_has_szwpakey();
  if (szwpakey_ == &::google::protobuf::internal::kEmptyString) {
    szwpakey_ = new ::std::string;
  }
  return szwpakey_;
}
inline ::std::string* WifiGeneral::release_szwpakey() {
  clear_has_szwpakey();
  if (szwpakey_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = szwpakey_;
    szwpakey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 bDHCP = 6;
inline bool WifiGeneral::has_bdhcp() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void WifiGeneral::set_has_bdhcp() {
  _has_bits_[0] |= 0x00000020u;
}
inline void WifiGeneral::clear_has_bdhcp() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void WifiGeneral::clear_bdhcp() {
  bdhcp_ = 0;
  clear_has_bdhcp();
}
inline ::google::protobuf::int32 WifiGeneral::bdhcp() const {
  return bdhcp_;
}
inline void WifiGeneral::set_bdhcp(::google::protobuf::int32 value) {
  set_has_bdhcp();
  bdhcp_ = value;
}

// optional int32 bPPPoE = 7;
inline bool WifiGeneral::has_bpppoe() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void WifiGeneral::set_has_bpppoe() {
  _has_bits_[0] |= 0x00000040u;
}
inline void WifiGeneral::clear_has_bpppoe() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void WifiGeneral::clear_bpppoe() {
  bpppoe_ = 0;
  clear_has_bpppoe();
}
inline ::google::protobuf::int32 WifiGeneral::bpppoe() const {
  return bpppoe_;
}
inline void WifiGeneral::set_bpppoe(::google::protobuf::int32 value) {
  set_has_bpppoe();
  bpppoe_ = value;
}

// optional uint32 bAutoDNS = 8;
inline bool WifiGeneral::has_bautodns() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void WifiGeneral::set_has_bautodns() {
  _has_bits_[0] |= 0x00000080u;
}
inline void WifiGeneral::clear_has_bautodns() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void WifiGeneral::clear_bautodns() {
  bautodns_ = 0u;
  clear_has_bautodns();
}
inline ::google::protobuf::uint32 WifiGeneral::bautodns() const {
  return bautodns_;
}
inline void WifiGeneral::set_bautodns(::google::protobuf::uint32 value) {
  set_has_bautodns();
  bautodns_ = value;
}

// optional string szIP = 9;
inline bool WifiGeneral::has_szip() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void WifiGeneral::set_has_szip() {
  _has_bits_[0] |= 0x00000100u;
}
inline void WifiGeneral::clear_has_szip() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void WifiGeneral::clear_szip() {
  if (szip_ != &::google::protobuf::internal::kEmptyString) {
    szip_->clear();
  }
  clear_has_szip();
}
inline const ::std::string& WifiGeneral::szip() const {
  return *szip_;
}
inline void WifiGeneral::set_szip(const ::std::string& value) {
  set_has_szip();
  if (szip_ == &::google::protobuf::internal::kEmptyString) {
    szip_ = new ::std::string;
  }
  szip_->assign(value);
}
inline void WifiGeneral::set_szip(const char* value) {
  set_has_szip();
  if (szip_ == &::google::protobuf::internal::kEmptyString) {
    szip_ = new ::std::string;
  }
  szip_->assign(value);
}
inline void WifiGeneral::set_szip(const char* value, size_t size) {
  set_has_szip();
  if (szip_ == &::google::protobuf::internal::kEmptyString) {
    szip_ = new ::std::string;
  }
  szip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* WifiGeneral::mutable_szip() {
  set_has_szip();
  if (szip_ == &::google::protobuf::internal::kEmptyString) {
    szip_ = new ::std::string;
  }
  return szip_;
}
inline ::std::string* WifiGeneral::release_szip() {
  clear_has_szip();
  if (szip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = szip_;
    szip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string szNetMask = 10;
inline bool WifiGeneral::has_sznetmask() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void WifiGeneral::set_has_sznetmask() {
  _has_bits_[0] |= 0x00000200u;
}
inline void WifiGeneral::clear_has_sznetmask() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void WifiGeneral::clear_sznetmask() {
  if (sznetmask_ != &::google::protobuf::internal::kEmptyString) {
    sznetmask_->clear();
  }
  clear_has_sznetmask();
}
inline const ::std::string& WifiGeneral::sznetmask() const {
  return *sznetmask_;
}
inline void WifiGeneral::set_sznetmask(const ::std::string& value) {
  set_has_sznetmask();
  if (sznetmask_ == &::google::protobuf::internal::kEmptyString) {
    sznetmask_ = new ::std::string;
  }
  sznetmask_->assign(value);
}
inline void WifiGeneral::set_sznetmask(const char* value) {
  set_has_sznetmask();
  if (sznetmask_ == &::google::protobuf::internal::kEmptyString) {
    sznetmask_ = new ::std::string;
  }
  sznetmask_->assign(value);
}
inline void WifiGeneral::set_sznetmask(const char* value, size_t size) {
  set_has_sznetmask();
  if (sznetmask_ == &::google::protobuf::internal::kEmptyString) {
    sznetmask_ = new ::std::string;
  }
  sznetmask_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* WifiGeneral::mutable_sznetmask() {
  set_has_sznetmask();
  if (sznetmask_ == &::google::protobuf::internal::kEmptyString) {
    sznetmask_ = new ::std::string;
  }
  return sznetmask_;
}
inline ::std::string* WifiGeneral::release_sznetmask() {
  clear_has_sznetmask();
  if (sznetmask_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sznetmask_;
    sznetmask_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string szGateway = 11;
inline bool WifiGeneral::has_szgateway() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void WifiGeneral::set_has_szgateway() {
  _has_bits_[0] |= 0x00000400u;
}
inline void WifiGeneral::clear_has_szgateway() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void WifiGeneral::clear_szgateway() {
  if (szgateway_ != &::google::protobuf::internal::kEmptyString) {
    szgateway_->clear();
  }
  clear_has_szgateway();
}
inline const ::std::string& WifiGeneral::szgateway() const {
  return *szgateway_;
}
inline void WifiGeneral::set_szgateway(const ::std::string& value) {
  set_has_szgateway();
  if (szgateway_ == &::google::protobuf::internal::kEmptyString) {
    szgateway_ = new ::std::string;
  }
  szgateway_->assign(value);
}
inline void WifiGeneral::set_szgateway(const char* value) {
  set_has_szgateway();
  if (szgateway_ == &::google::protobuf::internal::kEmptyString) {
    szgateway_ = new ::std::string;
  }
  szgateway_->assign(value);
}
inline void WifiGeneral::set_szgateway(const char* value, size_t size) {
  set_has_szgateway();
  if (szgateway_ == &::google::protobuf::internal::kEmptyString) {
    szgateway_ = new ::std::string;
  }
  szgateway_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* WifiGeneral::mutable_szgateway() {
  set_has_szgateway();
  if (szgateway_ == &::google::protobuf::internal::kEmptyString) {
    szgateway_ = new ::std::string;
  }
  return szgateway_;
}
inline ::std::string* WifiGeneral::release_szgateway() {
  clear_has_szgateway();
  if (szgateway_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = szgateway_;
    szgateway_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated string szDNS = 12;
inline int WifiGeneral::szdns_size() const {
  return szdns_.size();
}
inline void WifiGeneral::clear_szdns() {
  szdns_.Clear();
}
inline const ::std::string& WifiGeneral::szdns(int index) const {
  return szdns_.Get(index);
}
inline ::std::string* WifiGeneral::mutable_szdns(int index) {
  return szdns_.Mutable(index);
}
inline void WifiGeneral::set_szdns(int index, const ::std::string& value) {
  szdns_.Mutable(index)->assign(value);
}
inline void WifiGeneral::set_szdns(int index, const char* value) {
  szdns_.Mutable(index)->assign(value);
}
inline void WifiGeneral::set_szdns(int index, const char* value, size_t size) {
  szdns_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* WifiGeneral::add_szdns() {
  return szdns_.Add();
}
inline void WifiGeneral::add_szdns(const ::std::string& value) {
  szdns_.Add()->assign(value);
}
inline void WifiGeneral::add_szdns(const char* value) {
  szdns_.Add()->assign(value);
}
inline void WifiGeneral::add_szdns(const char* value, size_t size) {
  szdns_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
WifiGeneral::szdns() const {
  return szdns_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
WifiGeneral::mutable_szdns() {
  return &szdns_;
}

// -------------------------------------------------------------------

// Wifi

// optional uint32 bEnable = 1;
inline bool Wifi::has_benable() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Wifi::set_has_benable() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Wifi::clear_has_benable() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Wifi::clear_benable() {
  benable_ = 0u;
  clear_has_benable();
}
inline ::google::protobuf::uint32 Wifi::benable() const {
  return benable_;
}
inline void Wifi::set_benable(::google::protobuf::uint32 value) {
  set_has_benable();
  benable_ = value;
}

// optional uint32 iMode = 2;
inline bool Wifi::has_imode() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Wifi::set_has_imode() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Wifi::clear_has_imode() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Wifi::clear_imode() {
  imode_ = 0u;
  clear_has_imode();
}
inline ::google::protobuf::uint32 Wifi::imode() const {
  return imode_;
}
inline void Wifi::set_imode(::google::protobuf::uint32 value) {
  set_has_imode();
  imode_ = value;
}

// optional uint32 iSignalLevel = 3;
inline bool Wifi::has_isignallevel() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Wifi::set_has_isignallevel() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Wifi::clear_has_isignallevel() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Wifi::clear_isignallevel() {
  isignallevel_ = 0u;
  clear_has_isignallevel();
}
inline ::google::protobuf::uint32 Wifi::isignallevel() const {
  return isignallevel_;
}
inline void Wifi::set_isignallevel(::google::protobuf::uint32 value) {
  set_has_isignallevel();
  isignallevel_ = value;
}

// optional .BVCU.PUConfig.WifiGeneral stGeneral = 4;
inline bool Wifi::has_stgeneral() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Wifi::set_has_stgeneral() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Wifi::clear_has_stgeneral() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Wifi::clear_stgeneral() {
  if (stgeneral_ != NULL) stgeneral_->::BVCU::PUConfig::WifiGeneral::Clear();
  clear_has_stgeneral();
}
inline const ::BVCU::PUConfig::WifiGeneral& Wifi::stgeneral() const {
  return stgeneral_ != NULL ? *stgeneral_ : *default_instance_->stgeneral_;
}
inline ::BVCU::PUConfig::WifiGeneral* Wifi::mutable_stgeneral() {
  set_has_stgeneral();
  if (stgeneral_ == NULL) stgeneral_ = new ::BVCU::PUConfig::WifiGeneral;
  return stgeneral_;
}
inline ::BVCU::PUConfig::WifiGeneral* Wifi::release_stgeneral() {
  clear_has_stgeneral();
  ::BVCU::PUConfig::WifiGeneral* temp = stgeneral_;
  stgeneral_ = NULL;
  return temp;
}

// optional .BVCU.PUConfig.WifiHotSpot stHostSpot = 5;
inline bool Wifi::has_sthostspot() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Wifi::set_has_sthostspot() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Wifi::clear_has_sthostspot() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Wifi::clear_sthostspot() {
  if (sthostspot_ != NULL) sthostspot_->::BVCU::PUConfig::WifiHotSpot::Clear();
  clear_has_sthostspot();
}
inline const ::BVCU::PUConfig::WifiHotSpot& Wifi::sthostspot() const {
  return sthostspot_ != NULL ? *sthostspot_ : *default_instance_->sthostspot_;
}
inline ::BVCU::PUConfig::WifiHotSpot* Wifi::mutable_sthostspot() {
  set_has_sthostspot();
  if (sthostspot_ == NULL) sthostspot_ = new ::BVCU::PUConfig::WifiHotSpot;
  return sthostspot_;
}
inline ::BVCU::PUConfig::WifiHotSpot* Wifi::release_sthostspot() {
  clear_has_sthostspot();
  ::BVCU::PUConfig::WifiHotSpot* temp = sthostspot_;
  sthostspot_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// RadioNetwork

// optional uint32 bEnable = 1;
inline bool RadioNetwork::has_benable() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RadioNetwork::set_has_benable() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RadioNetwork::clear_has_benable() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RadioNetwork::clear_benable() {
  benable_ = 0u;
  clear_has_benable();
}
inline ::google::protobuf::uint32 RadioNetwork::benable() const {
  return benable_;
}
inline void RadioNetwork::set_benable(::google::protobuf::uint32 value) {
  set_has_benable();
  benable_ = value;
}

// repeated uint32 iTypeAll = 2;
inline int RadioNetwork::itypeall_size() const {
  return itypeall_.size();
}
inline void RadioNetwork::clear_itypeall() {
  itypeall_.Clear();
}
inline ::google::protobuf::uint32 RadioNetwork::itypeall(int index) const {
  return itypeall_.Get(index);
}
inline void RadioNetwork::set_itypeall(int index, ::google::protobuf::uint32 value) {
  itypeall_.Set(index, value);
}
inline void RadioNetwork::add_itypeall(::google::protobuf::uint32 value) {
  itypeall_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
RadioNetwork::itypeall() const {
  return itypeall_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
RadioNetwork::mutable_itypeall() {
  return &itypeall_;
}

// optional uint32 iTypeIndex = 3;
inline bool RadioNetwork::has_itypeindex() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RadioNetwork::set_has_itypeindex() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RadioNetwork::clear_has_itypeindex() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RadioNetwork::clear_itypeindex() {
  itypeindex_ = 0u;
  clear_has_itypeindex();
}
inline ::google::protobuf::uint32 RadioNetwork::itypeindex() const {
  return itypeindex_;
}
inline void RadioNetwork::set_itypeindex(::google::protobuf::uint32 value) {
  set_has_itypeindex();
  itypeindex_ = value;
}

// optional string szModuleName = 4;
inline bool RadioNetwork::has_szmodulename() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RadioNetwork::set_has_szmodulename() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RadioNetwork::clear_has_szmodulename() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RadioNetwork::clear_szmodulename() {
  if (szmodulename_ != &::google::protobuf::internal::kEmptyString) {
    szmodulename_->clear();
  }
  clear_has_szmodulename();
}
inline const ::std::string& RadioNetwork::szmodulename() const {
  return *szmodulename_;
}
inline void RadioNetwork::set_szmodulename(const ::std::string& value) {
  set_has_szmodulename();
  if (szmodulename_ == &::google::protobuf::internal::kEmptyString) {
    szmodulename_ = new ::std::string;
  }
  szmodulename_->assign(value);
}
inline void RadioNetwork::set_szmodulename(const char* value) {
  set_has_szmodulename();
  if (szmodulename_ == &::google::protobuf::internal::kEmptyString) {
    szmodulename_ = new ::std::string;
  }
  szmodulename_->assign(value);
}
inline void RadioNetwork::set_szmodulename(const char* value, size_t size) {
  set_has_szmodulename();
  if (szmodulename_ == &::google::protobuf::internal::kEmptyString) {
    szmodulename_ = new ::std::string;
  }
  szmodulename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RadioNetwork::mutable_szmodulename() {
  set_has_szmodulename();
  if (szmodulename_ == &::google::protobuf::internal::kEmptyString) {
    szmodulename_ = new ::std::string;
  }
  return szmodulename_;
}
inline ::std::string* RadioNetwork::release_szmodulename() {
  clear_has_szmodulename();
  if (szmodulename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = szmodulename_;
    szmodulename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string szUserName = 5;
inline bool RadioNetwork::has_szusername() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RadioNetwork::set_has_szusername() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RadioNetwork::clear_has_szusername() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RadioNetwork::clear_szusername() {
  if (szusername_ != &::google::protobuf::internal::kEmptyString) {
    szusername_->clear();
  }
  clear_has_szusername();
}
inline const ::std::string& RadioNetwork::szusername() const {
  return *szusername_;
}
inline void RadioNetwork::set_szusername(const ::std::string& value) {
  set_has_szusername();
  if (szusername_ == &::google::protobuf::internal::kEmptyString) {
    szusername_ = new ::std::string;
  }
  szusername_->assign(value);
}
inline void RadioNetwork::set_szusername(const char* value) {
  set_has_szusername();
  if (szusername_ == &::google::protobuf::internal::kEmptyString) {
    szusername_ = new ::std::string;
  }
  szusername_->assign(value);
}
inline void RadioNetwork::set_szusername(const char* value, size_t size) {
  set_has_szusername();
  if (szusername_ == &::google::protobuf::internal::kEmptyString) {
    szusername_ = new ::std::string;
  }
  szusername_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RadioNetwork::mutable_szusername() {
  set_has_szusername();
  if (szusername_ == &::google::protobuf::internal::kEmptyString) {
    szusername_ = new ::std::string;
  }
  return szusername_;
}
inline ::std::string* RadioNetwork::release_szusername() {
  clear_has_szusername();
  if (szusername_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = szusername_;
    szusername_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bytes szPassword = 6;
inline bool RadioNetwork::has_szpassword() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RadioNetwork::set_has_szpassword() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RadioNetwork::clear_has_szpassword() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RadioNetwork::clear_szpassword() {
  if (szpassword_ != &::google::protobuf::internal::kEmptyString) {
    szpassword_->clear();
  }
  clear_has_szpassword();
}
inline const ::std::string& RadioNetwork::szpassword() const {
  return *szpassword_;
}
inline void RadioNetwork::set_szpassword(const ::std::string& value) {
  set_has_szpassword();
  if (szpassword_ == &::google::protobuf::internal::kEmptyString) {
    szpassword_ = new ::std::string;
  }
  szpassword_->assign(value);
}
inline void RadioNetwork::set_szpassword(const char* value) {
  set_has_szpassword();
  if (szpassword_ == &::google::protobuf::internal::kEmptyString) {
    szpassword_ = new ::std::string;
  }
  szpassword_->assign(value);
}
inline void RadioNetwork::set_szpassword(const void* value, size_t size) {
  set_has_szpassword();
  if (szpassword_ == &::google::protobuf::internal::kEmptyString) {
    szpassword_ = new ::std::string;
  }
  szpassword_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RadioNetwork::mutable_szpassword() {
  set_has_szpassword();
  if (szpassword_ == &::google::protobuf::internal::kEmptyString) {
    szpassword_ = new ::std::string;
  }
  return szpassword_;
}
inline ::std::string* RadioNetwork::release_szpassword() {
  clear_has_szpassword();
  if (szpassword_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = szpassword_;
    szpassword_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string szAPN = 7;
inline bool RadioNetwork::has_szapn() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void RadioNetwork::set_has_szapn() {
  _has_bits_[0] |= 0x00000040u;
}
inline void RadioNetwork::clear_has_szapn() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void RadioNetwork::clear_szapn() {
  if (szapn_ != &::google::protobuf::internal::kEmptyString) {
    szapn_->clear();
  }
  clear_has_szapn();
}
inline const ::std::string& RadioNetwork::szapn() const {
  return *szapn_;
}
inline void RadioNetwork::set_szapn(const ::std::string& value) {
  set_has_szapn();
  if (szapn_ == &::google::protobuf::internal::kEmptyString) {
    szapn_ = new ::std::string;
  }
  szapn_->assign(value);
}
inline void RadioNetwork::set_szapn(const char* value) {
  set_has_szapn();
  if (szapn_ == &::google::protobuf::internal::kEmptyString) {
    szapn_ = new ::std::string;
  }
  szapn_->assign(value);
}
inline void RadioNetwork::set_szapn(const char* value, size_t size) {
  set_has_szapn();
  if (szapn_ == &::google::protobuf::internal::kEmptyString) {
    szapn_ = new ::std::string;
  }
  szapn_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RadioNetwork::mutable_szapn() {
  set_has_szapn();
  if (szapn_ == &::google::protobuf::internal::kEmptyString) {
    szapn_ = new ::std::string;
  }
  return szapn_;
}
inline ::std::string* RadioNetwork::release_szapn() {
  clear_has_szapn();
  if (szapn_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = szapn_;
    szapn_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string szAccessNum = 8;
inline bool RadioNetwork::has_szaccessnum() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void RadioNetwork::set_has_szaccessnum() {
  _has_bits_[0] |= 0x00000080u;
}
inline void RadioNetwork::clear_has_szaccessnum() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void RadioNetwork::clear_szaccessnum() {
  if (szaccessnum_ != &::google::protobuf::internal::kEmptyString) {
    szaccessnum_->clear();
  }
  clear_has_szaccessnum();
}
inline const ::std::string& RadioNetwork::szaccessnum() const {
  return *szaccessnum_;
}
inline void RadioNetwork::set_szaccessnum(const ::std::string& value) {
  set_has_szaccessnum();
  if (szaccessnum_ == &::google::protobuf::internal::kEmptyString) {
    szaccessnum_ = new ::std::string;
  }
  szaccessnum_->assign(value);
}
inline void RadioNetwork::set_szaccessnum(const char* value) {
  set_has_szaccessnum();
  if (szaccessnum_ == &::google::protobuf::internal::kEmptyString) {
    szaccessnum_ = new ::std::string;
  }
  szaccessnum_->assign(value);
}
inline void RadioNetwork::set_szaccessnum(const char* value, size_t size) {
  set_has_szaccessnum();
  if (szaccessnum_ == &::google::protobuf::internal::kEmptyString) {
    szaccessnum_ = new ::std::string;
  }
  szaccessnum_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RadioNetwork::mutable_szaccessnum() {
  set_has_szaccessnum();
  if (szaccessnum_ == &::google::protobuf::internal::kEmptyString) {
    szaccessnum_ = new ::std::string;
  }
  return szaccessnum_;
}
inline ::std::string* RadioNetwork::release_szaccessnum() {
  clear_has_szaccessnum();
  if (szaccessnum_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = szaccessnum_;
    szaccessnum_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string szCardNum = 9;
inline bool RadioNetwork::has_szcardnum() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void RadioNetwork::set_has_szcardnum() {
  _has_bits_[0] |= 0x00000100u;
}
inline void RadioNetwork::clear_has_szcardnum() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void RadioNetwork::clear_szcardnum() {
  if (szcardnum_ != &::google::protobuf::internal::kEmptyString) {
    szcardnum_->clear();
  }
  clear_has_szcardnum();
}
inline const ::std::string& RadioNetwork::szcardnum() const {
  return *szcardnum_;
}
inline void RadioNetwork::set_szcardnum(const ::std::string& value) {
  set_has_szcardnum();
  if (szcardnum_ == &::google::protobuf::internal::kEmptyString) {
    szcardnum_ = new ::std::string;
  }
  szcardnum_->assign(value);
}
inline void RadioNetwork::set_szcardnum(const char* value) {
  set_has_szcardnum();
  if (szcardnum_ == &::google::protobuf::internal::kEmptyString) {
    szcardnum_ = new ::std::string;
  }
  szcardnum_->assign(value);
}
inline void RadioNetwork::set_szcardnum(const char* value, size_t size) {
  set_has_szcardnum();
  if (szcardnum_ == &::google::protobuf::internal::kEmptyString) {
    szcardnum_ = new ::std::string;
  }
  szcardnum_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RadioNetwork::mutable_szcardnum() {
  set_has_szcardnum();
  if (szcardnum_ == &::google::protobuf::internal::kEmptyString) {
    szcardnum_ = new ::std::string;
  }
  return szcardnum_;
}
inline ::std::string* RadioNetwork::release_szcardnum() {
  clear_has_szcardnum();
  if (szcardnum_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = szcardnum_;
    szcardnum_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional uint32 bOnline = 10;
inline bool RadioNetwork::has_bonline() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void RadioNetwork::set_has_bonline() {
  _has_bits_[0] |= 0x00000200u;
}
inline void RadioNetwork::clear_has_bonline() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void RadioNetwork::clear_bonline() {
  bonline_ = 0u;
  clear_has_bonline();
}
inline ::google::protobuf::uint32 RadioNetwork::bonline() const {
  return bonline_;
}
inline void RadioNetwork::set_bonline(::google::protobuf::uint32 value) {
  set_has_bonline();
  bonline_ = value;
}

// repeated uint32 iSignalLevel = 11;
inline int RadioNetwork::isignallevel_size() const {
  return isignallevel_.size();
}
inline void RadioNetwork::clear_isignallevel() {
  isignallevel_.Clear();
}
inline ::google::protobuf::uint32 RadioNetwork::isignallevel(int index) const {
  return isignallevel_.Get(index);
}
inline void RadioNetwork::set_isignallevel(int index, ::google::protobuf::uint32 value) {
  isignallevel_.Set(index, value);
}
inline void RadioNetwork::add_isignallevel(::google::protobuf::uint32 value) {
  isignallevel_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
RadioNetwork::isignallevel() const {
  return isignallevel_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
RadioNetwork::mutable_isignallevel() {
  return &isignallevel_;
}

// optional int32 iOnlineTime = 12;
inline bool RadioNetwork::has_ionlinetime() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void RadioNetwork::set_has_ionlinetime() {
  _has_bits_[0] |= 0x00000800u;
}
inline void RadioNetwork::clear_has_ionlinetime() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void RadioNetwork::clear_ionlinetime() {
  ionlinetime_ = 0;
  clear_has_ionlinetime();
}
inline ::google::protobuf::int32 RadioNetwork::ionlinetime() const {
  return ionlinetime_;
}
inline void RadioNetwork::set_ionlinetime(::google::protobuf::int32 value) {
  set_has_ionlinetime();
  ionlinetime_ = value;
}

// optional int32 iTrafficDownload = 13;
inline bool RadioNetwork::has_itrafficdownload() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void RadioNetwork::set_has_itrafficdownload() {
  _has_bits_[0] |= 0x00001000u;
}
inline void RadioNetwork::clear_has_itrafficdownload() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void RadioNetwork::clear_itrafficdownload() {
  itrafficdownload_ = 0;
  clear_has_itrafficdownload();
}
inline ::google::protobuf::int32 RadioNetwork::itrafficdownload() const {
  return itrafficdownload_;
}
inline void RadioNetwork::set_itrafficdownload(::google::protobuf::int32 value) {
  set_has_itrafficdownload();
  itrafficdownload_ = value;
}

// optional int32 iTrafficUpload = 14;
inline bool RadioNetwork::has_itrafficupload() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void RadioNetwork::set_has_itrafficupload() {
  _has_bits_[0] |= 0x00002000u;
}
inline void RadioNetwork::clear_has_itrafficupload() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void RadioNetwork::clear_itrafficupload() {
  itrafficupload_ = 0;
  clear_has_itrafficupload();
}
inline ::google::protobuf::int32 RadioNetwork::itrafficupload() const {
  return itrafficupload_;
}
inline void RadioNetwork::set_itrafficupload(::google::protobuf::int32 value) {
  set_has_itrafficupload();
  itrafficupload_ = value;
}

// optional uint32 iSpeedDownload = 15;
inline bool RadioNetwork::has_ispeeddownload() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void RadioNetwork::set_has_ispeeddownload() {
  _has_bits_[0] |= 0x00004000u;
}
inline void RadioNetwork::clear_has_ispeeddownload() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void RadioNetwork::clear_ispeeddownload() {
  ispeeddownload_ = 0u;
  clear_has_ispeeddownload();
}
inline ::google::protobuf::uint32 RadioNetwork::ispeeddownload() const {
  return ispeeddownload_;
}
inline void RadioNetwork::set_ispeeddownload(::google::protobuf::uint32 value) {
  set_has_ispeeddownload();
  ispeeddownload_ = value;
}

// optional uint32 iSpeedUpload = 16;
inline bool RadioNetwork::has_ispeedupload() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void RadioNetwork::set_has_ispeedupload() {
  _has_bits_[0] |= 0x00008000u;
}
inline void RadioNetwork::clear_has_ispeedupload() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void RadioNetwork::clear_ispeedupload() {
  ispeedupload_ = 0u;
  clear_has_ispeedupload();
}
inline ::google::protobuf::uint32 RadioNetwork::ispeedupload() const {
  return ispeedupload_;
}
inline void RadioNetwork::set_ispeedupload(::google::protobuf::uint32 value) {
  set_has_ispeedupload();
  ispeedupload_ = value;
}

// -------------------------------------------------------------------

// RadioNetworkAll

// repeated .BVCU.PUConfig.RadioNetwork stRadioNetwork = 1;
inline int RadioNetworkAll::stradionetwork_size() const {
  return stradionetwork_.size();
}
inline void RadioNetworkAll::clear_stradionetwork() {
  stradionetwork_.Clear();
}
inline const ::BVCU::PUConfig::RadioNetwork& RadioNetworkAll::stradionetwork(int index) const {
  return stradionetwork_.Get(index);
}
inline ::BVCU::PUConfig::RadioNetwork* RadioNetworkAll::mutable_stradionetwork(int index) {
  return stradionetwork_.Mutable(index);
}
inline ::BVCU::PUConfig::RadioNetwork* RadioNetworkAll::add_stradionetwork() {
  return stradionetwork_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::BVCU::PUConfig::RadioNetwork >&
RadioNetworkAll::stradionetwork() const {
  return stradionetwork_;
}
inline ::google::protobuf::RepeatedPtrField< ::BVCU::PUConfig::RadioNetwork >*
RadioNetworkAll::mutable_stradionetwork() {
  return &stradionetwork_;
}

// -------------------------------------------------------------------

// RegisterServer

// optional string szAddr = 1;
inline bool RegisterServer::has_szaddr() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RegisterServer::set_has_szaddr() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RegisterServer::clear_has_szaddr() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RegisterServer::clear_szaddr() {
  if (szaddr_ != &::google::protobuf::internal::kEmptyString) {
    szaddr_->clear();
  }
  clear_has_szaddr();
}
inline const ::std::string& RegisterServer::szaddr() const {
  return *szaddr_;
}
inline void RegisterServer::set_szaddr(const ::std::string& value) {
  set_has_szaddr();
  if (szaddr_ == &::google::protobuf::internal::kEmptyString) {
    szaddr_ = new ::std::string;
  }
  szaddr_->assign(value);
}
inline void RegisterServer::set_szaddr(const char* value) {
  set_has_szaddr();
  if (szaddr_ == &::google::protobuf::internal::kEmptyString) {
    szaddr_ = new ::std::string;
  }
  szaddr_->assign(value);
}
inline void RegisterServer::set_szaddr(const char* value, size_t size) {
  set_has_szaddr();
  if (szaddr_ == &::google::protobuf::internal::kEmptyString) {
    szaddr_ = new ::std::string;
  }
  szaddr_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RegisterServer::mutable_szaddr() {
  set_has_szaddr();
  if (szaddr_ == &::google::protobuf::internal::kEmptyString) {
    szaddr_ = new ::std::string;
  }
  return szaddr_;
}
inline ::std::string* RegisterServer::release_szaddr() {
  clear_has_szaddr();
  if (szaddr_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = szaddr_;
    szaddr_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional uint32 iPort = 2;
inline bool RegisterServer::has_iport() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RegisterServer::set_has_iport() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RegisterServer::clear_has_iport() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RegisterServer::clear_iport() {
  iport_ = 0u;
  clear_has_iport();
}
inline ::google::protobuf::uint32 RegisterServer::iport() const {
  return iport_;
}
inline void RegisterServer::set_iport(::google::protobuf::uint32 value) {
  set_has_iport();
  iport_ = value;
}

// optional uint32 iProto = 3;
inline bool RegisterServer::has_iproto() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RegisterServer::set_has_iproto() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RegisterServer::clear_has_iproto() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RegisterServer::clear_iproto() {
  iproto_ = 0u;
  clear_has_iproto();
}
inline ::google::protobuf::uint32 RegisterServer::iproto() const {
  return iproto_;
}
inline void RegisterServer::set_iproto(::google::protobuf::uint32 value) {
  set_has_iproto();
  iproto_ = value;
}

// -------------------------------------------------------------------

// UpdateServer

// optional string szAddr = 1;
inline bool UpdateServer::has_szaddr() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UpdateServer::set_has_szaddr() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UpdateServer::clear_has_szaddr() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UpdateServer::clear_szaddr() {
  if (szaddr_ != &::google::protobuf::internal::kEmptyString) {
    szaddr_->clear();
  }
  clear_has_szaddr();
}
inline const ::std::string& UpdateServer::szaddr() const {
  return *szaddr_;
}
inline void UpdateServer::set_szaddr(const ::std::string& value) {
  set_has_szaddr();
  if (szaddr_ == &::google::protobuf::internal::kEmptyString) {
    szaddr_ = new ::std::string;
  }
  szaddr_->assign(value);
}
inline void UpdateServer::set_szaddr(const char* value) {
  set_has_szaddr();
  if (szaddr_ == &::google::protobuf::internal::kEmptyString) {
    szaddr_ = new ::std::string;
  }
  szaddr_->assign(value);
}
inline void UpdateServer::set_szaddr(const char* value, size_t size) {
  set_has_szaddr();
  if (szaddr_ == &::google::protobuf::internal::kEmptyString) {
    szaddr_ = new ::std::string;
  }
  szaddr_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UpdateServer::mutable_szaddr() {
  set_has_szaddr();
  if (szaddr_ == &::google::protobuf::internal::kEmptyString) {
    szaddr_ = new ::std::string;
  }
  return szaddr_;
}
inline ::std::string* UpdateServer::release_szaddr() {
  clear_has_szaddr();
  if (szaddr_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = szaddr_;
    szaddr_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional uint32 iPort = 2;
inline bool UpdateServer::has_iport() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UpdateServer::set_has_iport() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UpdateServer::clear_has_iport() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UpdateServer::clear_iport() {
  iport_ = 0u;
  clear_has_iport();
}
inline ::google::protobuf::uint32 UpdateServer::iport() const {
  return iport_;
}
inline void UpdateServer::set_iport(::google::protobuf::uint32 value) {
  set_has_iport();
  iport_ = value;
}

// optional string szUserName = 3;
inline bool UpdateServer::has_szusername() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UpdateServer::set_has_szusername() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UpdateServer::clear_has_szusername() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UpdateServer::clear_szusername() {
  if (szusername_ != &::google::protobuf::internal::kEmptyString) {
    szusername_->clear();
  }
  clear_has_szusername();
}
inline const ::std::string& UpdateServer::szusername() const {
  return *szusername_;
}
inline void UpdateServer::set_szusername(const ::std::string& value) {
  set_has_szusername();
  if (szusername_ == &::google::protobuf::internal::kEmptyString) {
    szusername_ = new ::std::string;
  }
  szusername_->assign(value);
}
inline void UpdateServer::set_szusername(const char* value) {
  set_has_szusername();
  if (szusername_ == &::google::protobuf::internal::kEmptyString) {
    szusername_ = new ::std::string;
  }
  szusername_->assign(value);
}
inline void UpdateServer::set_szusername(const char* value, size_t size) {
  set_has_szusername();
  if (szusername_ == &::google::protobuf::internal::kEmptyString) {
    szusername_ = new ::std::string;
  }
  szusername_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UpdateServer::mutable_szusername() {
  set_has_szusername();
  if (szusername_ == &::google::protobuf::internal::kEmptyString) {
    szusername_ = new ::std::string;
  }
  return szusername_;
}
inline ::std::string* UpdateServer::release_szusername() {
  clear_has_szusername();
  if (szusername_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = szusername_;
    szusername_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bytes szPassword = 4;
inline bool UpdateServer::has_szpassword() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UpdateServer::set_has_szpassword() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UpdateServer::clear_has_szpassword() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UpdateServer::clear_szpassword() {
  if (szpassword_ != &::google::protobuf::internal::kEmptyString) {
    szpassword_->clear();
  }
  clear_has_szpassword();
}
inline const ::std::string& UpdateServer::szpassword() const {
  return *szpassword_;
}
inline void UpdateServer::set_szpassword(const ::std::string& value) {
  set_has_szpassword();
  if (szpassword_ == &::google::protobuf::internal::kEmptyString) {
    szpassword_ = new ::std::string;
  }
  szpassword_->assign(value);
}
inline void UpdateServer::set_szpassword(const char* value) {
  set_has_szpassword();
  if (szpassword_ == &::google::protobuf::internal::kEmptyString) {
    szpassword_ = new ::std::string;
  }
  szpassword_->assign(value);
}
inline void UpdateServer::set_szpassword(const void* value, size_t size) {
  set_has_szpassword();
  if (szpassword_ == &::google::protobuf::internal::kEmptyString) {
    szpassword_ = new ::std::string;
  }
  szpassword_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UpdateServer::mutable_szpassword() {
  set_has_szpassword();
  if (szpassword_ == &::google::protobuf::internal::kEmptyString) {
    szpassword_ = new ::std::string;
  }
  return szpassword_;
}
inline ::std::string* UpdateServer::release_szpassword() {
  clear_has_szpassword();
  if (szpassword_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = szpassword_;
    szpassword_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional uint32 iProto = 5;
inline bool UpdateServer::has_iproto() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UpdateServer::set_has_iproto() {
  _has_bits_[0] |= 0x00000010u;
}
inline void UpdateServer::clear_has_iproto() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void UpdateServer::clear_iproto() {
  iproto_ = 0u;
  clear_has_iproto();
}
inline ::google::protobuf::uint32 UpdateServer::iproto() const {
  return iproto_;
}
inline void UpdateServer::set_iproto(::google::protobuf::uint32 value) {
  set_has_iproto();
  iproto_ = value;
}

// optional string szPath = 6;
inline bool UpdateServer::has_szpath() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void UpdateServer::set_has_szpath() {
  _has_bits_[0] |= 0x00000020u;
}
inline void UpdateServer::clear_has_szpath() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void UpdateServer::clear_szpath() {
  if (szpath_ != &::google::protobuf::internal::kEmptyString) {
    szpath_->clear();
  }
  clear_has_szpath();
}
inline const ::std::string& UpdateServer::szpath() const {
  return *szpath_;
}
inline void UpdateServer::set_szpath(const ::std::string& value) {
  set_has_szpath();
  if (szpath_ == &::google::protobuf::internal::kEmptyString) {
    szpath_ = new ::std::string;
  }
  szpath_->assign(value);
}
inline void UpdateServer::set_szpath(const char* value) {
  set_has_szpath();
  if (szpath_ == &::google::protobuf::internal::kEmptyString) {
    szpath_ = new ::std::string;
  }
  szpath_->assign(value);
}
inline void UpdateServer::set_szpath(const char* value, size_t size) {
  set_has_szpath();
  if (szpath_ == &::google::protobuf::internal::kEmptyString) {
    szpath_ = new ::std::string;
  }
  szpath_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UpdateServer::mutable_szpath() {
  set_has_szpath();
  if (szpath_ == &::google::protobuf::internal::kEmptyString) {
    szpath_ = new ::std::string;
  }
  return szpath_;
}
inline ::std::string* UpdateServer::release_szpath() {
  clear_has_szpath();
  if (szpath_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = szpath_;
    szpath_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// EmailServer

// optional string szServerAddr = 1;
inline bool EmailServer::has_szserveraddr() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EmailServer::set_has_szserveraddr() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EmailServer::clear_has_szserveraddr() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EmailServer::clear_szserveraddr() {
  if (szserveraddr_ != &::google::protobuf::internal::kEmptyString) {
    szserveraddr_->clear();
  }
  clear_has_szserveraddr();
}
inline const ::std::string& EmailServer::szserveraddr() const {
  return *szserveraddr_;
}
inline void EmailServer::set_szserveraddr(const ::std::string& value) {
  set_has_szserveraddr();
  if (szserveraddr_ == &::google::protobuf::internal::kEmptyString) {
    szserveraddr_ = new ::std::string;
  }
  szserveraddr_->assign(value);
}
inline void EmailServer::set_szserveraddr(const char* value) {
  set_has_szserveraddr();
  if (szserveraddr_ == &::google::protobuf::internal::kEmptyString) {
    szserveraddr_ = new ::std::string;
  }
  szserveraddr_->assign(value);
}
inline void EmailServer::set_szserveraddr(const char* value, size_t size) {
  set_has_szserveraddr();
  if (szserveraddr_ == &::google::protobuf::internal::kEmptyString) {
    szserveraddr_ = new ::std::string;
  }
  szserveraddr_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EmailServer::mutable_szserveraddr() {
  set_has_szserveraddr();
  if (szserveraddr_ == &::google::protobuf::internal::kEmptyString) {
    szserveraddr_ = new ::std::string;
  }
  return szserveraddr_;
}
inline ::std::string* EmailServer::release_szserveraddr() {
  clear_has_szserveraddr();
  if (szserveraddr_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = szserveraddr_;
    szserveraddr_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional uint32 iServerPort = 2;
inline bool EmailServer::has_iserverport() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EmailServer::set_has_iserverport() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EmailServer::clear_has_iserverport() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EmailServer::clear_iserverport() {
  iserverport_ = 0u;
  clear_has_iserverport();
}
inline ::google::protobuf::uint32 EmailServer::iserverport() const {
  return iserverport_;
}
inline void EmailServer::set_iserverport(::google::protobuf::uint32 value) {
  set_has_iserverport();
  iserverport_ = value;
}

// optional string szUserName = 3;
inline bool EmailServer::has_szusername() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EmailServer::set_has_szusername() {
  _has_bits_[0] |= 0x00000004u;
}
inline void EmailServer::clear_has_szusername() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void EmailServer::clear_szusername() {
  if (szusername_ != &::google::protobuf::internal::kEmptyString) {
    szusername_->clear();
  }
  clear_has_szusername();
}
inline const ::std::string& EmailServer::szusername() const {
  return *szusername_;
}
inline void EmailServer::set_szusername(const ::std::string& value) {
  set_has_szusername();
  if (szusername_ == &::google::protobuf::internal::kEmptyString) {
    szusername_ = new ::std::string;
  }
  szusername_->assign(value);
}
inline void EmailServer::set_szusername(const char* value) {
  set_has_szusername();
  if (szusername_ == &::google::protobuf::internal::kEmptyString) {
    szusername_ = new ::std::string;
  }
  szusername_->assign(value);
}
inline void EmailServer::set_szusername(const char* value, size_t size) {
  set_has_szusername();
  if (szusername_ == &::google::protobuf::internal::kEmptyString) {
    szusername_ = new ::std::string;
  }
  szusername_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EmailServer::mutable_szusername() {
  set_has_szusername();
  if (szusername_ == &::google::protobuf::internal::kEmptyString) {
    szusername_ = new ::std::string;
  }
  return szusername_;
}
inline ::std::string* EmailServer::release_szusername() {
  clear_has_szusername();
  if (szusername_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = szusername_;
    szusername_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string szPassword = 4;
inline bool EmailServer::has_szpassword() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void EmailServer::set_has_szpassword() {
  _has_bits_[0] |= 0x00000008u;
}
inline void EmailServer::clear_has_szpassword() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void EmailServer::clear_szpassword() {
  if (szpassword_ != &::google::protobuf::internal::kEmptyString) {
    szpassword_->clear();
  }
  clear_has_szpassword();
}
inline const ::std::string& EmailServer::szpassword() const {
  return *szpassword_;
}
inline void EmailServer::set_szpassword(const ::std::string& value) {
  set_has_szpassword();
  if (szpassword_ == &::google::protobuf::internal::kEmptyString) {
    szpassword_ = new ::std::string;
  }
  szpassword_->assign(value);
}
inline void EmailServer::set_szpassword(const char* value) {
  set_has_szpassword();
  if (szpassword_ == &::google::protobuf::internal::kEmptyString) {
    szpassword_ = new ::std::string;
  }
  szpassword_->assign(value);
}
inline void EmailServer::set_szpassword(const char* value, size_t size) {
  set_has_szpassword();
  if (szpassword_ == &::google::protobuf::internal::kEmptyString) {
    szpassword_ = new ::std::string;
  }
  szpassword_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EmailServer::mutable_szpassword() {
  set_has_szpassword();
  if (szpassword_ == &::google::protobuf::internal::kEmptyString) {
    szpassword_ = new ::std::string;
  }
  return szpassword_;
}
inline ::std::string* EmailServer::release_szpassword() {
  clear_has_szpassword();
  if (szpassword_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = szpassword_;
    szpassword_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string szSenderAddr = 5;
inline bool EmailServer::has_szsenderaddr() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void EmailServer::set_has_szsenderaddr() {
  _has_bits_[0] |= 0x00000010u;
}
inline void EmailServer::clear_has_szsenderaddr() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void EmailServer::clear_szsenderaddr() {
  if (szsenderaddr_ != &::google::protobuf::internal::kEmptyString) {
    szsenderaddr_->clear();
  }
  clear_has_szsenderaddr();
}
inline const ::std::string& EmailServer::szsenderaddr() const {
  return *szsenderaddr_;
}
inline void EmailServer::set_szsenderaddr(const ::std::string& value) {
  set_has_szsenderaddr();
  if (szsenderaddr_ == &::google::protobuf::internal::kEmptyString) {
    szsenderaddr_ = new ::std::string;
  }
  szsenderaddr_->assign(value);
}
inline void EmailServer::set_szsenderaddr(const char* value) {
  set_has_szsenderaddr();
  if (szsenderaddr_ == &::google::protobuf::internal::kEmptyString) {
    szsenderaddr_ = new ::std::string;
  }
  szsenderaddr_->assign(value);
}
inline void EmailServer::set_szsenderaddr(const char* value, size_t size) {
  set_has_szsenderaddr();
  if (szsenderaddr_ == &::google::protobuf::internal::kEmptyString) {
    szsenderaddr_ = new ::std::string;
  }
  szsenderaddr_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EmailServer::mutable_szsenderaddr() {
  set_has_szsenderaddr();
  if (szsenderaddr_ == &::google::protobuf::internal::kEmptyString) {
    szsenderaddr_ = new ::std::string;
  }
  return szsenderaddr_;
}
inline ::std::string* EmailServer::release_szsenderaddr() {
  clear_has_szsenderaddr();
  if (szsenderaddr_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = szsenderaddr_;
    szsenderaddr_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional uint32 bSSLEnable = 6;
inline bool EmailServer::has_bsslenable() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void EmailServer::set_has_bsslenable() {
  _has_bits_[0] |= 0x00000020u;
}
inline void EmailServer::clear_has_bsslenable() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void EmailServer::clear_bsslenable() {
  bsslenable_ = 0u;
  clear_has_bsslenable();
}
inline ::google::protobuf::uint32 EmailServer::bsslenable() const {
  return bsslenable_;
}
inline void EmailServer::set_bsslenable(::google::protobuf::uint32 value) {
  set_has_bsslenable();
  bsslenable_ = value;
}

// -------------------------------------------------------------------

// NTPServer

// repeated string szAddr = 1;
inline int NTPServer::szaddr_size() const {
  return szaddr_.size();
}
inline void NTPServer::clear_szaddr() {
  szaddr_.Clear();
}
inline const ::std::string& NTPServer::szaddr(int index) const {
  return szaddr_.Get(index);
}
inline ::std::string* NTPServer::mutable_szaddr(int index) {
  return szaddr_.Mutable(index);
}
inline void NTPServer::set_szaddr(int index, const ::std::string& value) {
  szaddr_.Mutable(index)->assign(value);
}
inline void NTPServer::set_szaddr(int index, const char* value) {
  szaddr_.Mutable(index)->assign(value);
}
inline void NTPServer::set_szaddr(int index, const char* value, size_t size) {
  szaddr_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NTPServer::add_szaddr() {
  return szaddr_.Add();
}
inline void NTPServer::add_szaddr(const ::std::string& value) {
  szaddr_.Add()->assign(value);
}
inline void NTPServer::add_szaddr(const char* value) {
  szaddr_.Add()->assign(value);
}
inline void NTPServer::add_szaddr(const char* value, size_t size) {
  szaddr_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
NTPServer::szaddr() const {
  return szaddr_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
NTPServer::mutable_szaddr() {
  return &szaddr_;
}

// repeated uint32 iPort = 2;
inline int NTPServer::iport_size() const {
  return iport_.size();
}
inline void NTPServer::clear_iport() {
  iport_.Clear();
}
inline ::google::protobuf::uint32 NTPServer::iport(int index) const {
  return iport_.Get(index);
}
inline void NTPServer::set_iport(int index, ::google::protobuf::uint32 value) {
  iport_.Set(index, value);
}
inline void NTPServer::add_iport(::google::protobuf::uint32 value) {
  iport_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
NTPServer::iport() const {
  return iport_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
NTPServer::mutable_iport() {
  return &iport_;
}

// optional uint32 iUpdateInterval = 3;
inline bool NTPServer::has_iupdateinterval() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void NTPServer::set_has_iupdateinterval() {
  _has_bits_[0] |= 0x00000004u;
}
inline void NTPServer::clear_has_iupdateinterval() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void NTPServer::clear_iupdateinterval() {
  iupdateinterval_ = 0u;
  clear_has_iupdateinterval();
}
inline ::google::protobuf::uint32 NTPServer::iupdateinterval() const {
  return iupdateinterval_;
}
inline void NTPServer::set_iupdateinterval(::google::protobuf::uint32 value) {
  set_has_iupdateinterval();
  iupdateinterval_ = value;
}

// optional uint32 bUpdateImmediately = 4;
inline bool NTPServer::has_bupdateimmediately() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void NTPServer::set_has_bupdateimmediately() {
  _has_bits_[0] |= 0x00000008u;
}
inline void NTPServer::clear_has_bupdateimmediately() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void NTPServer::clear_bupdateimmediately() {
  bupdateimmediately_ = 0u;
  clear_has_bupdateimmediately();
}
inline ::google::protobuf::uint32 NTPServer::bupdateimmediately() const {
  return bupdateimmediately_;
}
inline void NTPServer::set_bupdateimmediately(::google::protobuf::uint32 value) {
  set_has_bupdateimmediately();
  bupdateimmediately_ = value;
}

// -------------------------------------------------------------------

// TimeSource

// optional uint32 iTimeZone = 1;
inline bool TimeSource::has_itimezone() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TimeSource::set_has_itimezone() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TimeSource::clear_has_itimezone() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TimeSource::clear_itimezone() {
  itimezone_ = 0u;
  clear_has_itimezone();
}
inline ::google::protobuf::uint32 TimeSource::itimezone() const {
  return itimezone_;
}
inline void TimeSource::set_itimezone(::google::protobuf::uint32 value) {
  set_has_itimezone();
  itimezone_ = value;
}

// optional uint32 bDST = 2;
inline bool TimeSource::has_bdst() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TimeSource::set_has_bdst() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TimeSource::clear_has_bdst() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TimeSource::clear_bdst() {
  bdst_ = 0u;
  clear_has_bdst();
}
inline ::google::protobuf::uint32 TimeSource::bdst() const {
  return bdst_;
}
inline void TimeSource::set_bdst(::google::protobuf::uint32 value) {
  set_has_bdst();
  bdst_ = value;
}

// optional .BVCU.PUConfig.NTPServer stNTPServer = 3;
inline bool TimeSource::has_stntpserver() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TimeSource::set_has_stntpserver() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TimeSource::clear_has_stntpserver() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TimeSource::clear_stntpserver() {
  if (stntpserver_ != NULL) stntpserver_->::BVCU::PUConfig::NTPServer::Clear();
  clear_has_stntpserver();
}
inline const ::BVCU::PUConfig::NTPServer& TimeSource::stntpserver() const {
  return stntpserver_ != NULL ? *stntpserver_ : *default_instance_->stntpserver_;
}
inline ::BVCU::PUConfig::NTPServer* TimeSource::mutable_stntpserver() {
  set_has_stntpserver();
  if (stntpserver_ == NULL) stntpserver_ = new ::BVCU::PUConfig::NTPServer;
  return stntpserver_;
}
inline ::BVCU::PUConfig::NTPServer* TimeSource::release_stntpserver() {
  clear_has_stntpserver();
  ::BVCU::PUConfig::NTPServer* temp = stntpserver_;
  stntpserver_ = NULL;
  return temp;
}

// optional uint32 iNTP = 4;
inline bool TimeSource::has_intp() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TimeSource::set_has_intp() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TimeSource::clear_has_intp() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TimeSource::clear_intp() {
  intp_ = 0u;
  clear_has_intp();
}
inline ::google::protobuf::uint32 TimeSource::intp() const {
  return intp_;
}
inline void TimeSource::set_intp(::google::protobuf::uint32 value) {
  set_has_intp();
  intp_ = value;
}

// optional uint32 iGPS = 5;
inline bool TimeSource::has_igps() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TimeSource::set_has_igps() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TimeSource::clear_has_igps() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TimeSource::clear_igps() {
  igps_ = 0u;
  clear_has_igps();
}
inline ::google::protobuf::uint32 TimeSource::igps() const {
  return igps_;
}
inline void TimeSource::set_igps(::google::protobuf::uint32 value) {
  set_has_igps();
  igps_ = value;
}

// -------------------------------------------------------------------

// DDNS

// optional int32 bDDNS = 1;
inline bool DDNS::has_bddns() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DDNS::set_has_bddns() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DDNS::clear_has_bddns() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DDNS::clear_bddns() {
  bddns_ = 0;
  clear_has_bddns();
}
inline ::google::protobuf::int32 DDNS::bddns() const {
  return bddns_;
}
inline void DDNS::set_bddns(::google::protobuf::int32 value) {
  set_has_bddns();
  bddns_ = value;
}

// optional string szDDNSProvider = 2;
inline bool DDNS::has_szddnsprovider() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DDNS::set_has_szddnsprovider() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DDNS::clear_has_szddnsprovider() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DDNS::clear_szddnsprovider() {
  if (szddnsprovider_ != &::google::protobuf::internal::kEmptyString) {
    szddnsprovider_->clear();
  }
  clear_has_szddnsprovider();
}
inline const ::std::string& DDNS::szddnsprovider() const {
  return *szddnsprovider_;
}
inline void DDNS::set_szddnsprovider(const ::std::string& value) {
  set_has_szddnsprovider();
  if (szddnsprovider_ == &::google::protobuf::internal::kEmptyString) {
    szddnsprovider_ = new ::std::string;
  }
  szddnsprovider_->assign(value);
}
inline void DDNS::set_szddnsprovider(const char* value) {
  set_has_szddnsprovider();
  if (szddnsprovider_ == &::google::protobuf::internal::kEmptyString) {
    szddnsprovider_ = new ::std::string;
  }
  szddnsprovider_->assign(value);
}
inline void DDNS::set_szddnsprovider(const char* value, size_t size) {
  set_has_szddnsprovider();
  if (szddnsprovider_ == &::google::protobuf::internal::kEmptyString) {
    szddnsprovider_ = new ::std::string;
  }
  szddnsprovider_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DDNS::mutable_szddnsprovider() {
  set_has_szddnsprovider();
  if (szddnsprovider_ == &::google::protobuf::internal::kEmptyString) {
    szddnsprovider_ = new ::std::string;
  }
  return szddnsprovider_;
}
inline ::std::string* DDNS::release_szddnsprovider() {
  clear_has_szddnsprovider();
  if (szddnsprovider_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = szddnsprovider_;
    szddnsprovider_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string szDDNSAddr = 3;
inline bool DDNS::has_szddnsaddr() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DDNS::set_has_szddnsaddr() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DDNS::clear_has_szddnsaddr() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DDNS::clear_szddnsaddr() {
  if (szddnsaddr_ != &::google::protobuf::internal::kEmptyString) {
    szddnsaddr_->clear();
  }
  clear_has_szddnsaddr();
}
inline const ::std::string& DDNS::szddnsaddr() const {
  return *szddnsaddr_;
}
inline void DDNS::set_szddnsaddr(const ::std::string& value) {
  set_has_szddnsaddr();
  if (szddnsaddr_ == &::google::protobuf::internal::kEmptyString) {
    szddnsaddr_ = new ::std::string;
  }
  szddnsaddr_->assign(value);
}
inline void DDNS::set_szddnsaddr(const char* value) {
  set_has_szddnsaddr();
  if (szddnsaddr_ == &::google::protobuf::internal::kEmptyString) {
    szddnsaddr_ = new ::std::string;
  }
  szddnsaddr_->assign(value);
}
inline void DDNS::set_szddnsaddr(const char* value, size_t size) {
  set_has_szddnsaddr();
  if (szddnsaddr_ == &::google::protobuf::internal::kEmptyString) {
    szddnsaddr_ = new ::std::string;
  }
  szddnsaddr_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DDNS::mutable_szddnsaddr() {
  set_has_szddnsaddr();
  if (szddnsaddr_ == &::google::protobuf::internal::kEmptyString) {
    szddnsaddr_ = new ::std::string;
  }
  return szddnsaddr_;
}
inline ::std::string* DDNS::release_szddnsaddr() {
  clear_has_szddnsaddr();
  if (szddnsaddr_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = szddnsaddr_;
    szddnsaddr_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string szDDNSUserName = 4;
inline bool DDNS::has_szddnsusername() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DDNS::set_has_szddnsusername() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DDNS::clear_has_szddnsusername() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DDNS::clear_szddnsusername() {
  if (szddnsusername_ != &::google::protobuf::internal::kEmptyString) {
    szddnsusername_->clear();
  }
  clear_has_szddnsusername();
}
inline const ::std::string& DDNS::szddnsusername() const {
  return *szddnsusername_;
}
inline void DDNS::set_szddnsusername(const ::std::string& value) {
  set_has_szddnsusername();
  if (szddnsusername_ == &::google::protobuf::internal::kEmptyString) {
    szddnsusername_ = new ::std::string;
  }
  szddnsusername_->assign(value);
}
inline void DDNS::set_szddnsusername(const char* value) {
  set_has_szddnsusername();
  if (szddnsusername_ == &::google::protobuf::internal::kEmptyString) {
    szddnsusername_ = new ::std::string;
  }
  szddnsusername_->assign(value);
}
inline void DDNS::set_szddnsusername(const char* value, size_t size) {
  set_has_szddnsusername();
  if (szddnsusername_ == &::google::protobuf::internal::kEmptyString) {
    szddnsusername_ = new ::std::string;
  }
  szddnsusername_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DDNS::mutable_szddnsusername() {
  set_has_szddnsusername();
  if (szddnsusername_ == &::google::protobuf::internal::kEmptyString) {
    szddnsusername_ = new ::std::string;
  }
  return szddnsusername_;
}
inline ::std::string* DDNS::release_szddnsusername() {
  clear_has_szddnsusername();
  if (szddnsusername_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = szddnsusername_;
    szddnsusername_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bytes szDDNSPassword = 5;
inline bool DDNS::has_szddnspassword() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DDNS::set_has_szddnspassword() {
  _has_bits_[0] |= 0x00000010u;
}
inline void DDNS::clear_has_szddnspassword() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void DDNS::clear_szddnspassword() {
  if (szddnspassword_ != &::google::protobuf::internal::kEmptyString) {
    szddnspassword_->clear();
  }
  clear_has_szddnspassword();
}
inline const ::std::string& DDNS::szddnspassword() const {
  return *szddnspassword_;
}
inline void DDNS::set_szddnspassword(const ::std::string& value) {
  set_has_szddnspassword();
  if (szddnspassword_ == &::google::protobuf::internal::kEmptyString) {
    szddnspassword_ = new ::std::string;
  }
  szddnspassword_->assign(value);
}
inline void DDNS::set_szddnspassword(const char* value) {
  set_has_szddnspassword();
  if (szddnspassword_ == &::google::protobuf::internal::kEmptyString) {
    szddnspassword_ = new ::std::string;
  }
  szddnspassword_->assign(value);
}
inline void DDNS::set_szddnspassword(const void* value, size_t size) {
  set_has_szddnspassword();
  if (szddnspassword_ == &::google::protobuf::internal::kEmptyString) {
    szddnspassword_ = new ::std::string;
  }
  szddnspassword_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DDNS::mutable_szddnspassword() {
  set_has_szddnspassword();
  if (szddnspassword_ == &::google::protobuf::internal::kEmptyString) {
    szddnspassword_ = new ::std::string;
  }
  return szddnspassword_;
}
inline ::std::string* DDNS::release_szddnspassword() {
  clear_has_szddnspassword();
  if (szddnspassword_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = szddnspassword_;
    szddnspassword_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string szDynamicName = 6;
inline bool DDNS::has_szdynamicname() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void DDNS::set_has_szdynamicname() {
  _has_bits_[0] |= 0x00000020u;
}
inline void DDNS::clear_has_szdynamicname() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void DDNS::clear_szdynamicname() {
  if (szdynamicname_ != &::google::protobuf::internal::kEmptyString) {
    szdynamicname_->clear();
  }
  clear_has_szdynamicname();
}
inline const ::std::string& DDNS::szdynamicname() const {
  return *szdynamicname_;
}
inline void DDNS::set_szdynamicname(const ::std::string& value) {
  set_has_szdynamicname();
  if (szdynamicname_ == &::google::protobuf::internal::kEmptyString) {
    szdynamicname_ = new ::std::string;
  }
  szdynamicname_->assign(value);
}
inline void DDNS::set_szdynamicname(const char* value) {
  set_has_szdynamicname();
  if (szdynamicname_ == &::google::protobuf::internal::kEmptyString) {
    szdynamicname_ = new ::std::string;
  }
  szdynamicname_->assign(value);
}
inline void DDNS::set_szdynamicname(const char* value, size_t size) {
  set_has_szdynamicname();
  if (szdynamicname_ == &::google::protobuf::internal::kEmptyString) {
    szdynamicname_ = new ::std::string;
  }
  szdynamicname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DDNS::mutable_szdynamicname() {
  set_has_szdynamicname();
  if (szdynamicname_ == &::google::protobuf::internal::kEmptyString) {
    szdynamicname_ = new ::std::string;
  }
  return szdynamicname_;
}
inline ::std::string* DDNS::release_szdynamicname() {
  clear_has_szdynamicname();
  if (szdynamicname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = szdynamicname_;
    szdynamicname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// Servers

// optional .BVCU.PUConfig.RegisterServer stRegisterServer = 1;
inline bool Servers::has_stregisterserver() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Servers::set_has_stregisterserver() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Servers::clear_has_stregisterserver() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Servers::clear_stregisterserver() {
  if (stregisterserver_ != NULL) stregisterserver_->::BVCU::PUConfig::RegisterServer::Clear();
  clear_has_stregisterserver();
}
inline const ::BVCU::PUConfig::RegisterServer& Servers::stregisterserver() const {
  return stregisterserver_ != NULL ? *stregisterserver_ : *default_instance_->stregisterserver_;
}
inline ::BVCU::PUConfig::RegisterServer* Servers::mutable_stregisterserver() {
  set_has_stregisterserver();
  if (stregisterserver_ == NULL) stregisterserver_ = new ::BVCU::PUConfig::RegisterServer;
  return stregisterserver_;
}
inline ::BVCU::PUConfig::RegisterServer* Servers::release_stregisterserver() {
  clear_has_stregisterserver();
  ::BVCU::PUConfig::RegisterServer* temp = stregisterserver_;
  stregisterserver_ = NULL;
  return temp;
}

// optional .BVCU.PUConfig.UpdateServer stUpdateServer = 2;
inline bool Servers::has_stupdateserver() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Servers::set_has_stupdateserver() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Servers::clear_has_stupdateserver() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Servers::clear_stupdateserver() {
  if (stupdateserver_ != NULL) stupdateserver_->::BVCU::PUConfig::UpdateServer::Clear();
  clear_has_stupdateserver();
}
inline const ::BVCU::PUConfig::UpdateServer& Servers::stupdateserver() const {
  return stupdateserver_ != NULL ? *stupdateserver_ : *default_instance_->stupdateserver_;
}
inline ::BVCU::PUConfig::UpdateServer* Servers::mutable_stupdateserver() {
  set_has_stupdateserver();
  if (stupdateserver_ == NULL) stupdateserver_ = new ::BVCU::PUConfig::UpdateServer;
  return stupdateserver_;
}
inline ::BVCU::PUConfig::UpdateServer* Servers::release_stupdateserver() {
  clear_has_stupdateserver();
  ::BVCU::PUConfig::UpdateServer* temp = stupdateserver_;
  stupdateserver_ = NULL;
  return temp;
}

// optional .BVCU.PUConfig.TimeSource stTimeSource = 3;
inline bool Servers::has_sttimesource() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Servers::set_has_sttimesource() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Servers::clear_has_sttimesource() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Servers::clear_sttimesource() {
  if (sttimesource_ != NULL) sttimesource_->::BVCU::PUConfig::TimeSource::Clear();
  clear_has_sttimesource();
}
inline const ::BVCU::PUConfig::TimeSource& Servers::sttimesource() const {
  return sttimesource_ != NULL ? *sttimesource_ : *default_instance_->sttimesource_;
}
inline ::BVCU::PUConfig::TimeSource* Servers::mutable_sttimesource() {
  set_has_sttimesource();
  if (sttimesource_ == NULL) sttimesource_ = new ::BVCU::PUConfig::TimeSource;
  return sttimesource_;
}
inline ::BVCU::PUConfig::TimeSource* Servers::release_sttimesource() {
  clear_has_sttimesource();
  ::BVCU::PUConfig::TimeSource* temp = sttimesource_;
  sttimesource_ = NULL;
  return temp;
}

// optional .BVCU.PUConfig.DDNS stDDNS = 4;
inline bool Servers::has_stddns() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Servers::set_has_stddns() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Servers::clear_has_stddns() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Servers::clear_stddns() {
  if (stddns_ != NULL) stddns_->::BVCU::PUConfig::DDNS::Clear();
  clear_has_stddns();
}
inline const ::BVCU::PUConfig::DDNS& Servers::stddns() const {
  return stddns_ != NULL ? *stddns_ : *default_instance_->stddns_;
}
inline ::BVCU::PUConfig::DDNS* Servers::mutable_stddns() {
  set_has_stddns();
  if (stddns_ == NULL) stddns_ = new ::BVCU::PUConfig::DDNS;
  return stddns_;
}
inline ::BVCU::PUConfig::DDNS* Servers::release_stddns() {
  clear_has_stddns();
  ::BVCU::PUConfig::DDNS* temp = stddns_;
  stddns_ = NULL;
  return temp;
}

// optional .BVCU.PUConfig.EmailServer stEmailServer = 5;
inline bool Servers::has_stemailserver() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Servers::set_has_stemailserver() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Servers::clear_has_stemailserver() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Servers::clear_stemailserver() {
  if (stemailserver_ != NULL) stemailserver_->::BVCU::PUConfig::EmailServer::Clear();
  clear_has_stemailserver();
}
inline const ::BVCU::PUConfig::EmailServer& Servers::stemailserver() const {
  return stemailserver_ != NULL ? *stemailserver_ : *default_instance_->stemailserver_;
}
inline ::BVCU::PUConfig::EmailServer* Servers::mutable_stemailserver() {
  set_has_stemailserver();
  if (stemailserver_ == NULL) stemailserver_ = new ::BVCU::PUConfig::EmailServer;
  return stemailserver_;
}
inline ::BVCU::PUConfig::EmailServer* Servers::release_stemailserver() {
  clear_has_stemailserver();
  ::BVCU::PUConfig::EmailServer* temp = stemailserver_;
  stemailserver_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// Storage_Schedule

// optional uint32 iChannelIndex = 1;
inline bool Storage_Schedule::has_ichannelindex() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Storage_Schedule::set_has_ichannelindex() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Storage_Schedule::clear_has_ichannelindex() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Storage_Schedule::clear_ichannelindex() {
  ichannelindex_ = 0u;
  clear_has_ichannelindex();
}
inline ::google::protobuf::uint32 Storage_Schedule::ichannelindex() const {
  return ichannelindex_;
}
inline void Storage_Schedule::set_ichannelindex(::google::protobuf::uint32 value) {
  set_has_ichannelindex();
  ichannelindex_ = value;
}

// optional .BVCU.PUConfig.WeekTimeSlice stWeekSnapshot = 2;
inline bool Storage_Schedule::has_stweeksnapshot() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Storage_Schedule::set_has_stweeksnapshot() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Storage_Schedule::clear_has_stweeksnapshot() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Storage_Schedule::clear_stweeksnapshot() {
  if (stweeksnapshot_ != NULL) stweeksnapshot_->::BVCU::PUConfig::WeekTimeSlice::Clear();
  clear_has_stweeksnapshot();
}
inline const ::BVCU::PUConfig::WeekTimeSlice& Storage_Schedule::stweeksnapshot() const {
  return stweeksnapshot_ != NULL ? *stweeksnapshot_ : *default_instance_->stweeksnapshot_;
}
inline ::BVCU::PUConfig::WeekTimeSlice* Storage_Schedule::mutable_stweeksnapshot() {
  set_has_stweeksnapshot();
  if (stweeksnapshot_ == NULL) stweeksnapshot_ = new ::BVCU::PUConfig::WeekTimeSlice;
  return stweeksnapshot_;
}
inline ::BVCU::PUConfig::WeekTimeSlice* Storage_Schedule::release_stweeksnapshot() {
  clear_has_stweeksnapshot();
  ::BVCU::PUConfig::WeekTimeSlice* temp = stweeksnapshot_;
  stweeksnapshot_ = NULL;
  return temp;
}

// optional .BVCU.PUConfig.WeekTimeSlice stWeekRecord = 3;
inline bool Storage_Schedule::has_stweekrecord() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Storage_Schedule::set_has_stweekrecord() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Storage_Schedule::clear_has_stweekrecord() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Storage_Schedule::clear_stweekrecord() {
  if (stweekrecord_ != NULL) stweekrecord_->::BVCU::PUConfig::WeekTimeSlice::Clear();
  clear_has_stweekrecord();
}
inline const ::BVCU::PUConfig::WeekTimeSlice& Storage_Schedule::stweekrecord() const {
  return stweekrecord_ != NULL ? *stweekrecord_ : *default_instance_->stweekrecord_;
}
inline ::BVCU::PUConfig::WeekTimeSlice* Storage_Schedule::mutable_stweekrecord() {
  set_has_stweekrecord();
  if (stweekrecord_ == NULL) stweekrecord_ = new ::BVCU::PUConfig::WeekTimeSlice;
  return stweekrecord_;
}
inline ::BVCU::PUConfig::WeekTimeSlice* Storage_Schedule::release_stweekrecord() {
  clear_has_stweekrecord();
  ::BVCU::PUConfig::WeekTimeSlice* temp = stweekrecord_;
  stweekrecord_ = NULL;
  return temp;
}

// optional uint32 bRecordAudio = 4;
inline bool Storage_Schedule::has_brecordaudio() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Storage_Schedule::set_has_brecordaudio() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Storage_Schedule::clear_has_brecordaudio() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Storage_Schedule::clear_brecordaudio() {
  brecordaudio_ = 0u;
  clear_has_brecordaudio();
}
inline ::google::protobuf::uint32 Storage_Schedule::brecordaudio() const {
  return brecordaudio_;
}
inline void Storage_Schedule::set_brecordaudio(::google::protobuf::uint32 value) {
  set_has_brecordaudio();
  brecordaudio_ = value;
}

// optional .BVCU.PUConfig.WallTime stBegin = 5;
inline bool Storage_Schedule::has_stbegin() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Storage_Schedule::set_has_stbegin() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Storage_Schedule::clear_has_stbegin() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Storage_Schedule::clear_stbegin() {
  if (stbegin_ != NULL) stbegin_->::BVCU::PUConfig::WallTime::Clear();
  clear_has_stbegin();
}
inline const ::BVCU::PUConfig::WallTime& Storage_Schedule::stbegin() const {
  return stbegin_ != NULL ? *stbegin_ : *default_instance_->stbegin_;
}
inline ::BVCU::PUConfig::WallTime* Storage_Schedule::mutable_stbegin() {
  set_has_stbegin();
  if (stbegin_ == NULL) stbegin_ = new ::BVCU::PUConfig::WallTime;
  return stbegin_;
}
inline ::BVCU::PUConfig::WallTime* Storage_Schedule::release_stbegin() {
  clear_has_stbegin();
  ::BVCU::PUConfig::WallTime* temp = stbegin_;
  stbegin_ = NULL;
  return temp;
}

// optional .BVCU.PUConfig.WallTime stEnd = 6;
inline bool Storage_Schedule::has_stend() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Storage_Schedule::set_has_stend() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Storage_Schedule::clear_has_stend() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Storage_Schedule::clear_stend() {
  if (stend_ != NULL) stend_->::BVCU::PUConfig::WallTime::Clear();
  clear_has_stend();
}
inline const ::BVCU::PUConfig::WallTime& Storage_Schedule::stend() const {
  return stend_ != NULL ? *stend_ : *default_instance_->stend_;
}
inline ::BVCU::PUConfig::WallTime* Storage_Schedule::mutable_stend() {
  set_has_stend();
  if (stend_ == NULL) stend_ = new ::BVCU::PUConfig::WallTime;
  return stend_;
}
inline ::BVCU::PUConfig::WallTime* Storage_Schedule::release_stend() {
  clear_has_stend();
  ::BVCU::PUConfig::WallTime* temp = stend_;
  stend_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// Storage_Media

// optional string szMediaName = 7;
inline bool Storage_Media::has_szmedianame() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Storage_Media::set_has_szmedianame() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Storage_Media::clear_has_szmedianame() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Storage_Media::clear_szmedianame() {
  if (szmedianame_ != &::google::protobuf::internal::kEmptyString) {
    szmedianame_->clear();
  }
  clear_has_szmedianame();
}
inline const ::std::string& Storage_Media::szmedianame() const {
  return *szmedianame_;
}
inline void Storage_Media::set_szmedianame(const ::std::string& value) {
  set_has_szmedianame();
  if (szmedianame_ == &::google::protobuf::internal::kEmptyString) {
    szmedianame_ = new ::std::string;
  }
  szmedianame_->assign(value);
}
inline void Storage_Media::set_szmedianame(const char* value) {
  set_has_szmedianame();
  if (szmedianame_ == &::google::protobuf::internal::kEmptyString) {
    szmedianame_ = new ::std::string;
  }
  szmedianame_->assign(value);
}
inline void Storage_Media::set_szmedianame(const char* value, size_t size) {
  set_has_szmedianame();
  if (szmedianame_ == &::google::protobuf::internal::kEmptyString) {
    szmedianame_ = new ::std::string;
  }
  szmedianame_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Storage_Media::mutable_szmedianame() {
  set_has_szmedianame();
  if (szmedianame_ == &::google::protobuf::internal::kEmptyString) {
    szmedianame_ = new ::std::string;
  }
  return szmedianame_;
}
inline ::std::string* Storage_Media::release_szmedianame() {
  clear_has_szmedianame();
  if (szmedianame_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = szmedianame_;
    szmedianame_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional uint32 iStorageMediaType = 1;
inline bool Storage_Media::has_istoragemediatype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Storage_Media::set_has_istoragemediatype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Storage_Media::clear_has_istoragemediatype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Storage_Media::clear_istoragemediatype() {
  istoragemediatype_ = 0u;
  clear_has_istoragemediatype();
}
inline ::google::protobuf::uint32 Storage_Media::istoragemediatype() const {
  return istoragemediatype_;
}
inline void Storage_Media::set_istoragemediatype(::google::protobuf::uint32 value) {
  set_has_istoragemediatype();
  istoragemediatype_ = value;
}

// optional uint32 iTotalSpace = 2;
inline bool Storage_Media::has_itotalspace() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Storage_Media::set_has_itotalspace() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Storage_Media::clear_has_itotalspace() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Storage_Media::clear_itotalspace() {
  itotalspace_ = 0u;
  clear_has_itotalspace();
}
inline ::google::protobuf::uint32 Storage_Media::itotalspace() const {
  return itotalspace_;
}
inline void Storage_Media::set_itotalspace(::google::protobuf::uint32 value) {
  set_has_itotalspace();
  itotalspace_ = value;
}

// optional uint32 iFreeSpace = 3;
inline bool Storage_Media::has_ifreespace() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Storage_Media::set_has_ifreespace() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Storage_Media::clear_has_ifreespace() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Storage_Media::clear_ifreespace() {
  ifreespace_ = 0u;
  clear_has_ifreespace();
}
inline ::google::protobuf::uint32 Storage_Media::ifreespace() const {
  return ifreespace_;
}
inline void Storage_Media::set_ifreespace(::google::protobuf::uint32 value) {
  set_has_ifreespace();
  ifreespace_ = value;
}

// optional uint32 bFormated = 4;
inline bool Storage_Media::has_bformated() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Storage_Media::set_has_bformated() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Storage_Media::clear_has_bformated() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Storage_Media::clear_bformated() {
  bformated_ = 0u;
  clear_has_bformated();
}
inline ::google::protobuf::uint32 Storage_Media::bformated() const {
  return bformated_;
}
inline void Storage_Media::set_bformated(::google::protobuf::uint32 value) {
  set_has_bformated();
  bformated_ = value;
}

// -------------------------------------------------------------------

// Storage_Rule

// optional uint32 iNoSpaceRule = 1;
inline bool Storage_Rule::has_inospacerule() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Storage_Rule::set_has_inospacerule() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Storage_Rule::clear_has_inospacerule() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Storage_Rule::clear_inospacerule() {
  inospacerule_ = 0u;
  clear_has_inospacerule();
}
inline ::google::protobuf::uint32 Storage_Rule::inospacerule() const {
  return inospacerule_;
}
inline void Storage_Rule::set_inospacerule(::google::protobuf::uint32 value) {
  set_has_inospacerule();
  inospacerule_ = value;
}

// optional uint32 iAlarmSpace = 2;
inline bool Storage_Rule::has_ialarmspace() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Storage_Rule::set_has_ialarmspace() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Storage_Rule::clear_has_ialarmspace() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Storage_Rule::clear_ialarmspace() {
  ialarmspace_ = 0u;
  clear_has_ialarmspace();
}
inline ::google::protobuf::uint32 Storage_Rule::ialarmspace() const {
  return ialarmspace_;
}
inline void Storage_Rule::set_ialarmspace(::google::protobuf::uint32 value) {
  set_has_ialarmspace();
  ialarmspace_ = value;
}

// optional uint32 iReserveDays = 3;
inline bool Storage_Rule::has_ireservedays() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Storage_Rule::set_has_ireservedays() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Storage_Rule::clear_has_ireservedays() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Storage_Rule::clear_ireservedays() {
  ireservedays_ = 0u;
  clear_has_ireservedays();
}
inline ::google::protobuf::uint32 Storage_Rule::ireservedays() const {
  return ireservedays_;
}
inline void Storage_Rule::set_ireservedays(::google::protobuf::uint32 value) {
  set_has_ireservedays();
  ireservedays_ = value;
}

// optional uint32 iRecordFileLength = 4;
inline bool Storage_Rule::has_irecordfilelength() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Storage_Rule::set_has_irecordfilelength() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Storage_Rule::clear_has_irecordfilelength() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Storage_Rule::clear_irecordfilelength() {
  irecordfilelength_ = 0u;
  clear_has_irecordfilelength();
}
inline ::google::protobuf::uint32 Storage_Rule::irecordfilelength() const {
  return irecordfilelength_;
}
inline void Storage_Rule::set_irecordfilelength(::google::protobuf::uint32 value) {
  set_has_irecordfilelength();
  irecordfilelength_ = value;
}

// optional uint32 bRecordGPS = 5;
inline bool Storage_Rule::has_brecordgps() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Storage_Rule::set_has_brecordgps() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Storage_Rule::clear_has_brecordgps() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Storage_Rule::clear_brecordgps() {
  brecordgps_ = 0u;
  clear_has_brecordgps();
}
inline ::google::protobuf::uint32 Storage_Rule::brecordgps() const {
  return brecordgps_;
}
inline void Storage_Rule::set_brecordgps(::google::protobuf::uint32 value) {
  set_has_brecordgps();
  brecordgps_ = value;
}

// -------------------------------------------------------------------

// Storage_Format

// optional uint32 iAction = 1;
inline bool Storage_Format::has_iaction() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Storage_Format::set_has_iaction() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Storage_Format::clear_has_iaction() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Storage_Format::clear_iaction() {
  iaction_ = 0u;
  clear_has_iaction();
}
inline ::google::protobuf::uint32 Storage_Format::iaction() const {
  return iaction_;
}
inline void Storage_Format::set_iaction(::google::protobuf::uint32 value) {
  set_has_iaction();
  iaction_ = value;
}

// optional uint32 iPercent = 2;
inline bool Storage_Format::has_ipercent() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Storage_Format::set_has_ipercent() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Storage_Format::clear_has_ipercent() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Storage_Format::clear_ipercent() {
  ipercent_ = 0u;
  clear_has_ipercent();
}
inline ::google::protobuf::uint32 Storage_Format::ipercent() const {
  return ipercent_;
}
inline void Storage_Format::set_ipercent(::google::protobuf::uint32 value) {
  set_has_ipercent();
  ipercent_ = value;
}

// optional string szMediaName = 3;
inline bool Storage_Format::has_szmedianame() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Storage_Format::set_has_szmedianame() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Storage_Format::clear_has_szmedianame() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Storage_Format::clear_szmedianame() {
  if (szmedianame_ != &::google::protobuf::internal::kEmptyString) {
    szmedianame_->clear();
  }
  clear_has_szmedianame();
}
inline const ::std::string& Storage_Format::szmedianame() const {
  return *szmedianame_;
}
inline void Storage_Format::set_szmedianame(const ::std::string& value) {
  set_has_szmedianame();
  if (szmedianame_ == &::google::protobuf::internal::kEmptyString) {
    szmedianame_ = new ::std::string;
  }
  szmedianame_->assign(value);
}
inline void Storage_Format::set_szmedianame(const char* value) {
  set_has_szmedianame();
  if (szmedianame_ == &::google::protobuf::internal::kEmptyString) {
    szmedianame_ = new ::std::string;
  }
  szmedianame_->assign(value);
}
inline void Storage_Format::set_szmedianame(const char* value, size_t size) {
  set_has_szmedianame();
  if (szmedianame_ == &::google::protobuf::internal::kEmptyString) {
    szmedianame_ = new ::std::string;
  }
  szmedianame_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Storage_Format::mutable_szmedianame() {
  set_has_szmedianame();
  if (szmedianame_ == &::google::protobuf::internal::kEmptyString) {
    szmedianame_ = new ::std::string;
  }
  return szmedianame_;
}
inline ::std::string* Storage_Format::release_szmedianame() {
  clear_has_szmedianame();
  if (szmedianame_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = szmedianame_;
    szmedianame_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// OnlineControlOne

// optional uint32 iTrigger = 1;
inline bool OnlineControlOne::has_itrigger() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OnlineControlOne::set_has_itrigger() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OnlineControlOne::clear_has_itrigger() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OnlineControlOne::clear_itrigger() {
  itrigger_ = 0u;
  clear_has_itrigger();
}
inline ::google::protobuf::uint32 OnlineControlOne::itrigger() const {
  return itrigger_;
}
inline void OnlineControlOne::set_itrigger(::google::protobuf::uint32 value) {
  set_has_itrigger();
  itrigger_ = value;
}

// optional uint32 iEvent = 2;
inline bool OnlineControlOne::has_ievent() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OnlineControlOne::set_has_ievent() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OnlineControlOne::clear_has_ievent() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OnlineControlOne::clear_ievent() {
  ievent_ = 0u;
  clear_has_ievent();
}
inline ::google::protobuf::uint32 OnlineControlOne::ievent() const {
  return ievent_;
}
inline void OnlineControlOne::set_ievent(::google::protobuf::uint32 value) {
  set_has_ievent();
  ievent_ = value;
}

// optional int32 iOnlineTime = 3;
inline bool OnlineControlOne::has_ionlinetime() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void OnlineControlOne::set_has_ionlinetime() {
  _has_bits_[0] |= 0x00000004u;
}
inline void OnlineControlOne::clear_has_ionlinetime() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void OnlineControlOne::clear_ionlinetime() {
  ionlinetime_ = 0;
  clear_has_ionlinetime();
}
inline ::google::protobuf::int32 OnlineControlOne::ionlinetime() const {
  return ionlinetime_;
}
inline void OnlineControlOne::set_ionlinetime(::google::protobuf::int32 value) {
  set_has_ionlinetime();
  ionlinetime_ = value;
}

// optional uint32 iThrough = 4;
inline bool OnlineControlOne::has_ithrough() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void OnlineControlOne::set_has_ithrough() {
  _has_bits_[0] |= 0x00000008u;
}
inline void OnlineControlOne::clear_has_ithrough() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void OnlineControlOne::clear_ithrough() {
  ithrough_ = 0u;
  clear_has_ithrough();
}
inline ::google::protobuf::uint32 OnlineControlOne::ithrough() const {
  return ithrough_;
}
inline void OnlineControlOne::set_ithrough(::google::protobuf::uint32 value) {
  set_has_ithrough();
  ithrough_ = value;
}

// -------------------------------------------------------------------

// OnlineEventSMS

// repeated string szCardNum = 1;
inline int OnlineEventSMS::szcardnum_size() const {
  return szcardnum_.size();
}
inline void OnlineEventSMS::clear_szcardnum() {
  szcardnum_.Clear();
}
inline const ::std::string& OnlineEventSMS::szcardnum(int index) const {
  return szcardnum_.Get(index);
}
inline ::std::string* OnlineEventSMS::mutable_szcardnum(int index) {
  return szcardnum_.Mutable(index);
}
inline void OnlineEventSMS::set_szcardnum(int index, const ::std::string& value) {
  szcardnum_.Mutable(index)->assign(value);
}
inline void OnlineEventSMS::set_szcardnum(int index, const char* value) {
  szcardnum_.Mutable(index)->assign(value);
}
inline void OnlineEventSMS::set_szcardnum(int index, const char* value, size_t size) {
  szcardnum_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OnlineEventSMS::add_szcardnum() {
  return szcardnum_.Add();
}
inline void OnlineEventSMS::add_szcardnum(const ::std::string& value) {
  szcardnum_.Add()->assign(value);
}
inline void OnlineEventSMS::add_szcardnum(const char* value) {
  szcardnum_.Add()->assign(value);
}
inline void OnlineEventSMS::add_szcardnum(const char* value, size_t size) {
  szcardnum_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
OnlineEventSMS::szcardnum() const {
  return szcardnum_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
OnlineEventSMS::mutable_szcardnum() {
  return &szcardnum_;
}

// optional string szContent = 2;
inline bool OnlineEventSMS::has_szcontent() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OnlineEventSMS::set_has_szcontent() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OnlineEventSMS::clear_has_szcontent() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OnlineEventSMS::clear_szcontent() {
  if (szcontent_ != &::google::protobuf::internal::kEmptyString) {
    szcontent_->clear();
  }
  clear_has_szcontent();
}
inline const ::std::string& OnlineEventSMS::szcontent() const {
  return *szcontent_;
}
inline void OnlineEventSMS::set_szcontent(const ::std::string& value) {
  set_has_szcontent();
  if (szcontent_ == &::google::protobuf::internal::kEmptyString) {
    szcontent_ = new ::std::string;
  }
  szcontent_->assign(value);
}
inline void OnlineEventSMS::set_szcontent(const char* value) {
  set_has_szcontent();
  if (szcontent_ == &::google::protobuf::internal::kEmptyString) {
    szcontent_ = new ::std::string;
  }
  szcontent_->assign(value);
}
inline void OnlineEventSMS::set_szcontent(const char* value, size_t size) {
  set_has_szcontent();
  if (szcontent_ == &::google::protobuf::internal::kEmptyString) {
    szcontent_ = new ::std::string;
  }
  szcontent_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OnlineEventSMS::mutable_szcontent() {
  set_has_szcontent();
  if (szcontent_ == &::google::protobuf::internal::kEmptyString) {
    szcontent_ = new ::std::string;
  }
  return szcontent_;
}
inline ::std::string* OnlineEventSMS::release_szcontent() {
  clear_has_szcontent();
  if (szcontent_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = szcontent_;
    szcontent_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional uint32 bReply = 3;
inline bool OnlineEventSMS::has_breply() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void OnlineEventSMS::set_has_breply() {
  _has_bits_[0] |= 0x00000004u;
}
inline void OnlineEventSMS::clear_has_breply() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void OnlineEventSMS::clear_breply() {
  breply_ = 0u;
  clear_has_breply();
}
inline ::google::protobuf::uint32 OnlineEventSMS::breply() const {
  return breply_;
}
inline void OnlineEventSMS::set_breply(::google::protobuf::uint32 value) {
  set_has_breply();
  breply_ = value;
}

// -------------------------------------------------------------------

// OnlineControl_TimeSliceOnlineCtrl

// optional .BVCU.PUConfig.DayTimeSlice stTime = 1;
inline bool OnlineControl_TimeSliceOnlineCtrl::has_sttime() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OnlineControl_TimeSliceOnlineCtrl::set_has_sttime() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OnlineControl_TimeSliceOnlineCtrl::clear_has_sttime() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OnlineControl_TimeSliceOnlineCtrl::clear_sttime() {
  if (sttime_ != NULL) sttime_->::BVCU::PUConfig::DayTimeSlice::Clear();
  clear_has_sttime();
}
inline const ::BVCU::PUConfig::DayTimeSlice& OnlineControl_TimeSliceOnlineCtrl::sttime() const {
  return sttime_ != NULL ? *sttime_ : *default_instance_->sttime_;
}
inline ::BVCU::PUConfig::DayTimeSlice* OnlineControl_TimeSliceOnlineCtrl::mutable_sttime() {
  set_has_sttime();
  if (sttime_ == NULL) sttime_ = new ::BVCU::PUConfig::DayTimeSlice;
  return sttime_;
}
inline ::BVCU::PUConfig::DayTimeSlice* OnlineControl_TimeSliceOnlineCtrl::release_sttime() {
  clear_has_sttime();
  ::BVCU::PUConfig::DayTimeSlice* temp = sttime_;
  sttime_ = NULL;
  return temp;
}

// optional .BVCU.PUConfig.OnlineControlOne stRCO = 2;
inline bool OnlineControl_TimeSliceOnlineCtrl::has_strco() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OnlineControl_TimeSliceOnlineCtrl::set_has_strco() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OnlineControl_TimeSliceOnlineCtrl::clear_has_strco() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OnlineControl_TimeSliceOnlineCtrl::clear_strco() {
  if (strco_ != NULL) strco_->::BVCU::PUConfig::OnlineControlOne::Clear();
  clear_has_strco();
}
inline const ::BVCU::PUConfig::OnlineControlOne& OnlineControl_TimeSliceOnlineCtrl::strco() const {
  return strco_ != NULL ? *strco_ : *default_instance_->strco_;
}
inline ::BVCU::PUConfig::OnlineControlOne* OnlineControl_TimeSliceOnlineCtrl::mutable_strco() {
  set_has_strco();
  if (strco_ == NULL) strco_ = new ::BVCU::PUConfig::OnlineControlOne;
  return strco_;
}
inline ::BVCU::PUConfig::OnlineControlOne* OnlineControl_TimeSliceOnlineCtrl::release_strco() {
  clear_has_strco();
  ::BVCU::PUConfig::OnlineControlOne* temp = strco_;
  strco_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// OnlineControl_TimeSliceOnlineCtrls

// repeated .BVCU.PUConfig.OnlineControl.TimeSliceOnlineCtrl stDay = 1;
inline int OnlineControl_TimeSliceOnlineCtrls::stday_size() const {
  return stday_.size();
}
inline void OnlineControl_TimeSliceOnlineCtrls::clear_stday() {
  stday_.Clear();
}
inline const ::BVCU::PUConfig::OnlineControl_TimeSliceOnlineCtrl& OnlineControl_TimeSliceOnlineCtrls::stday(int index) const {
  return stday_.Get(index);
}
inline ::BVCU::PUConfig::OnlineControl_TimeSliceOnlineCtrl* OnlineControl_TimeSliceOnlineCtrls::mutable_stday(int index) {
  return stday_.Mutable(index);
}
inline ::BVCU::PUConfig::OnlineControl_TimeSliceOnlineCtrl* OnlineControl_TimeSliceOnlineCtrls::add_stday() {
  return stday_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::BVCU::PUConfig::OnlineControl_TimeSliceOnlineCtrl >&
OnlineControl_TimeSliceOnlineCtrls::stday() const {
  return stday_;
}
inline ::google::protobuf::RepeatedPtrField< ::BVCU::PUConfig::OnlineControl_TimeSliceOnlineCtrl >*
OnlineControl_TimeSliceOnlineCtrls::mutable_stday() {
  return &stday_;
}

// -------------------------------------------------------------------

// OnlineControl

// repeated .BVCU.PUConfig.OnlineControl.TimeSliceOnlineCtrls stWeek = 1;
inline int OnlineControl::stweek_size() const {
  return stweek_.size();
}
inline void OnlineControl::clear_stweek() {
  stweek_.Clear();
}
inline const ::BVCU::PUConfig::OnlineControl_TimeSliceOnlineCtrls& OnlineControl::stweek(int index) const {
  return stweek_.Get(index);
}
inline ::BVCU::PUConfig::OnlineControl_TimeSliceOnlineCtrls* OnlineControl::mutable_stweek(int index) {
  return stweek_.Mutable(index);
}
inline ::BVCU::PUConfig::OnlineControl_TimeSliceOnlineCtrls* OnlineControl::add_stweek() {
  return stweek_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::BVCU::PUConfig::OnlineControl_TimeSliceOnlineCtrls >&
OnlineControl::stweek() const {
  return stweek_;
}
inline ::google::protobuf::RepeatedPtrField< ::BVCU::PUConfig::OnlineControl_TimeSliceOnlineCtrls >*
OnlineControl::mutable_stweek() {
  return &stweek_;
}

// optional .BVCU.PUConfig.OnlineEventSMS stRESMS = 8;
inline bool OnlineControl::has_stresms() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OnlineControl::set_has_stresms() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OnlineControl::clear_has_stresms() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OnlineControl::clear_stresms() {
  if (stresms_ != NULL) stresms_->::BVCU::PUConfig::OnlineEventSMS::Clear();
  clear_has_stresms();
}
inline const ::BVCU::PUConfig::OnlineEventSMS& OnlineControl::stresms() const {
  return stresms_ != NULL ? *stresms_ : *default_instance_->stresms_;
}
inline ::BVCU::PUConfig::OnlineEventSMS* OnlineControl::mutable_stresms() {
  set_has_stresms();
  if (stresms_ == NULL) stresms_ = new ::BVCU::PUConfig::OnlineEventSMS;
  return stresms_;
}
inline ::BVCU::PUConfig::OnlineEventSMS* OnlineControl::release_stresms() {
  clear_has_stresms();
  ::BVCU::PUConfig::OnlineEventSMS* temp = stresms_;
  stresms_ = NULL;
  return temp;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace PUConfig
}  // namespace BVCU

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_PUConfig_2eproto__INCLUDED
