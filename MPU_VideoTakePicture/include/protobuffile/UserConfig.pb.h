// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: UserConfig.proto

#ifndef PROTOBUF_UserConfig_2eproto__INCLUDED
#define PROTOBUF_UserConfig_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
// @@protoc_insertion_point(includes)

namespace BVCU {
namespace UserConfig {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_UserConfig_2eproto();
void protobuf_AssignDesc_UserConfig_2eproto();
void protobuf_ShutdownFile_UserConfig_2eproto();

class UserGroup;
class User;
class PUPermissions;
class Resource;
class UserGroupInfo;
class UserInfo;
class UserOnline;
class ModPassword;
class kickout;

enum kickout_kickoutReason {
  kickout_kickoutReason_KICK_REASON_USER_DEL = 0
};
bool kickout_kickoutReason_IsValid(int value);
const kickout_kickoutReason kickout_kickoutReason_kickoutReason_MIN = kickout_kickoutReason_KICK_REASON_USER_DEL;
const kickout_kickoutReason kickout_kickoutReason_kickoutReason_MAX = kickout_kickoutReason_KICK_REASON_USER_DEL;
const int kickout_kickoutReason_kickoutReason_ARRAYSIZE = kickout_kickoutReason_kickoutReason_MAX + 1;

const ::google::protobuf::EnumDescriptor* kickout_kickoutReason_descriptor();
inline const ::std::string& kickout_kickoutReason_Name(kickout_kickoutReason value) {
  return ::google::protobuf::internal::NameOfEnum(
    kickout_kickoutReason_descriptor(), value);
}
inline bool kickout_kickoutReason_Parse(
    const ::std::string& name, kickout_kickoutReason* value) {
  return ::google::protobuf::internal::ParseNamedEnum<kickout_kickoutReason>(
    kickout_kickoutReason_descriptor(), name, value);
}
// ===================================================================

class UserGroup : public ::google::protobuf::Message {
 public:
  UserGroup();
  virtual ~UserGroup();
  
  UserGroup(const UserGroup& from);
  
  inline UserGroup& operator=(const UserGroup& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const UserGroup& default_instance();
  
  void Swap(UserGroup* other);
  
  // implements Message ----------------------------------------------
  
  UserGroup* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UserGroup& from);
  void MergeFrom(const UserGroup& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string sId = 1;
  inline bool has_sid() const;
  inline void clear_sid();
  static const int kSIdFieldNumber = 1;
  inline const ::std::string& sid() const;
  inline void set_sid(const ::std::string& value);
  inline void set_sid(const char* value);
  inline void set_sid(const char* value, size_t size);
  inline ::std::string* mutable_sid();
  inline ::std::string* release_sid();
  
  // optional string sName = 2;
  inline bool has_sname() const;
  inline void clear_sname();
  static const int kSNameFieldNumber = 2;
  inline const ::std::string& sname() const;
  inline void set_sname(const ::std::string& value);
  inline void set_sname(const char* value);
  inline void set_sname(const char* value, size_t size);
  inline ::std::string* mutable_sname();
  inline ::std::string* release_sname();
  
  // optional string sParentId = 3;
  inline bool has_sparentid() const;
  inline void clear_sparentid();
  static const int kSParentIdFieldNumber = 3;
  inline const ::std::string& sparentid() const;
  inline void set_sparentid(const ::std::string& value);
  inline void set_sparentid(const char* value);
  inline void set_sparentid(const char* value, size_t size);
  inline ::std::string* mutable_sparentid();
  inline ::std::string* release_sparentid();
  
  // @@protoc_insertion_point(class_scope:BVCU.UserConfig.UserGroup)
 private:
  inline void set_has_sid();
  inline void clear_has_sid();
  inline void set_has_sname();
  inline void clear_has_sname();
  inline void set_has_sparentid();
  inline void clear_has_sparentid();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* sid_;
  ::std::string* sname_;
  ::std::string* sparentid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_UserConfig_2eproto();
  friend void protobuf_AssignDesc_UserConfig_2eproto();
  friend void protobuf_ShutdownFile_UserConfig_2eproto();
  
  void InitAsDefaultInstance();
  static UserGroup* default_instance_;
};
// -------------------------------------------------------------------

class User : public ::google::protobuf::Message {
 public:
  User();
  virtual ~User();
  
  User(const User& from);
  
  inline User& operator=(const User& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const User& default_instance();
  
  void Swap(User* other);
  
  // implements Message ----------------------------------------------
  
  User* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const User& from);
  void MergeFrom(const User& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string sId = 1;
  inline bool has_sid() const;
  inline void clear_sid();
  static const int kSIdFieldNumber = 1;
  inline const ::std::string& sid() const;
  inline void set_sid(const ::std::string& value);
  inline void set_sid(const char* value);
  inline void set_sid(const char* value, size_t size);
  inline ::std::string* mutable_sid();
  inline ::std::string* release_sid();
  
  // optional string sGroupId = 2;
  inline bool has_sgroupid() const;
  inline void clear_sgroupid();
  static const int kSGroupIdFieldNumber = 2;
  inline const ::std::string& sgroupid() const;
  inline void set_sgroupid(const ::std::string& value);
  inline void set_sgroupid(const char* value);
  inline void set_sgroupid(const char* value, size_t size);
  inline ::std::string* mutable_sgroupid();
  inline ::std::string* release_sgroupid();
  
  // optional string sName = 3;
  inline bool has_sname() const;
  inline void clear_sname();
  static const int kSNameFieldNumber = 3;
  inline const ::std::string& sname() const;
  inline void set_sname(const ::std::string& value);
  inline void set_sname(const char* value);
  inline void set_sname(const char* value, size_t size);
  inline ::std::string* mutable_sname();
  inline ::std::string* release_sname();
  
  // @@protoc_insertion_point(class_scope:BVCU.UserConfig.User)
 private:
  inline void set_has_sid();
  inline void clear_has_sid();
  inline void set_has_sgroupid();
  inline void clear_has_sgroupid();
  inline void set_has_sname();
  inline void clear_has_sname();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* sid_;
  ::std::string* sgroupid_;
  ::std::string* sname_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_UserConfig_2eproto();
  friend void protobuf_AssignDesc_UserConfig_2eproto();
  friend void protobuf_ShutdownFile_UserConfig_2eproto();
  
  void InitAsDefaultInstance();
  static User* default_instance_;
};
// -------------------------------------------------------------------

class PUPermissions : public ::google::protobuf::Message {
 public:
  PUPermissions();
  virtual ~PUPermissions();
  
  PUPermissions(const PUPermissions& from);
  
  inline PUPermissions& operator=(const PUPermissions& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const PUPermissions& default_instance();
  
  void Swap(PUPermissions* other);
  
  // implements Message ----------------------------------------------
  
  PUPermissions* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PUPermissions& from);
  void MergeFrom(const PUPermissions& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional uint32 config = 1;
  inline bool has_config() const;
  inline void clear_config();
  static const int kConfigFieldNumber = 1;
  inline ::google::protobuf::uint32 config() const;
  inline void set_config(::google::protobuf::uint32 value);
  
  // optional bytes channel = 2;
  inline bool has_channel() const;
  inline void clear_channel();
  static const int kChannelFieldNumber = 2;
  inline const ::std::string& channel() const;
  inline void set_channel(const ::std::string& value);
  inline void set_channel(const char* value);
  inline void set_channel(const void* value, size_t size);
  inline ::std::string* mutable_channel();
  inline ::std::string* release_channel();
  
  // @@protoc_insertion_point(class_scope:BVCU.UserConfig.PUPermissions)
 private:
  inline void set_has_config();
  inline void clear_has_config();
  inline void set_has_channel();
  inline void clear_has_channel();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* channel_;
  ::google::protobuf::uint32 config_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_UserConfig_2eproto();
  friend void protobuf_AssignDesc_UserConfig_2eproto();
  friend void protobuf_ShutdownFile_UserConfig_2eproto();
  
  void InitAsDefaultInstance();
  static PUPermissions* default_instance_;
};
// -------------------------------------------------------------------

class Resource : public ::google::protobuf::Message {
 public:
  Resource();
  virtual ~Resource();
  
  Resource(const Resource& from);
  
  inline Resource& operator=(const Resource& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Resource& default_instance();
  
  void Swap(Resource* other);
  
  // implements Message ----------------------------------------------
  
  Resource* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Resource& from);
  void MergeFrom(const Resource& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string sPuID = 1;
  inline bool has_spuid() const;
  inline void clear_spuid();
  static const int kSPuIDFieldNumber = 1;
  inline const ::std::string& spuid() const;
  inline void set_spuid(const ::std::string& value);
  inline void set_spuid(const char* value);
  inline void set_spuid(const char* value, size_t size);
  inline ::std::string* mutable_spuid();
  inline ::std::string* release_spuid();
  
  // optional .BVCU.UserConfig.PUPermissions szPermissions = 2;
  inline bool has_szpermissions() const;
  inline void clear_szpermissions();
  static const int kSzPermissionsFieldNumber = 2;
  inline const ::BVCU::UserConfig::PUPermissions& szpermissions() const;
  inline ::BVCU::UserConfig::PUPermissions* mutable_szpermissions();
  inline ::BVCU::UserConfig::PUPermissions* release_szpermissions();
  
  // @@protoc_insertion_point(class_scope:BVCU.UserConfig.Resource)
 private:
  inline void set_has_spuid();
  inline void clear_has_spuid();
  inline void set_has_szpermissions();
  inline void clear_has_szpermissions();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* spuid_;
  ::BVCU::UserConfig::PUPermissions* szpermissions_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_UserConfig_2eproto();
  friend void protobuf_AssignDesc_UserConfig_2eproto();
  friend void protobuf_ShutdownFile_UserConfig_2eproto();
  
  void InitAsDefaultInstance();
  static Resource* default_instance_;
};
// -------------------------------------------------------------------

class UserGroupInfo : public ::google::protobuf::Message {
 public:
  UserGroupInfo();
  virtual ~UserGroupInfo();
  
  UserGroupInfo(const UserGroupInfo& from);
  
  inline UserGroupInfo& operator=(const UserGroupInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const UserGroupInfo& default_instance();
  
  void Swap(UserGroupInfo* other);
  
  // implements Message ----------------------------------------------
  
  UserGroupInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UserGroupInfo& from);
  void MergeFrom(const UserGroupInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string sId = 1;
  inline bool has_sid() const;
  inline void clear_sid();
  static const int kSIdFieldNumber = 1;
  inline const ::std::string& sid() const;
  inline void set_sid(const ::std::string& value);
  inline void set_sid(const char* value);
  inline void set_sid(const char* value, size_t size);
  inline ::std::string* mutable_sid();
  inline ::std::string* release_sid();
  
  // optional string sName = 2;
  inline bool has_sname() const;
  inline void clear_sname();
  static const int kSNameFieldNumber = 2;
  inline const ::std::string& sname() const;
  inline void set_sname(const ::std::string& value);
  inline void set_sname(const char* value);
  inline void set_sname(const char* value, size_t size);
  inline ::std::string* mutable_sname();
  inline ::std::string* release_sname();
  
  // optional string sParentId = 3;
  inline bool has_sparentid() const;
  inline void clear_sparentid();
  static const int kSParentIdFieldNumber = 3;
  inline const ::std::string& sparentid() const;
  inline void set_sparentid(const ::std::string& value);
  inline void set_sparentid(const char* value);
  inline void set_sparentid(const char* value, size_t size);
  inline ::std::string* mutable_sparentid();
  inline ::std::string* release_sparentid();
  
  // optional string sDescription = 4;
  inline bool has_sdescription() const;
  inline void clear_sdescription();
  static const int kSDescriptionFieldNumber = 4;
  inline const ::std::string& sdescription() const;
  inline void set_sdescription(const ::std::string& value);
  inline void set_sdescription(const char* value);
  inline void set_sdescription(const char* value, size_t size);
  inline ::std::string* mutable_sdescription();
  inline ::std::string* release_sdescription();
  
  // repeated .BVCU.UserConfig.Resource pResource = 5;
  inline int presource_size() const;
  inline void clear_presource();
  static const int kPResourceFieldNumber = 5;
  inline const ::BVCU::UserConfig::Resource& presource(int index) const;
  inline ::BVCU::UserConfig::Resource* mutable_presource(int index);
  inline ::BVCU::UserConfig::Resource* add_presource();
  inline const ::google::protobuf::RepeatedPtrField< ::BVCU::UserConfig::Resource >&
      presource() const;
  inline ::google::protobuf::RepeatedPtrField< ::BVCU::UserConfig::Resource >*
      mutable_presource();
  
  // @@protoc_insertion_point(class_scope:BVCU.UserConfig.UserGroupInfo)
 private:
  inline void set_has_sid();
  inline void clear_has_sid();
  inline void set_has_sname();
  inline void clear_has_sname();
  inline void set_has_sparentid();
  inline void clear_has_sparentid();
  inline void set_has_sdescription();
  inline void clear_has_sdescription();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* sid_;
  ::std::string* sname_;
  ::std::string* sparentid_;
  ::std::string* sdescription_;
  ::google::protobuf::RepeatedPtrField< ::BVCU::UserConfig::Resource > presource_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_UserConfig_2eproto();
  friend void protobuf_AssignDesc_UserConfig_2eproto();
  friend void protobuf_ShutdownFile_UserConfig_2eproto();
  
  void InitAsDefaultInstance();
  static UserGroupInfo* default_instance_;
};
// -------------------------------------------------------------------

class UserInfo : public ::google::protobuf::Message {
 public:
  UserInfo();
  virtual ~UserInfo();
  
  UserInfo(const UserInfo& from);
  
  inline UserInfo& operator=(const UserInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const UserInfo& default_instance();
  
  void Swap(UserInfo* other);
  
  // implements Message ----------------------------------------------
  
  UserInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UserInfo& from);
  void MergeFrom(const UserInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string sId = 1;
  inline bool has_sid() const;
  inline void clear_sid();
  static const int kSIdFieldNumber = 1;
  inline const ::std::string& sid() const;
  inline void set_sid(const ::std::string& value);
  inline void set_sid(const char* value);
  inline void set_sid(const char* value, size_t size);
  inline ::std::string* mutable_sid();
  inline ::std::string* release_sid();
  
  // optional bytes sPasswd = 2;
  inline bool has_spasswd() const;
  inline void clear_spasswd();
  static const int kSPasswdFieldNumber = 2;
  inline const ::std::string& spasswd() const;
  inline void set_spasswd(const ::std::string& value);
  inline void set_spasswd(const char* value);
  inline void set_spasswd(const void* value, size_t size);
  inline ::std::string* mutable_spasswd();
  inline ::std::string* release_spasswd();
  
  // optional uint32 iSysAdmin = 3;
  inline bool has_isysadmin() const;
  inline void clear_isysadmin();
  static const int kISysAdminFieldNumber = 3;
  inline ::google::protobuf::uint32 isysadmin() const;
  inline void set_isysadmin(::google::protobuf::uint32 value);
  
  // optional uint32 iptz = 12;
  inline bool has_iptz() const;
  inline void clear_iptz();
  static const int kIptzFieldNumber = 12;
  inline ::google::protobuf::uint32 iptz() const;
  inline void set_iptz(::google::protobuf::uint32 value);
  
  // optional string sServerId = 4;
  inline bool has_sserverid() const;
  inline void clear_sserverid();
  static const int kSServerIdFieldNumber = 4;
  inline const ::std::string& sserverid() const;
  inline void set_sserverid(const ::std::string& value);
  inline void set_sserverid(const char* value);
  inline void set_sserverid(const char* value, size_t size);
  inline ::std::string* mutable_sserverid();
  inline ::std::string* release_sserverid();
  
  // optional string sGroupId = 5;
  inline bool has_sgroupid() const;
  inline void clear_sgroupid();
  static const int kSGroupIdFieldNumber = 5;
  inline const ::std::string& sgroupid() const;
  inline void set_sgroupid(const ::std::string& value);
  inline void set_sgroupid(const char* value);
  inline void set_sgroupid(const char* value, size_t size);
  inline ::std::string* mutable_sgroupid();
  inline ::std::string* release_sgroupid();
  
  // optional uint32 iMaxSession = 6;
  inline bool has_imaxsession() const;
  inline void clear_imaxsession();
  static const int kIMaxSessionFieldNumber = 6;
  inline ::google::protobuf::uint32 imaxsession() const;
  inline void set_imaxsession(::google::protobuf::uint32 value);
  
  // optional string sAllocateId = 7;
  inline bool has_sallocateid() const;
  inline void clear_sallocateid();
  static const int kSAllocateIdFieldNumber = 7;
  inline const ::std::string& sallocateid() const;
  inline void set_sallocateid(const ::std::string& value);
  inline void set_sallocateid(const char* value);
  inline void set_sallocateid(const char* value, size_t size);
  inline ::std::string* mutable_sallocateid();
  inline ::std::string* release_sallocateid();
  
  // optional string sName = 8;
  inline bool has_sname() const;
  inline void clear_sname();
  static const int kSNameFieldNumber = 8;
  inline const ::std::string& sname() const;
  inline void set_sname(const ::std::string& value);
  inline void set_sname(const char* value);
  inline void set_sname(const char* value, size_t size);
  inline ::std::string* mutable_sname();
  inline ::std::string* release_sname();
  
  // optional string sPhone = 9;
  inline bool has_sphone() const;
  inline void clear_sphone();
  static const int kSPhoneFieldNumber = 9;
  inline const ::std::string& sphone() const;
  inline void set_sphone(const ::std::string& value);
  inline void set_sphone(const char* value);
  inline void set_sphone(const char* value, size_t size);
  inline ::std::string* mutable_sphone();
  inline ::std::string* release_sphone();
  
  // optional string sEmail = 13;
  inline bool has_semail() const;
  inline void clear_semail();
  static const int kSEmailFieldNumber = 13;
  inline const ::std::string& semail() const;
  inline void set_semail(const ::std::string& value);
  inline void set_semail(const char* value);
  inline void set_semail(const char* value, size_t size);
  inline ::std::string* mutable_semail();
  inline ::std::string* release_semail();
  
  // optional string sDescription = 10;
  inline bool has_sdescription() const;
  inline void clear_sdescription();
  static const int kSDescriptionFieldNumber = 10;
  inline const ::std::string& sdescription() const;
  inline void set_sdescription(const ::std::string& value);
  inline void set_sdescription(const char* value);
  inline void set_sdescription(const char* value, size_t size);
  inline ::std::string* mutable_sdescription();
  inline ::std::string* release_sdescription();
  
  // repeated .BVCU.UserConfig.Resource pResource = 11;
  inline int presource_size() const;
  inline void clear_presource();
  static const int kPResourceFieldNumber = 11;
  inline const ::BVCU::UserConfig::Resource& presource(int index) const;
  inline ::BVCU::UserConfig::Resource* mutable_presource(int index);
  inline ::BVCU::UserConfig::Resource* add_presource();
  inline const ::google::protobuf::RepeatedPtrField< ::BVCU::UserConfig::Resource >&
      presource() const;
  inline ::google::protobuf::RepeatedPtrField< ::BVCU::UserConfig::Resource >*
      mutable_presource();
  
  // @@protoc_insertion_point(class_scope:BVCU.UserConfig.UserInfo)
 private:
  inline void set_has_sid();
  inline void clear_has_sid();
  inline void set_has_spasswd();
  inline void clear_has_spasswd();
  inline void set_has_isysadmin();
  inline void clear_has_isysadmin();
  inline void set_has_iptz();
  inline void clear_has_iptz();
  inline void set_has_sserverid();
  inline void clear_has_sserverid();
  inline void set_has_sgroupid();
  inline void clear_has_sgroupid();
  inline void set_has_imaxsession();
  inline void clear_has_imaxsession();
  inline void set_has_sallocateid();
  inline void clear_has_sallocateid();
  inline void set_has_sname();
  inline void clear_has_sname();
  inline void set_has_sphone();
  inline void clear_has_sphone();
  inline void set_has_semail();
  inline void clear_has_semail();
  inline void set_has_sdescription();
  inline void clear_has_sdescription();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* sid_;
  ::std::string* spasswd_;
  ::google::protobuf::uint32 isysadmin_;
  ::google::protobuf::uint32 iptz_;
  ::std::string* sserverid_;
  ::std::string* sgroupid_;
  ::std::string* sallocateid_;
  ::std::string* sname_;
  ::std::string* sphone_;
  ::std::string* semail_;
  ::std::string* sdescription_;
  ::google::protobuf::RepeatedPtrField< ::BVCU::UserConfig::Resource > presource_;
  ::google::protobuf::uint32 imaxsession_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(13 + 31) / 32];
  
  friend void  protobuf_AddDesc_UserConfig_2eproto();
  friend void protobuf_AssignDesc_UserConfig_2eproto();
  friend void protobuf_ShutdownFile_UserConfig_2eproto();
  
  void InitAsDefaultInstance();
  static UserInfo* default_instance_;
};
// -------------------------------------------------------------------

class UserOnline : public ::google::protobuf::Message {
 public:
  UserOnline();
  virtual ~UserOnline();
  
  UserOnline(const UserOnline& from);
  
  inline UserOnline& operator=(const UserOnline& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const UserOnline& default_instance();
  
  void Swap(UserOnline* other);
  
  // implements Message ----------------------------------------------
  
  UserOnline* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UserOnline& from);
  void MergeFrom(const UserOnline& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string sUserId = 1;
  inline bool has_suserid() const;
  inline void clear_suserid();
  static const int kSUserIdFieldNumber = 1;
  inline const ::std::string& suserid() const;
  inline void set_suserid(const ::std::string& value);
  inline void set_suserid(const char* value);
  inline void set_suserid(const char* value, size_t size);
  inline ::std::string* mutable_suserid();
  inline ::std::string* release_suserid();
  
  // optional string szDevID = 2;
  inline bool has_szdevid() const;
  inline void clear_szdevid();
  static const int kSzDevIDFieldNumber = 2;
  inline const ::std::string& szdevid() const;
  inline void set_szdevid(const ::std::string& value);
  inline void set_szdevid(const char* value);
  inline void set_szdevid(const char* value, size_t size);
  inline ::std::string* mutable_szdevid();
  inline ::std::string* release_szdevid();
  
  // optional string szAddr = 3;
  inline bool has_szaddr() const;
  inline void clear_szaddr();
  static const int kSzAddrFieldNumber = 3;
  inline const ::std::string& szaddr() const;
  inline void set_szaddr(const ::std::string& value);
  inline void set_szaddr(const char* value);
  inline void set_szaddr(const char* value, size_t size);
  inline ::std::string* mutable_szaddr();
  inline ::std::string* release_szaddr();
  
  // optional uint32 iStatus = 4;
  inline bool has_istatus() const;
  inline void clear_istatus();
  static const int kIStatusFieldNumber = 4;
  inline ::google::protobuf::uint32 istatus() const;
  inline void set_istatus(::google::protobuf::uint32 value);
  
  // optional uint32 iApplierID = 5;
  inline bool has_iapplierid() const;
  inline void clear_iapplierid();
  static const int kIApplierIDFieldNumber = 5;
  inline ::google::protobuf::uint32 iapplierid() const;
  inline void set_iapplierid(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:BVCU.UserConfig.UserOnline)
 private:
  inline void set_has_suserid();
  inline void clear_has_suserid();
  inline void set_has_szdevid();
  inline void clear_has_szdevid();
  inline void set_has_szaddr();
  inline void clear_has_szaddr();
  inline void set_has_istatus();
  inline void clear_has_istatus();
  inline void set_has_iapplierid();
  inline void clear_has_iapplierid();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* suserid_;
  ::std::string* szdevid_;
  ::std::string* szaddr_;
  ::google::protobuf::uint32 istatus_;
  ::google::protobuf::uint32 iapplierid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_UserConfig_2eproto();
  friend void protobuf_AssignDesc_UserConfig_2eproto();
  friend void protobuf_ShutdownFile_UserConfig_2eproto();
  
  void InitAsDefaultInstance();
  static UserOnline* default_instance_;
};
// -------------------------------------------------------------------

class ModPassword : public ::google::protobuf::Message {
 public:
  ModPassword();
  virtual ~ModPassword();
  
  ModPassword(const ModPassword& from);
  
  inline ModPassword& operator=(const ModPassword& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ModPassword& default_instance();
  
  void Swap(ModPassword* other);
  
  // implements Message ----------------------------------------------
  
  ModPassword* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ModPassword& from);
  void MergeFrom(const ModPassword& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string sId = 1;
  inline bool has_sid() const;
  inline void clear_sid();
  static const int kSIdFieldNumber = 1;
  inline const ::std::string& sid() const;
  inline void set_sid(const ::std::string& value);
  inline void set_sid(const char* value);
  inline void set_sid(const char* value, size_t size);
  inline ::std::string* mutable_sid();
  inline ::std::string* release_sid();
  
  // optional bytes sPassword = 2;
  inline bool has_spassword() const;
  inline void clear_spassword();
  static const int kSPasswordFieldNumber = 2;
  inline const ::std::string& spassword() const;
  inline void set_spassword(const ::std::string& value);
  inline void set_spassword(const char* value);
  inline void set_spassword(const void* value, size_t size);
  inline ::std::string* mutable_spassword();
  inline ::std::string* release_spassword();
  
  // optional bytes sNewPassword = 3;
  inline bool has_snewpassword() const;
  inline void clear_snewpassword();
  static const int kSNewPasswordFieldNumber = 3;
  inline const ::std::string& snewpassword() const;
  inline void set_snewpassword(const ::std::string& value);
  inline void set_snewpassword(const char* value);
  inline void set_snewpassword(const void* value, size_t size);
  inline ::std::string* mutable_snewpassword();
  inline ::std::string* release_snewpassword();
  
  // @@protoc_insertion_point(class_scope:BVCU.UserConfig.ModPassword)
 private:
  inline void set_has_sid();
  inline void clear_has_sid();
  inline void set_has_spassword();
  inline void clear_has_spassword();
  inline void set_has_snewpassword();
  inline void clear_has_snewpassword();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* sid_;
  ::std::string* spassword_;
  ::std::string* snewpassword_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_UserConfig_2eproto();
  friend void protobuf_AssignDesc_UserConfig_2eproto();
  friend void protobuf_ShutdownFile_UserConfig_2eproto();
  
  void InitAsDefaultInstance();
  static ModPassword* default_instance_;
};
// -------------------------------------------------------------------

class kickout : public ::google::protobuf::Message {
 public:
  kickout();
  virtual ~kickout();
  
  kickout(const kickout& from);
  
  inline kickout& operator=(const kickout& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const kickout& default_instance();
  
  void Swap(kickout* other);
  
  // implements Message ----------------------------------------------
  
  kickout* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const kickout& from);
  void MergeFrom(const kickout& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef kickout_kickoutReason kickoutReason;
  static const kickoutReason KICK_REASON_USER_DEL = kickout_kickoutReason_KICK_REASON_USER_DEL;
  static inline bool kickoutReason_IsValid(int value) {
    return kickout_kickoutReason_IsValid(value);
  }
  static const kickoutReason kickoutReason_MIN =
    kickout_kickoutReason_kickoutReason_MIN;
  static const kickoutReason kickoutReason_MAX =
    kickout_kickoutReason_kickoutReason_MAX;
  static const int kickoutReason_ARRAYSIZE =
    kickout_kickoutReason_kickoutReason_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  kickoutReason_descriptor() {
    return kickout_kickoutReason_descriptor();
  }
  static inline const ::std::string& kickoutReason_Name(kickoutReason value) {
    return kickout_kickoutReason_Name(value);
  }
  static inline bool kickoutReason_Parse(const ::std::string& name,
      kickoutReason* value) {
    return kickout_kickoutReason_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // optional int32 iReason = 1;
  inline bool has_ireason() const;
  inline void clear_ireason();
  static const int kIReasonFieldNumber = 1;
  inline ::google::protobuf::int32 ireason() const;
  inline void set_ireason(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:BVCU.UserConfig.kickout)
 private:
  inline void set_has_ireason();
  inline void clear_has_ireason();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 ireason_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_UserConfig_2eproto();
  friend void protobuf_AssignDesc_UserConfig_2eproto();
  friend void protobuf_ShutdownFile_UserConfig_2eproto();
  
  void InitAsDefaultInstance();
  static kickout* default_instance_;
};
// ===================================================================


// ===================================================================

// UserGroup

// optional string sId = 1;
inline bool UserGroup::has_sid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserGroup::set_has_sid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserGroup::clear_has_sid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserGroup::clear_sid() {
  if (sid_ != &::google::protobuf::internal::kEmptyString) {
    sid_->clear();
  }
  clear_has_sid();
}
inline const ::std::string& UserGroup::sid() const {
  return *sid_;
}
inline void UserGroup::set_sid(const ::std::string& value) {
  set_has_sid();
  if (sid_ == &::google::protobuf::internal::kEmptyString) {
    sid_ = new ::std::string;
  }
  sid_->assign(value);
}
inline void UserGroup::set_sid(const char* value) {
  set_has_sid();
  if (sid_ == &::google::protobuf::internal::kEmptyString) {
    sid_ = new ::std::string;
  }
  sid_->assign(value);
}
inline void UserGroup::set_sid(const char* value, size_t size) {
  set_has_sid();
  if (sid_ == &::google::protobuf::internal::kEmptyString) {
    sid_ = new ::std::string;
  }
  sid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserGroup::mutable_sid() {
  set_has_sid();
  if (sid_ == &::google::protobuf::internal::kEmptyString) {
    sid_ = new ::std::string;
  }
  return sid_;
}
inline ::std::string* UserGroup::release_sid() {
  clear_has_sid();
  if (sid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sid_;
    sid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string sName = 2;
inline bool UserGroup::has_sname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserGroup::set_has_sname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserGroup::clear_has_sname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserGroup::clear_sname() {
  if (sname_ != &::google::protobuf::internal::kEmptyString) {
    sname_->clear();
  }
  clear_has_sname();
}
inline const ::std::string& UserGroup::sname() const {
  return *sname_;
}
inline void UserGroup::set_sname(const ::std::string& value) {
  set_has_sname();
  if (sname_ == &::google::protobuf::internal::kEmptyString) {
    sname_ = new ::std::string;
  }
  sname_->assign(value);
}
inline void UserGroup::set_sname(const char* value) {
  set_has_sname();
  if (sname_ == &::google::protobuf::internal::kEmptyString) {
    sname_ = new ::std::string;
  }
  sname_->assign(value);
}
inline void UserGroup::set_sname(const char* value, size_t size) {
  set_has_sname();
  if (sname_ == &::google::protobuf::internal::kEmptyString) {
    sname_ = new ::std::string;
  }
  sname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserGroup::mutable_sname() {
  set_has_sname();
  if (sname_ == &::google::protobuf::internal::kEmptyString) {
    sname_ = new ::std::string;
  }
  return sname_;
}
inline ::std::string* UserGroup::release_sname() {
  clear_has_sname();
  if (sname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sname_;
    sname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string sParentId = 3;
inline bool UserGroup::has_sparentid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UserGroup::set_has_sparentid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UserGroup::clear_has_sparentid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UserGroup::clear_sparentid() {
  if (sparentid_ != &::google::protobuf::internal::kEmptyString) {
    sparentid_->clear();
  }
  clear_has_sparentid();
}
inline const ::std::string& UserGroup::sparentid() const {
  return *sparentid_;
}
inline void UserGroup::set_sparentid(const ::std::string& value) {
  set_has_sparentid();
  if (sparentid_ == &::google::protobuf::internal::kEmptyString) {
    sparentid_ = new ::std::string;
  }
  sparentid_->assign(value);
}
inline void UserGroup::set_sparentid(const char* value) {
  set_has_sparentid();
  if (sparentid_ == &::google::protobuf::internal::kEmptyString) {
    sparentid_ = new ::std::string;
  }
  sparentid_->assign(value);
}
inline void UserGroup::set_sparentid(const char* value, size_t size) {
  set_has_sparentid();
  if (sparentid_ == &::google::protobuf::internal::kEmptyString) {
    sparentid_ = new ::std::string;
  }
  sparentid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserGroup::mutable_sparentid() {
  set_has_sparentid();
  if (sparentid_ == &::google::protobuf::internal::kEmptyString) {
    sparentid_ = new ::std::string;
  }
  return sparentid_;
}
inline ::std::string* UserGroup::release_sparentid() {
  clear_has_sparentid();
  if (sparentid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sparentid_;
    sparentid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// User

// optional string sId = 1;
inline bool User::has_sid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void User::set_has_sid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void User::clear_has_sid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void User::clear_sid() {
  if (sid_ != &::google::protobuf::internal::kEmptyString) {
    sid_->clear();
  }
  clear_has_sid();
}
inline const ::std::string& User::sid() const {
  return *sid_;
}
inline void User::set_sid(const ::std::string& value) {
  set_has_sid();
  if (sid_ == &::google::protobuf::internal::kEmptyString) {
    sid_ = new ::std::string;
  }
  sid_->assign(value);
}
inline void User::set_sid(const char* value) {
  set_has_sid();
  if (sid_ == &::google::protobuf::internal::kEmptyString) {
    sid_ = new ::std::string;
  }
  sid_->assign(value);
}
inline void User::set_sid(const char* value, size_t size) {
  set_has_sid();
  if (sid_ == &::google::protobuf::internal::kEmptyString) {
    sid_ = new ::std::string;
  }
  sid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* User::mutable_sid() {
  set_has_sid();
  if (sid_ == &::google::protobuf::internal::kEmptyString) {
    sid_ = new ::std::string;
  }
  return sid_;
}
inline ::std::string* User::release_sid() {
  clear_has_sid();
  if (sid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sid_;
    sid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string sGroupId = 2;
inline bool User::has_sgroupid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void User::set_has_sgroupid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void User::clear_has_sgroupid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void User::clear_sgroupid() {
  if (sgroupid_ != &::google::protobuf::internal::kEmptyString) {
    sgroupid_->clear();
  }
  clear_has_sgroupid();
}
inline const ::std::string& User::sgroupid() const {
  return *sgroupid_;
}
inline void User::set_sgroupid(const ::std::string& value) {
  set_has_sgroupid();
  if (sgroupid_ == &::google::protobuf::internal::kEmptyString) {
    sgroupid_ = new ::std::string;
  }
  sgroupid_->assign(value);
}
inline void User::set_sgroupid(const char* value) {
  set_has_sgroupid();
  if (sgroupid_ == &::google::protobuf::internal::kEmptyString) {
    sgroupid_ = new ::std::string;
  }
  sgroupid_->assign(value);
}
inline void User::set_sgroupid(const char* value, size_t size) {
  set_has_sgroupid();
  if (sgroupid_ == &::google::protobuf::internal::kEmptyString) {
    sgroupid_ = new ::std::string;
  }
  sgroupid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* User::mutable_sgroupid() {
  set_has_sgroupid();
  if (sgroupid_ == &::google::protobuf::internal::kEmptyString) {
    sgroupid_ = new ::std::string;
  }
  return sgroupid_;
}
inline ::std::string* User::release_sgroupid() {
  clear_has_sgroupid();
  if (sgroupid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sgroupid_;
    sgroupid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string sName = 3;
inline bool User::has_sname() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void User::set_has_sname() {
  _has_bits_[0] |= 0x00000004u;
}
inline void User::clear_has_sname() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void User::clear_sname() {
  if (sname_ != &::google::protobuf::internal::kEmptyString) {
    sname_->clear();
  }
  clear_has_sname();
}
inline const ::std::string& User::sname() const {
  return *sname_;
}
inline void User::set_sname(const ::std::string& value) {
  set_has_sname();
  if (sname_ == &::google::protobuf::internal::kEmptyString) {
    sname_ = new ::std::string;
  }
  sname_->assign(value);
}
inline void User::set_sname(const char* value) {
  set_has_sname();
  if (sname_ == &::google::protobuf::internal::kEmptyString) {
    sname_ = new ::std::string;
  }
  sname_->assign(value);
}
inline void User::set_sname(const char* value, size_t size) {
  set_has_sname();
  if (sname_ == &::google::protobuf::internal::kEmptyString) {
    sname_ = new ::std::string;
  }
  sname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* User::mutable_sname() {
  set_has_sname();
  if (sname_ == &::google::protobuf::internal::kEmptyString) {
    sname_ = new ::std::string;
  }
  return sname_;
}
inline ::std::string* User::release_sname() {
  clear_has_sname();
  if (sname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sname_;
    sname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// PUPermissions

// optional uint32 config = 1;
inline bool PUPermissions::has_config() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PUPermissions::set_has_config() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PUPermissions::clear_has_config() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PUPermissions::clear_config() {
  config_ = 0u;
  clear_has_config();
}
inline ::google::protobuf::uint32 PUPermissions::config() const {
  return config_;
}
inline void PUPermissions::set_config(::google::protobuf::uint32 value) {
  set_has_config();
  config_ = value;
}

// optional bytes channel = 2;
inline bool PUPermissions::has_channel() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PUPermissions::set_has_channel() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PUPermissions::clear_has_channel() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PUPermissions::clear_channel() {
  if (channel_ != &::google::protobuf::internal::kEmptyString) {
    channel_->clear();
  }
  clear_has_channel();
}
inline const ::std::string& PUPermissions::channel() const {
  return *channel_;
}
inline void PUPermissions::set_channel(const ::std::string& value) {
  set_has_channel();
  if (channel_ == &::google::protobuf::internal::kEmptyString) {
    channel_ = new ::std::string;
  }
  channel_->assign(value);
}
inline void PUPermissions::set_channel(const char* value) {
  set_has_channel();
  if (channel_ == &::google::protobuf::internal::kEmptyString) {
    channel_ = new ::std::string;
  }
  channel_->assign(value);
}
inline void PUPermissions::set_channel(const void* value, size_t size) {
  set_has_channel();
  if (channel_ == &::google::protobuf::internal::kEmptyString) {
    channel_ = new ::std::string;
  }
  channel_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PUPermissions::mutable_channel() {
  set_has_channel();
  if (channel_ == &::google::protobuf::internal::kEmptyString) {
    channel_ = new ::std::string;
  }
  return channel_;
}
inline ::std::string* PUPermissions::release_channel() {
  clear_has_channel();
  if (channel_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = channel_;
    channel_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// Resource

// optional string sPuID = 1;
inline bool Resource::has_spuid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Resource::set_has_spuid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Resource::clear_has_spuid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Resource::clear_spuid() {
  if (spuid_ != &::google::protobuf::internal::kEmptyString) {
    spuid_->clear();
  }
  clear_has_spuid();
}
inline const ::std::string& Resource::spuid() const {
  return *spuid_;
}
inline void Resource::set_spuid(const ::std::string& value) {
  set_has_spuid();
  if (spuid_ == &::google::protobuf::internal::kEmptyString) {
    spuid_ = new ::std::string;
  }
  spuid_->assign(value);
}
inline void Resource::set_spuid(const char* value) {
  set_has_spuid();
  if (spuid_ == &::google::protobuf::internal::kEmptyString) {
    spuid_ = new ::std::string;
  }
  spuid_->assign(value);
}
inline void Resource::set_spuid(const char* value, size_t size) {
  set_has_spuid();
  if (spuid_ == &::google::protobuf::internal::kEmptyString) {
    spuid_ = new ::std::string;
  }
  spuid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Resource::mutable_spuid() {
  set_has_spuid();
  if (spuid_ == &::google::protobuf::internal::kEmptyString) {
    spuid_ = new ::std::string;
  }
  return spuid_;
}
inline ::std::string* Resource::release_spuid() {
  clear_has_spuid();
  if (spuid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = spuid_;
    spuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional .BVCU.UserConfig.PUPermissions szPermissions = 2;
inline bool Resource::has_szpermissions() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Resource::set_has_szpermissions() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Resource::clear_has_szpermissions() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Resource::clear_szpermissions() {
  if (szpermissions_ != NULL) szpermissions_->::BVCU::UserConfig::PUPermissions::Clear();
  clear_has_szpermissions();
}
inline const ::BVCU::UserConfig::PUPermissions& Resource::szpermissions() const {
  return szpermissions_ != NULL ? *szpermissions_ : *default_instance_->szpermissions_;
}
inline ::BVCU::UserConfig::PUPermissions* Resource::mutable_szpermissions() {
  set_has_szpermissions();
  if (szpermissions_ == NULL) szpermissions_ = new ::BVCU::UserConfig::PUPermissions;
  return szpermissions_;
}
inline ::BVCU::UserConfig::PUPermissions* Resource::release_szpermissions() {
  clear_has_szpermissions();
  ::BVCU::UserConfig::PUPermissions* temp = szpermissions_;
  szpermissions_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// UserGroupInfo

// optional string sId = 1;
inline bool UserGroupInfo::has_sid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserGroupInfo::set_has_sid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserGroupInfo::clear_has_sid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserGroupInfo::clear_sid() {
  if (sid_ != &::google::protobuf::internal::kEmptyString) {
    sid_->clear();
  }
  clear_has_sid();
}
inline const ::std::string& UserGroupInfo::sid() const {
  return *sid_;
}
inline void UserGroupInfo::set_sid(const ::std::string& value) {
  set_has_sid();
  if (sid_ == &::google::protobuf::internal::kEmptyString) {
    sid_ = new ::std::string;
  }
  sid_->assign(value);
}
inline void UserGroupInfo::set_sid(const char* value) {
  set_has_sid();
  if (sid_ == &::google::protobuf::internal::kEmptyString) {
    sid_ = new ::std::string;
  }
  sid_->assign(value);
}
inline void UserGroupInfo::set_sid(const char* value, size_t size) {
  set_has_sid();
  if (sid_ == &::google::protobuf::internal::kEmptyString) {
    sid_ = new ::std::string;
  }
  sid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserGroupInfo::mutable_sid() {
  set_has_sid();
  if (sid_ == &::google::protobuf::internal::kEmptyString) {
    sid_ = new ::std::string;
  }
  return sid_;
}
inline ::std::string* UserGroupInfo::release_sid() {
  clear_has_sid();
  if (sid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sid_;
    sid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string sName = 2;
inline bool UserGroupInfo::has_sname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserGroupInfo::set_has_sname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserGroupInfo::clear_has_sname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserGroupInfo::clear_sname() {
  if (sname_ != &::google::protobuf::internal::kEmptyString) {
    sname_->clear();
  }
  clear_has_sname();
}
inline const ::std::string& UserGroupInfo::sname() const {
  return *sname_;
}
inline void UserGroupInfo::set_sname(const ::std::string& value) {
  set_has_sname();
  if (sname_ == &::google::protobuf::internal::kEmptyString) {
    sname_ = new ::std::string;
  }
  sname_->assign(value);
}
inline void UserGroupInfo::set_sname(const char* value) {
  set_has_sname();
  if (sname_ == &::google::protobuf::internal::kEmptyString) {
    sname_ = new ::std::string;
  }
  sname_->assign(value);
}
inline void UserGroupInfo::set_sname(const char* value, size_t size) {
  set_has_sname();
  if (sname_ == &::google::protobuf::internal::kEmptyString) {
    sname_ = new ::std::string;
  }
  sname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserGroupInfo::mutable_sname() {
  set_has_sname();
  if (sname_ == &::google::protobuf::internal::kEmptyString) {
    sname_ = new ::std::string;
  }
  return sname_;
}
inline ::std::string* UserGroupInfo::release_sname() {
  clear_has_sname();
  if (sname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sname_;
    sname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string sParentId = 3;
inline bool UserGroupInfo::has_sparentid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UserGroupInfo::set_has_sparentid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UserGroupInfo::clear_has_sparentid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UserGroupInfo::clear_sparentid() {
  if (sparentid_ != &::google::protobuf::internal::kEmptyString) {
    sparentid_->clear();
  }
  clear_has_sparentid();
}
inline const ::std::string& UserGroupInfo::sparentid() const {
  return *sparentid_;
}
inline void UserGroupInfo::set_sparentid(const ::std::string& value) {
  set_has_sparentid();
  if (sparentid_ == &::google::protobuf::internal::kEmptyString) {
    sparentid_ = new ::std::string;
  }
  sparentid_->assign(value);
}
inline void UserGroupInfo::set_sparentid(const char* value) {
  set_has_sparentid();
  if (sparentid_ == &::google::protobuf::internal::kEmptyString) {
    sparentid_ = new ::std::string;
  }
  sparentid_->assign(value);
}
inline void UserGroupInfo::set_sparentid(const char* value, size_t size) {
  set_has_sparentid();
  if (sparentid_ == &::google::protobuf::internal::kEmptyString) {
    sparentid_ = new ::std::string;
  }
  sparentid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserGroupInfo::mutable_sparentid() {
  set_has_sparentid();
  if (sparentid_ == &::google::protobuf::internal::kEmptyString) {
    sparentid_ = new ::std::string;
  }
  return sparentid_;
}
inline ::std::string* UserGroupInfo::release_sparentid() {
  clear_has_sparentid();
  if (sparentid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sparentid_;
    sparentid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string sDescription = 4;
inline bool UserGroupInfo::has_sdescription() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UserGroupInfo::set_has_sdescription() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UserGroupInfo::clear_has_sdescription() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UserGroupInfo::clear_sdescription() {
  if (sdescription_ != &::google::protobuf::internal::kEmptyString) {
    sdescription_->clear();
  }
  clear_has_sdescription();
}
inline const ::std::string& UserGroupInfo::sdescription() const {
  return *sdescription_;
}
inline void UserGroupInfo::set_sdescription(const ::std::string& value) {
  set_has_sdescription();
  if (sdescription_ == &::google::protobuf::internal::kEmptyString) {
    sdescription_ = new ::std::string;
  }
  sdescription_->assign(value);
}
inline void UserGroupInfo::set_sdescription(const char* value) {
  set_has_sdescription();
  if (sdescription_ == &::google::protobuf::internal::kEmptyString) {
    sdescription_ = new ::std::string;
  }
  sdescription_->assign(value);
}
inline void UserGroupInfo::set_sdescription(const char* value, size_t size) {
  set_has_sdescription();
  if (sdescription_ == &::google::protobuf::internal::kEmptyString) {
    sdescription_ = new ::std::string;
  }
  sdescription_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserGroupInfo::mutable_sdescription() {
  set_has_sdescription();
  if (sdescription_ == &::google::protobuf::internal::kEmptyString) {
    sdescription_ = new ::std::string;
  }
  return sdescription_;
}
inline ::std::string* UserGroupInfo::release_sdescription() {
  clear_has_sdescription();
  if (sdescription_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sdescription_;
    sdescription_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated .BVCU.UserConfig.Resource pResource = 5;
inline int UserGroupInfo::presource_size() const {
  return presource_.size();
}
inline void UserGroupInfo::clear_presource() {
  presource_.Clear();
}
inline const ::BVCU::UserConfig::Resource& UserGroupInfo::presource(int index) const {
  return presource_.Get(index);
}
inline ::BVCU::UserConfig::Resource* UserGroupInfo::mutable_presource(int index) {
  return presource_.Mutable(index);
}
inline ::BVCU::UserConfig::Resource* UserGroupInfo::add_presource() {
  return presource_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::BVCU::UserConfig::Resource >&
UserGroupInfo::presource() const {
  return presource_;
}
inline ::google::protobuf::RepeatedPtrField< ::BVCU::UserConfig::Resource >*
UserGroupInfo::mutable_presource() {
  return &presource_;
}

// -------------------------------------------------------------------

// UserInfo

// optional string sId = 1;
inline bool UserInfo::has_sid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserInfo::set_has_sid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserInfo::clear_has_sid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserInfo::clear_sid() {
  if (sid_ != &::google::protobuf::internal::kEmptyString) {
    sid_->clear();
  }
  clear_has_sid();
}
inline const ::std::string& UserInfo::sid() const {
  return *sid_;
}
inline void UserInfo::set_sid(const ::std::string& value) {
  set_has_sid();
  if (sid_ == &::google::protobuf::internal::kEmptyString) {
    sid_ = new ::std::string;
  }
  sid_->assign(value);
}
inline void UserInfo::set_sid(const char* value) {
  set_has_sid();
  if (sid_ == &::google::protobuf::internal::kEmptyString) {
    sid_ = new ::std::string;
  }
  sid_->assign(value);
}
inline void UserInfo::set_sid(const char* value, size_t size) {
  set_has_sid();
  if (sid_ == &::google::protobuf::internal::kEmptyString) {
    sid_ = new ::std::string;
  }
  sid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserInfo::mutable_sid() {
  set_has_sid();
  if (sid_ == &::google::protobuf::internal::kEmptyString) {
    sid_ = new ::std::string;
  }
  return sid_;
}
inline ::std::string* UserInfo::release_sid() {
  clear_has_sid();
  if (sid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sid_;
    sid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bytes sPasswd = 2;
inline bool UserInfo::has_spasswd() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserInfo::set_has_spasswd() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserInfo::clear_has_spasswd() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserInfo::clear_spasswd() {
  if (spasswd_ != &::google::protobuf::internal::kEmptyString) {
    spasswd_->clear();
  }
  clear_has_spasswd();
}
inline const ::std::string& UserInfo::spasswd() const {
  return *spasswd_;
}
inline void UserInfo::set_spasswd(const ::std::string& value) {
  set_has_spasswd();
  if (spasswd_ == &::google::protobuf::internal::kEmptyString) {
    spasswd_ = new ::std::string;
  }
  spasswd_->assign(value);
}
inline void UserInfo::set_spasswd(const char* value) {
  set_has_spasswd();
  if (spasswd_ == &::google::protobuf::internal::kEmptyString) {
    spasswd_ = new ::std::string;
  }
  spasswd_->assign(value);
}
inline void UserInfo::set_spasswd(const void* value, size_t size) {
  set_has_spasswd();
  if (spasswd_ == &::google::protobuf::internal::kEmptyString) {
    spasswd_ = new ::std::string;
  }
  spasswd_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserInfo::mutable_spasswd() {
  set_has_spasswd();
  if (spasswd_ == &::google::protobuf::internal::kEmptyString) {
    spasswd_ = new ::std::string;
  }
  return spasswd_;
}
inline ::std::string* UserInfo::release_spasswd() {
  clear_has_spasswd();
  if (spasswd_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = spasswd_;
    spasswd_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional uint32 iSysAdmin = 3;
inline bool UserInfo::has_isysadmin() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UserInfo::set_has_isysadmin() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UserInfo::clear_has_isysadmin() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UserInfo::clear_isysadmin() {
  isysadmin_ = 0u;
  clear_has_isysadmin();
}
inline ::google::protobuf::uint32 UserInfo::isysadmin() const {
  return isysadmin_;
}
inline void UserInfo::set_isysadmin(::google::protobuf::uint32 value) {
  set_has_isysadmin();
  isysadmin_ = value;
}

// optional uint32 iptz = 12;
inline bool UserInfo::has_iptz() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UserInfo::set_has_iptz() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UserInfo::clear_has_iptz() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UserInfo::clear_iptz() {
  iptz_ = 0u;
  clear_has_iptz();
}
inline ::google::protobuf::uint32 UserInfo::iptz() const {
  return iptz_;
}
inline void UserInfo::set_iptz(::google::protobuf::uint32 value) {
  set_has_iptz();
  iptz_ = value;
}

// optional string sServerId = 4;
inline bool UserInfo::has_sserverid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UserInfo::set_has_sserverid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void UserInfo::clear_has_sserverid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void UserInfo::clear_sserverid() {
  if (sserverid_ != &::google::protobuf::internal::kEmptyString) {
    sserverid_->clear();
  }
  clear_has_sserverid();
}
inline const ::std::string& UserInfo::sserverid() const {
  return *sserverid_;
}
inline void UserInfo::set_sserverid(const ::std::string& value) {
  set_has_sserverid();
  if (sserverid_ == &::google::protobuf::internal::kEmptyString) {
    sserverid_ = new ::std::string;
  }
  sserverid_->assign(value);
}
inline void UserInfo::set_sserverid(const char* value) {
  set_has_sserverid();
  if (sserverid_ == &::google::protobuf::internal::kEmptyString) {
    sserverid_ = new ::std::string;
  }
  sserverid_->assign(value);
}
inline void UserInfo::set_sserverid(const char* value, size_t size) {
  set_has_sserverid();
  if (sserverid_ == &::google::protobuf::internal::kEmptyString) {
    sserverid_ = new ::std::string;
  }
  sserverid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserInfo::mutable_sserverid() {
  set_has_sserverid();
  if (sserverid_ == &::google::protobuf::internal::kEmptyString) {
    sserverid_ = new ::std::string;
  }
  return sserverid_;
}
inline ::std::string* UserInfo::release_sserverid() {
  clear_has_sserverid();
  if (sserverid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sserverid_;
    sserverid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string sGroupId = 5;
inline bool UserInfo::has_sgroupid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void UserInfo::set_has_sgroupid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void UserInfo::clear_has_sgroupid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void UserInfo::clear_sgroupid() {
  if (sgroupid_ != &::google::protobuf::internal::kEmptyString) {
    sgroupid_->clear();
  }
  clear_has_sgroupid();
}
inline const ::std::string& UserInfo::sgroupid() const {
  return *sgroupid_;
}
inline void UserInfo::set_sgroupid(const ::std::string& value) {
  set_has_sgroupid();
  if (sgroupid_ == &::google::protobuf::internal::kEmptyString) {
    sgroupid_ = new ::std::string;
  }
  sgroupid_->assign(value);
}
inline void UserInfo::set_sgroupid(const char* value) {
  set_has_sgroupid();
  if (sgroupid_ == &::google::protobuf::internal::kEmptyString) {
    sgroupid_ = new ::std::string;
  }
  sgroupid_->assign(value);
}
inline void UserInfo::set_sgroupid(const char* value, size_t size) {
  set_has_sgroupid();
  if (sgroupid_ == &::google::protobuf::internal::kEmptyString) {
    sgroupid_ = new ::std::string;
  }
  sgroupid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserInfo::mutable_sgroupid() {
  set_has_sgroupid();
  if (sgroupid_ == &::google::protobuf::internal::kEmptyString) {
    sgroupid_ = new ::std::string;
  }
  return sgroupid_;
}
inline ::std::string* UserInfo::release_sgroupid() {
  clear_has_sgroupid();
  if (sgroupid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sgroupid_;
    sgroupid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional uint32 iMaxSession = 6;
inline bool UserInfo::has_imaxsession() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void UserInfo::set_has_imaxsession() {
  _has_bits_[0] |= 0x00000040u;
}
inline void UserInfo::clear_has_imaxsession() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void UserInfo::clear_imaxsession() {
  imaxsession_ = 0u;
  clear_has_imaxsession();
}
inline ::google::protobuf::uint32 UserInfo::imaxsession() const {
  return imaxsession_;
}
inline void UserInfo::set_imaxsession(::google::protobuf::uint32 value) {
  set_has_imaxsession();
  imaxsession_ = value;
}

// optional string sAllocateId = 7;
inline bool UserInfo::has_sallocateid() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void UserInfo::set_has_sallocateid() {
  _has_bits_[0] |= 0x00000080u;
}
inline void UserInfo::clear_has_sallocateid() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void UserInfo::clear_sallocateid() {
  if (sallocateid_ != &::google::protobuf::internal::kEmptyString) {
    sallocateid_->clear();
  }
  clear_has_sallocateid();
}
inline const ::std::string& UserInfo::sallocateid() const {
  return *sallocateid_;
}
inline void UserInfo::set_sallocateid(const ::std::string& value) {
  set_has_sallocateid();
  if (sallocateid_ == &::google::protobuf::internal::kEmptyString) {
    sallocateid_ = new ::std::string;
  }
  sallocateid_->assign(value);
}
inline void UserInfo::set_sallocateid(const char* value) {
  set_has_sallocateid();
  if (sallocateid_ == &::google::protobuf::internal::kEmptyString) {
    sallocateid_ = new ::std::string;
  }
  sallocateid_->assign(value);
}
inline void UserInfo::set_sallocateid(const char* value, size_t size) {
  set_has_sallocateid();
  if (sallocateid_ == &::google::protobuf::internal::kEmptyString) {
    sallocateid_ = new ::std::string;
  }
  sallocateid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserInfo::mutable_sallocateid() {
  set_has_sallocateid();
  if (sallocateid_ == &::google::protobuf::internal::kEmptyString) {
    sallocateid_ = new ::std::string;
  }
  return sallocateid_;
}
inline ::std::string* UserInfo::release_sallocateid() {
  clear_has_sallocateid();
  if (sallocateid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sallocateid_;
    sallocateid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string sName = 8;
inline bool UserInfo::has_sname() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void UserInfo::set_has_sname() {
  _has_bits_[0] |= 0x00000100u;
}
inline void UserInfo::clear_has_sname() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void UserInfo::clear_sname() {
  if (sname_ != &::google::protobuf::internal::kEmptyString) {
    sname_->clear();
  }
  clear_has_sname();
}
inline const ::std::string& UserInfo::sname() const {
  return *sname_;
}
inline void UserInfo::set_sname(const ::std::string& value) {
  set_has_sname();
  if (sname_ == &::google::protobuf::internal::kEmptyString) {
    sname_ = new ::std::string;
  }
  sname_->assign(value);
}
inline void UserInfo::set_sname(const char* value) {
  set_has_sname();
  if (sname_ == &::google::protobuf::internal::kEmptyString) {
    sname_ = new ::std::string;
  }
  sname_->assign(value);
}
inline void UserInfo::set_sname(const char* value, size_t size) {
  set_has_sname();
  if (sname_ == &::google::protobuf::internal::kEmptyString) {
    sname_ = new ::std::string;
  }
  sname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserInfo::mutable_sname() {
  set_has_sname();
  if (sname_ == &::google::protobuf::internal::kEmptyString) {
    sname_ = new ::std::string;
  }
  return sname_;
}
inline ::std::string* UserInfo::release_sname() {
  clear_has_sname();
  if (sname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sname_;
    sname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string sPhone = 9;
inline bool UserInfo::has_sphone() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void UserInfo::set_has_sphone() {
  _has_bits_[0] |= 0x00000200u;
}
inline void UserInfo::clear_has_sphone() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void UserInfo::clear_sphone() {
  if (sphone_ != &::google::protobuf::internal::kEmptyString) {
    sphone_->clear();
  }
  clear_has_sphone();
}
inline const ::std::string& UserInfo::sphone() const {
  return *sphone_;
}
inline void UserInfo::set_sphone(const ::std::string& value) {
  set_has_sphone();
  if (sphone_ == &::google::protobuf::internal::kEmptyString) {
    sphone_ = new ::std::string;
  }
  sphone_->assign(value);
}
inline void UserInfo::set_sphone(const char* value) {
  set_has_sphone();
  if (sphone_ == &::google::protobuf::internal::kEmptyString) {
    sphone_ = new ::std::string;
  }
  sphone_->assign(value);
}
inline void UserInfo::set_sphone(const char* value, size_t size) {
  set_has_sphone();
  if (sphone_ == &::google::protobuf::internal::kEmptyString) {
    sphone_ = new ::std::string;
  }
  sphone_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserInfo::mutable_sphone() {
  set_has_sphone();
  if (sphone_ == &::google::protobuf::internal::kEmptyString) {
    sphone_ = new ::std::string;
  }
  return sphone_;
}
inline ::std::string* UserInfo::release_sphone() {
  clear_has_sphone();
  if (sphone_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sphone_;
    sphone_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string sEmail = 13;
inline bool UserInfo::has_semail() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void UserInfo::set_has_semail() {
  _has_bits_[0] |= 0x00000400u;
}
inline void UserInfo::clear_has_semail() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void UserInfo::clear_semail() {
  if (semail_ != &::google::protobuf::internal::kEmptyString) {
    semail_->clear();
  }
  clear_has_semail();
}
inline const ::std::string& UserInfo::semail() const {
  return *semail_;
}
inline void UserInfo::set_semail(const ::std::string& value) {
  set_has_semail();
  if (semail_ == &::google::protobuf::internal::kEmptyString) {
    semail_ = new ::std::string;
  }
  semail_->assign(value);
}
inline void UserInfo::set_semail(const char* value) {
  set_has_semail();
  if (semail_ == &::google::protobuf::internal::kEmptyString) {
    semail_ = new ::std::string;
  }
  semail_->assign(value);
}
inline void UserInfo::set_semail(const char* value, size_t size) {
  set_has_semail();
  if (semail_ == &::google::protobuf::internal::kEmptyString) {
    semail_ = new ::std::string;
  }
  semail_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserInfo::mutable_semail() {
  set_has_semail();
  if (semail_ == &::google::protobuf::internal::kEmptyString) {
    semail_ = new ::std::string;
  }
  return semail_;
}
inline ::std::string* UserInfo::release_semail() {
  clear_has_semail();
  if (semail_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = semail_;
    semail_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string sDescription = 10;
inline bool UserInfo::has_sdescription() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void UserInfo::set_has_sdescription() {
  _has_bits_[0] |= 0x00000800u;
}
inline void UserInfo::clear_has_sdescription() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void UserInfo::clear_sdescription() {
  if (sdescription_ != &::google::protobuf::internal::kEmptyString) {
    sdescription_->clear();
  }
  clear_has_sdescription();
}
inline const ::std::string& UserInfo::sdescription() const {
  return *sdescription_;
}
inline void UserInfo::set_sdescription(const ::std::string& value) {
  set_has_sdescription();
  if (sdescription_ == &::google::protobuf::internal::kEmptyString) {
    sdescription_ = new ::std::string;
  }
  sdescription_->assign(value);
}
inline void UserInfo::set_sdescription(const char* value) {
  set_has_sdescription();
  if (sdescription_ == &::google::protobuf::internal::kEmptyString) {
    sdescription_ = new ::std::string;
  }
  sdescription_->assign(value);
}
inline void UserInfo::set_sdescription(const char* value, size_t size) {
  set_has_sdescription();
  if (sdescription_ == &::google::protobuf::internal::kEmptyString) {
    sdescription_ = new ::std::string;
  }
  sdescription_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserInfo::mutable_sdescription() {
  set_has_sdescription();
  if (sdescription_ == &::google::protobuf::internal::kEmptyString) {
    sdescription_ = new ::std::string;
  }
  return sdescription_;
}
inline ::std::string* UserInfo::release_sdescription() {
  clear_has_sdescription();
  if (sdescription_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sdescription_;
    sdescription_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated .BVCU.UserConfig.Resource pResource = 11;
inline int UserInfo::presource_size() const {
  return presource_.size();
}
inline void UserInfo::clear_presource() {
  presource_.Clear();
}
inline const ::BVCU::UserConfig::Resource& UserInfo::presource(int index) const {
  return presource_.Get(index);
}
inline ::BVCU::UserConfig::Resource* UserInfo::mutable_presource(int index) {
  return presource_.Mutable(index);
}
inline ::BVCU::UserConfig::Resource* UserInfo::add_presource() {
  return presource_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::BVCU::UserConfig::Resource >&
UserInfo::presource() const {
  return presource_;
}
inline ::google::protobuf::RepeatedPtrField< ::BVCU::UserConfig::Resource >*
UserInfo::mutable_presource() {
  return &presource_;
}

// -------------------------------------------------------------------

// UserOnline

// optional string sUserId = 1;
inline bool UserOnline::has_suserid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserOnline::set_has_suserid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserOnline::clear_has_suserid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserOnline::clear_suserid() {
  if (suserid_ != &::google::protobuf::internal::kEmptyString) {
    suserid_->clear();
  }
  clear_has_suserid();
}
inline const ::std::string& UserOnline::suserid() const {
  return *suserid_;
}
inline void UserOnline::set_suserid(const ::std::string& value) {
  set_has_suserid();
  if (suserid_ == &::google::protobuf::internal::kEmptyString) {
    suserid_ = new ::std::string;
  }
  suserid_->assign(value);
}
inline void UserOnline::set_suserid(const char* value) {
  set_has_suserid();
  if (suserid_ == &::google::protobuf::internal::kEmptyString) {
    suserid_ = new ::std::string;
  }
  suserid_->assign(value);
}
inline void UserOnline::set_suserid(const char* value, size_t size) {
  set_has_suserid();
  if (suserid_ == &::google::protobuf::internal::kEmptyString) {
    suserid_ = new ::std::string;
  }
  suserid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserOnline::mutable_suserid() {
  set_has_suserid();
  if (suserid_ == &::google::protobuf::internal::kEmptyString) {
    suserid_ = new ::std::string;
  }
  return suserid_;
}
inline ::std::string* UserOnline::release_suserid() {
  clear_has_suserid();
  if (suserid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = suserid_;
    suserid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string szDevID = 2;
inline bool UserOnline::has_szdevid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserOnline::set_has_szdevid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserOnline::clear_has_szdevid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserOnline::clear_szdevid() {
  if (szdevid_ != &::google::protobuf::internal::kEmptyString) {
    szdevid_->clear();
  }
  clear_has_szdevid();
}
inline const ::std::string& UserOnline::szdevid() const {
  return *szdevid_;
}
inline void UserOnline::set_szdevid(const ::std::string& value) {
  set_has_szdevid();
  if (szdevid_ == &::google::protobuf::internal::kEmptyString) {
    szdevid_ = new ::std::string;
  }
  szdevid_->assign(value);
}
inline void UserOnline::set_szdevid(const char* value) {
  set_has_szdevid();
  if (szdevid_ == &::google::protobuf::internal::kEmptyString) {
    szdevid_ = new ::std::string;
  }
  szdevid_->assign(value);
}
inline void UserOnline::set_szdevid(const char* value, size_t size) {
  set_has_szdevid();
  if (szdevid_ == &::google::protobuf::internal::kEmptyString) {
    szdevid_ = new ::std::string;
  }
  szdevid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserOnline::mutable_szdevid() {
  set_has_szdevid();
  if (szdevid_ == &::google::protobuf::internal::kEmptyString) {
    szdevid_ = new ::std::string;
  }
  return szdevid_;
}
inline ::std::string* UserOnline::release_szdevid() {
  clear_has_szdevid();
  if (szdevid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = szdevid_;
    szdevid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string szAddr = 3;
inline bool UserOnline::has_szaddr() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UserOnline::set_has_szaddr() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UserOnline::clear_has_szaddr() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UserOnline::clear_szaddr() {
  if (szaddr_ != &::google::protobuf::internal::kEmptyString) {
    szaddr_->clear();
  }
  clear_has_szaddr();
}
inline const ::std::string& UserOnline::szaddr() const {
  return *szaddr_;
}
inline void UserOnline::set_szaddr(const ::std::string& value) {
  set_has_szaddr();
  if (szaddr_ == &::google::protobuf::internal::kEmptyString) {
    szaddr_ = new ::std::string;
  }
  szaddr_->assign(value);
}
inline void UserOnline::set_szaddr(const char* value) {
  set_has_szaddr();
  if (szaddr_ == &::google::protobuf::internal::kEmptyString) {
    szaddr_ = new ::std::string;
  }
  szaddr_->assign(value);
}
inline void UserOnline::set_szaddr(const char* value, size_t size) {
  set_has_szaddr();
  if (szaddr_ == &::google::protobuf::internal::kEmptyString) {
    szaddr_ = new ::std::string;
  }
  szaddr_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserOnline::mutable_szaddr() {
  set_has_szaddr();
  if (szaddr_ == &::google::protobuf::internal::kEmptyString) {
    szaddr_ = new ::std::string;
  }
  return szaddr_;
}
inline ::std::string* UserOnline::release_szaddr() {
  clear_has_szaddr();
  if (szaddr_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = szaddr_;
    szaddr_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional uint32 iStatus = 4;
inline bool UserOnline::has_istatus() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UserOnline::set_has_istatus() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UserOnline::clear_has_istatus() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UserOnline::clear_istatus() {
  istatus_ = 0u;
  clear_has_istatus();
}
inline ::google::protobuf::uint32 UserOnline::istatus() const {
  return istatus_;
}
inline void UserOnline::set_istatus(::google::protobuf::uint32 value) {
  set_has_istatus();
  istatus_ = value;
}

// optional uint32 iApplierID = 5;
inline bool UserOnline::has_iapplierid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UserOnline::set_has_iapplierid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void UserOnline::clear_has_iapplierid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void UserOnline::clear_iapplierid() {
  iapplierid_ = 0u;
  clear_has_iapplierid();
}
inline ::google::protobuf::uint32 UserOnline::iapplierid() const {
  return iapplierid_;
}
inline void UserOnline::set_iapplierid(::google::protobuf::uint32 value) {
  set_has_iapplierid();
  iapplierid_ = value;
}

// -------------------------------------------------------------------

// ModPassword

// optional string sId = 1;
inline bool ModPassword::has_sid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ModPassword::set_has_sid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ModPassword::clear_has_sid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ModPassword::clear_sid() {
  if (sid_ != &::google::protobuf::internal::kEmptyString) {
    sid_->clear();
  }
  clear_has_sid();
}
inline const ::std::string& ModPassword::sid() const {
  return *sid_;
}
inline void ModPassword::set_sid(const ::std::string& value) {
  set_has_sid();
  if (sid_ == &::google::protobuf::internal::kEmptyString) {
    sid_ = new ::std::string;
  }
  sid_->assign(value);
}
inline void ModPassword::set_sid(const char* value) {
  set_has_sid();
  if (sid_ == &::google::protobuf::internal::kEmptyString) {
    sid_ = new ::std::string;
  }
  sid_->assign(value);
}
inline void ModPassword::set_sid(const char* value, size_t size) {
  set_has_sid();
  if (sid_ == &::google::protobuf::internal::kEmptyString) {
    sid_ = new ::std::string;
  }
  sid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ModPassword::mutable_sid() {
  set_has_sid();
  if (sid_ == &::google::protobuf::internal::kEmptyString) {
    sid_ = new ::std::string;
  }
  return sid_;
}
inline ::std::string* ModPassword::release_sid() {
  clear_has_sid();
  if (sid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sid_;
    sid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bytes sPassword = 2;
inline bool ModPassword::has_spassword() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ModPassword::set_has_spassword() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ModPassword::clear_has_spassword() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ModPassword::clear_spassword() {
  if (spassword_ != &::google::protobuf::internal::kEmptyString) {
    spassword_->clear();
  }
  clear_has_spassword();
}
inline const ::std::string& ModPassword::spassword() const {
  return *spassword_;
}
inline void ModPassword::set_spassword(const ::std::string& value) {
  set_has_spassword();
  if (spassword_ == &::google::protobuf::internal::kEmptyString) {
    spassword_ = new ::std::string;
  }
  spassword_->assign(value);
}
inline void ModPassword::set_spassword(const char* value) {
  set_has_spassword();
  if (spassword_ == &::google::protobuf::internal::kEmptyString) {
    spassword_ = new ::std::string;
  }
  spassword_->assign(value);
}
inline void ModPassword::set_spassword(const void* value, size_t size) {
  set_has_spassword();
  if (spassword_ == &::google::protobuf::internal::kEmptyString) {
    spassword_ = new ::std::string;
  }
  spassword_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ModPassword::mutable_spassword() {
  set_has_spassword();
  if (spassword_ == &::google::protobuf::internal::kEmptyString) {
    spassword_ = new ::std::string;
  }
  return spassword_;
}
inline ::std::string* ModPassword::release_spassword() {
  clear_has_spassword();
  if (spassword_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = spassword_;
    spassword_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bytes sNewPassword = 3;
inline bool ModPassword::has_snewpassword() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ModPassword::set_has_snewpassword() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ModPassword::clear_has_snewpassword() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ModPassword::clear_snewpassword() {
  if (snewpassword_ != &::google::protobuf::internal::kEmptyString) {
    snewpassword_->clear();
  }
  clear_has_snewpassword();
}
inline const ::std::string& ModPassword::snewpassword() const {
  return *snewpassword_;
}
inline void ModPassword::set_snewpassword(const ::std::string& value) {
  set_has_snewpassword();
  if (snewpassword_ == &::google::protobuf::internal::kEmptyString) {
    snewpassword_ = new ::std::string;
  }
  snewpassword_->assign(value);
}
inline void ModPassword::set_snewpassword(const char* value) {
  set_has_snewpassword();
  if (snewpassword_ == &::google::protobuf::internal::kEmptyString) {
    snewpassword_ = new ::std::string;
  }
  snewpassword_->assign(value);
}
inline void ModPassword::set_snewpassword(const void* value, size_t size) {
  set_has_snewpassword();
  if (snewpassword_ == &::google::protobuf::internal::kEmptyString) {
    snewpassword_ = new ::std::string;
  }
  snewpassword_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ModPassword::mutable_snewpassword() {
  set_has_snewpassword();
  if (snewpassword_ == &::google::protobuf::internal::kEmptyString) {
    snewpassword_ = new ::std::string;
  }
  return snewpassword_;
}
inline ::std::string* ModPassword::release_snewpassword() {
  clear_has_snewpassword();
  if (snewpassword_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = snewpassword_;
    snewpassword_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// kickout

// optional int32 iReason = 1;
inline bool kickout::has_ireason() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void kickout::set_has_ireason() {
  _has_bits_[0] |= 0x00000001u;
}
inline void kickout::clear_has_ireason() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void kickout::clear_ireason() {
  ireason_ = 0;
  clear_has_ireason();
}
inline ::google::protobuf::int32 kickout::ireason() const {
  return ireason_;
}
inline void kickout::set_ireason(::google::protobuf::int32 value) {
  set_has_ireason();
  ireason_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace UserConfig
}  // namespace BVCU

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::BVCU::UserConfig::kickout_kickoutReason>() {
  return ::BVCU::UserConfig::kickout_kickoutReason_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_UserConfig_2eproto__INCLUDED
