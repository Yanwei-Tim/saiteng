// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: NRUConfig.proto

#ifndef PROTOBUF_NRUConfig_2eproto__INCLUDED
#define PROTOBUF_NRUConfig_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
#include "PUConfig.pb.h"
// @@protoc_insertion_point(includes)

namespace BVCU {
namespace NRUConfig {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_NRUConfig_2eproto();
void protobuf_AssignDesc_NRUConfig_2eproto();
void protobuf_ShutdownFile_NRUConfig_2eproto();

class StorageMedia;
class NRUItem;
class NRUInfo;
class Storage_Schedule_ListItem;
class Storage_Channel;
class Storage_PU;
class Storage_Schedule;

// ===================================================================

class StorageMedia : public ::google::protobuf::Message {
 public:
  StorageMedia();
  virtual ~StorageMedia();
  
  StorageMedia(const StorageMedia& from);
  
  inline StorageMedia& operator=(const StorageMedia& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const StorageMedia& default_instance();
  
  void Swap(StorageMedia* other);
  
  // implements Message ----------------------------------------------
  
  StorageMedia* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StorageMedia& from);
  void MergeFrom(const StorageMedia& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string szName = 1;
  inline bool has_szname() const;
  inline void clear_szname();
  static const int kSzNameFieldNumber = 1;
  inline const ::std::string& szname() const;
  inline void set_szname(const ::std::string& value);
  inline void set_szname(const char* value);
  inline void set_szname(const char* value, size_t size);
  inline ::std::string* mutable_szname();
  inline ::std::string* release_szname();
  
  // optional uint32 iTotalSpace = 2;
  inline bool has_itotalspace() const;
  inline void clear_itotalspace();
  static const int kITotalSpaceFieldNumber = 2;
  inline ::google::protobuf::uint32 itotalspace() const;
  inline void set_itotalspace(::google::protobuf::uint32 value);
  
  // optional uint32 iFreeSpace = 3;
  inline bool has_ifreespace() const;
  inline void clear_ifreespace();
  static const int kIFreeSpaceFieldNumber = 3;
  inline ::google::protobuf::uint32 ifreespace() const;
  inline void set_ifreespace(::google::protobuf::uint32 value);
  
  // optional uint32 bInUse = 4;
  inline bool has_binuse() const;
  inline void clear_binuse();
  static const int kBInUseFieldNumber = 4;
  inline ::google::protobuf::uint32 binuse() const;
  inline void set_binuse(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:BVCU.NRUConfig.StorageMedia)
 private:
  inline void set_has_szname();
  inline void clear_has_szname();
  inline void set_has_itotalspace();
  inline void clear_has_itotalspace();
  inline void set_has_ifreespace();
  inline void clear_has_ifreespace();
  inline void set_has_binuse();
  inline void clear_has_binuse();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* szname_;
  ::google::protobuf::uint32 itotalspace_;
  ::google::protobuf::uint32 ifreespace_;
  ::google::protobuf::uint32 binuse_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_NRUConfig_2eproto();
  friend void protobuf_AssignDesc_NRUConfig_2eproto();
  friend void protobuf_ShutdownFile_NRUConfig_2eproto();
  
  void InitAsDefaultInstance();
  static StorageMedia* default_instance_;
};
// -------------------------------------------------------------------

class NRUItem : public ::google::protobuf::Message {
 public:
  NRUItem();
  virtual ~NRUItem();
  
  NRUItem(const NRUItem& from);
  
  inline NRUItem& operator=(const NRUItem& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const NRUItem& default_instance();
  
  void Swap(NRUItem* other);
  
  // implements Message ----------------------------------------------
  
  NRUItem* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NRUItem& from);
  void MergeFrom(const NRUItem& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string szID = 1;
  inline bool has_szid() const;
  inline void clear_szid();
  static const int kSzIDFieldNumber = 1;
  inline const ::std::string& szid() const;
  inline void set_szid(const ::std::string& value);
  inline void set_szid(const char* value);
  inline void set_szid(const char* value, size_t size);
  inline ::std::string* mutable_szid();
  inline ::std::string* release_szid();
  
  // optional string szName = 2;
  inline bool has_szname() const;
  inline void clear_szname();
  static const int kSzNameFieldNumber = 2;
  inline const ::std::string& szname() const;
  inline void set_szname(const ::std::string& value);
  inline void set_szname(const char* value);
  inline void set_szname(const char* value, size_t size);
  inline ::std::string* mutable_szname();
  inline ::std::string* release_szname();
  
  // optional uint32 iStorageMediaCount = 3;
  inline bool has_istoragemediacount() const;
  inline void clear_istoragemediacount();
  static const int kIStorageMediaCountFieldNumber = 3;
  inline ::google::protobuf::uint32 istoragemediacount() const;
  inline void set_istoragemediacount(::google::protobuf::uint32 value);
  
  // optional uint32 iOnlineStatus = 4;
  inline bool has_ionlinestatus() const;
  inline void clear_ionlinestatus();
  static const int kIOnlineStatusFieldNumber = 4;
  inline ::google::protobuf::uint32 ionlinestatus() const;
  inline void set_ionlinestatus(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:BVCU.NRUConfig.NRUItem)
 private:
  inline void set_has_szid();
  inline void clear_has_szid();
  inline void set_has_szname();
  inline void clear_has_szname();
  inline void set_has_istoragemediacount();
  inline void clear_has_istoragemediacount();
  inline void set_has_ionlinestatus();
  inline void clear_has_ionlinestatus();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* szid_;
  ::std::string* szname_;
  ::google::protobuf::uint32 istoragemediacount_;
  ::google::protobuf::uint32 ionlinestatus_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_NRUConfig_2eproto();
  friend void protobuf_AssignDesc_NRUConfig_2eproto();
  friend void protobuf_ShutdownFile_NRUConfig_2eproto();
  
  void InitAsDefaultInstance();
  static NRUItem* default_instance_;
};
// -------------------------------------------------------------------

class NRUInfo : public ::google::protobuf::Message {
 public:
  NRUInfo();
  virtual ~NRUInfo();
  
  NRUInfo(const NRUInfo& from);
  
  inline NRUInfo& operator=(const NRUInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const NRUInfo& default_instance();
  
  void Swap(NRUInfo* other);
  
  // implements Message ----------------------------------------------
  
  NRUInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NRUInfo& from);
  void MergeFrom(const NRUInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string szID = 1;
  inline bool has_szid() const;
  inline void clear_szid();
  static const int kSzIDFieldNumber = 1;
  inline const ::std::string& szid() const;
  inline void set_szid(const ::std::string& value);
  inline void set_szid(const char* value);
  inline void set_szid(const char* value, size_t size);
  inline ::std::string* mutable_szid();
  inline ::std::string* release_szid();
  
  // optional string szManufacturer = 2;
  inline bool has_szmanufacturer() const;
  inline void clear_szmanufacturer();
  static const int kSzManufacturerFieldNumber = 2;
  inline const ::std::string& szmanufacturer() const;
  inline void set_szmanufacturer(const ::std::string& value);
  inline void set_szmanufacturer(const char* value);
  inline void set_szmanufacturer(const char* value, size_t size);
  inline ::std::string* mutable_szmanufacturer();
  inline ::std::string* release_szmanufacturer();
  
  // optional string szSoftwareVersion = 3;
  inline bool has_szsoftwareversion() const;
  inline void clear_szsoftwareversion();
  static const int kSzSoftwareVersionFieldNumber = 3;
  inline const ::std::string& szsoftwareversion() const;
  inline void set_szsoftwareversion(const ::std::string& value);
  inline void set_szsoftwareversion(const char* value);
  inline void set_szsoftwareversion(const char* value, size_t size);
  inline ::std::string* mutable_szsoftwareversion();
  inline ::std::string* release_szsoftwareversion();
  
  // optional string szHardwareVersion = 4;
  inline bool has_szhardwareversion() const;
  inline void clear_szhardwareversion();
  static const int kSzHardwareVersionFieldNumber = 4;
  inline const ::std::string& szhardwareversion() const;
  inline void set_szhardwareversion(const ::std::string& value);
  inline void set_szhardwareversion(const char* value);
  inline void set_szhardwareversion(const char* value, size_t size);
  inline ::std::string* mutable_szhardwareversion();
  inline ::std::string* release_szhardwareversion();
  
  // optional string szName = 5;
  inline bool has_szname() const;
  inline void clear_szname();
  static const int kSzNameFieldNumber = 5;
  inline const ::std::string& szname() const;
  inline void set_szname(const ::std::string& value);
  inline void set_szname(const char* value);
  inline void set_szname(const char* value, size_t size);
  inline ::std::string* mutable_szname();
  inline ::std::string* release_szname();
  
  // optional uint32 iNoSpaceRule = 6;
  inline bool has_inospacerule() const;
  inline void clear_inospacerule();
  static const int kINoSpaceRuleFieldNumber = 6;
  inline ::google::protobuf::uint32 inospacerule() const;
  inline void set_inospacerule(::google::protobuf::uint32 value);
  
  // optional uint32 iReserveRecordDays = 7;
  inline bool has_ireserverecorddays() const;
  inline void clear_ireserverecorddays();
  static const int kIReserveRecordDaysFieldNumber = 7;
  inline ::google::protobuf::uint32 ireserverecorddays() const;
  inline void set_ireserverecorddays(::google::protobuf::uint32 value);
  
  // optional uint32 iRecordFileLength = 8;
  inline bool has_irecordfilelength() const;
  inline void clear_irecordfilelength();
  static const int kIRecordFileLengthFieldNumber = 8;
  inline ::google::protobuf::uint32 irecordfilelength() const;
  inline void set_irecordfilelength(::google::protobuf::uint32 value);
  
  // optional uint32 iReservePicDays = 9;
  inline bool has_ireservepicdays() const;
  inline void clear_ireservepicdays();
  static const int kIReservePicDaysFieldNumber = 9;
  inline ::google::protobuf::uint32 ireservepicdays() const;
  inline void set_ireservepicdays(::google::protobuf::uint32 value);
  
  // optional uint32 iReserveGPSDays = 10;
  inline bool has_ireservegpsdays() const;
  inline void clear_ireservegpsdays();
  static const int kIReserveGPSDaysFieldNumber = 10;
  inline ::google::protobuf::uint32 ireservegpsdays() const;
  inline void set_ireservegpsdays(::google::protobuf::uint32 value);
  
  // optional uint32 iOnlineStatus = 11;
  inline bool has_ionlinestatus() const;
  inline void clear_ionlinestatus();
  static const int kIOnlineStatusFieldNumber = 11;
  inline ::google::protobuf::uint32 ionlinestatus() const;
  inline void set_ionlinestatus(::google::protobuf::uint32 value);
  
  // repeated .BVCU.NRUConfig.StorageMedia pStorageMedia = 12;
  inline int pstoragemedia_size() const;
  inline void clear_pstoragemedia();
  static const int kPStorageMediaFieldNumber = 12;
  inline const ::BVCU::NRUConfig::StorageMedia& pstoragemedia(int index) const;
  inline ::BVCU::NRUConfig::StorageMedia* mutable_pstoragemedia(int index);
  inline ::BVCU::NRUConfig::StorageMedia* add_pstoragemedia();
  inline const ::google::protobuf::RepeatedPtrField< ::BVCU::NRUConfig::StorageMedia >&
      pstoragemedia() const;
  inline ::google::protobuf::RepeatedPtrField< ::BVCU::NRUConfig::StorageMedia >*
      mutable_pstoragemedia();
  
  // @@protoc_insertion_point(class_scope:BVCU.NRUConfig.NRUInfo)
 private:
  inline void set_has_szid();
  inline void clear_has_szid();
  inline void set_has_szmanufacturer();
  inline void clear_has_szmanufacturer();
  inline void set_has_szsoftwareversion();
  inline void clear_has_szsoftwareversion();
  inline void set_has_szhardwareversion();
  inline void clear_has_szhardwareversion();
  inline void set_has_szname();
  inline void clear_has_szname();
  inline void set_has_inospacerule();
  inline void clear_has_inospacerule();
  inline void set_has_ireserverecorddays();
  inline void clear_has_ireserverecorddays();
  inline void set_has_irecordfilelength();
  inline void clear_has_irecordfilelength();
  inline void set_has_ireservepicdays();
  inline void clear_has_ireservepicdays();
  inline void set_has_ireservegpsdays();
  inline void clear_has_ireservegpsdays();
  inline void set_has_ionlinestatus();
  inline void clear_has_ionlinestatus();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* szid_;
  ::std::string* szmanufacturer_;
  ::std::string* szsoftwareversion_;
  ::std::string* szhardwareversion_;
  ::std::string* szname_;
  ::google::protobuf::uint32 inospacerule_;
  ::google::protobuf::uint32 ireserverecorddays_;
  ::google::protobuf::uint32 irecordfilelength_;
  ::google::protobuf::uint32 ireservepicdays_;
  ::google::protobuf::uint32 ireservegpsdays_;
  ::google::protobuf::uint32 ionlinestatus_;
  ::google::protobuf::RepeatedPtrField< ::BVCU::NRUConfig::StorageMedia > pstoragemedia_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(12 + 31) / 32];
  
  friend void  protobuf_AddDesc_NRUConfig_2eproto();
  friend void protobuf_AssignDesc_NRUConfig_2eproto();
  friend void protobuf_ShutdownFile_NRUConfig_2eproto();
  
  void InitAsDefaultInstance();
  static NRUInfo* default_instance_;
};
// -------------------------------------------------------------------

class Storage_Schedule_ListItem : public ::google::protobuf::Message {
 public:
  Storage_Schedule_ListItem();
  virtual ~Storage_Schedule_ListItem();
  
  Storage_Schedule_ListItem(const Storage_Schedule_ListItem& from);
  
  inline Storage_Schedule_ListItem& operator=(const Storage_Schedule_ListItem& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Storage_Schedule_ListItem& default_instance();
  
  void Swap(Storage_Schedule_ListItem* other);
  
  // implements Message ----------------------------------------------
  
  Storage_Schedule_ListItem* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Storage_Schedule_ListItem& from);
  void MergeFrom(const Storage_Schedule_ListItem& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string szName = 1;
  inline bool has_szname() const;
  inline void clear_szname();
  static const int kSzNameFieldNumber = 1;
  inline const ::std::string& szname() const;
  inline void set_szname(const ::std::string& value);
  inline void set_szname(const char* value);
  inline void set_szname(const char* value, size_t size);
  inline ::std::string* mutable_szname();
  inline ::std::string* release_szname();
  
  // optional .BVCU.PUConfig.WallTime stBegin = 2;
  inline bool has_stbegin() const;
  inline void clear_stbegin();
  static const int kStBeginFieldNumber = 2;
  inline const ::BVCU::PUConfig::WallTime& stbegin() const;
  inline ::BVCU::PUConfig::WallTime* mutable_stbegin();
  inline ::BVCU::PUConfig::WallTime* release_stbegin();
  
  // optional .BVCU.PUConfig.WallTime stEnd = 3;
  inline bool has_stend() const;
  inline void clear_stend();
  static const int kStEndFieldNumber = 3;
  inline const ::BVCU::PUConfig::WallTime& stend() const;
  inline ::BVCU::PUConfig::WallTime* mutable_stend();
  inline ::BVCU::PUConfig::WallTime* release_stend();
  
  // @@protoc_insertion_point(class_scope:BVCU.NRUConfig.Storage_Schedule_ListItem)
 private:
  inline void set_has_szname();
  inline void clear_has_szname();
  inline void set_has_stbegin();
  inline void clear_has_stbegin();
  inline void set_has_stend();
  inline void clear_has_stend();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* szname_;
  ::BVCU::PUConfig::WallTime* stbegin_;
  ::BVCU::PUConfig::WallTime* stend_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_NRUConfig_2eproto();
  friend void protobuf_AssignDesc_NRUConfig_2eproto();
  friend void protobuf_ShutdownFile_NRUConfig_2eproto();
  
  void InitAsDefaultInstance();
  static Storage_Schedule_ListItem* default_instance_;
};
// -------------------------------------------------------------------

class Storage_Channel : public ::google::protobuf::Message {
 public:
  Storage_Channel();
  virtual ~Storage_Channel();
  
  Storage_Channel(const Storage_Channel& from);
  
  inline Storage_Channel& operator=(const Storage_Channel& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Storage_Channel& default_instance();
  
  void Swap(Storage_Channel* other);
  
  // implements Message ----------------------------------------------
  
  Storage_Channel* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Storage_Channel& from);
  void MergeFrom(const Storage_Channel& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional uint32 iChannelIndex = 1;
  inline bool has_ichannelindex() const;
  inline void clear_ichannelindex();
  static const int kIChannelIndexFieldNumber = 1;
  inline ::google::protobuf::uint32 ichannelindex() const;
  inline void set_ichannelindex(::google::protobuf::uint32 value);
  
  // optional uint32 bRecordAudio = 2;
  inline bool has_brecordaudio() const;
  inline void clear_brecordaudio();
  static const int kBRecordAudioFieldNumber = 2;
  inline ::google::protobuf::uint32 brecordaudio() const;
  inline void set_brecordaudio(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:BVCU.NRUConfig.Storage_Channel)
 private:
  inline void set_has_ichannelindex();
  inline void clear_has_ichannelindex();
  inline void set_has_brecordaudio();
  inline void clear_has_brecordaudio();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint32 ichannelindex_;
  ::google::protobuf::uint32 brecordaudio_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_NRUConfig_2eproto();
  friend void protobuf_AssignDesc_NRUConfig_2eproto();
  friend void protobuf_ShutdownFile_NRUConfig_2eproto();
  
  void InitAsDefaultInstance();
  static Storage_Channel* default_instance_;
};
// -------------------------------------------------------------------

class Storage_PU : public ::google::protobuf::Message {
 public:
  Storage_PU();
  virtual ~Storage_PU();
  
  Storage_PU(const Storage_PU& from);
  
  inline Storage_PU& operator=(const Storage_PU& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Storage_PU& default_instance();
  
  void Swap(Storage_PU* other);
  
  // implements Message ----------------------------------------------
  
  Storage_PU* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Storage_PU& from);
  void MergeFrom(const Storage_PU& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string szID = 1;
  inline bool has_szid() const;
  inline void clear_szid();
  static const int kSzIDFieldNumber = 1;
  inline const ::std::string& szid() const;
  inline void set_szid(const ::std::string& value);
  inline void set_szid(const char* value);
  inline void set_szid(const char* value, size_t size);
  inline ::std::string* mutable_szid();
  inline ::std::string* release_szid();
  
  // repeated .BVCU.NRUConfig.Storage_Channel pChannel = 2;
  inline int pchannel_size() const;
  inline void clear_pchannel();
  static const int kPChannelFieldNumber = 2;
  inline const ::BVCU::NRUConfig::Storage_Channel& pchannel(int index) const;
  inline ::BVCU::NRUConfig::Storage_Channel* mutable_pchannel(int index);
  inline ::BVCU::NRUConfig::Storage_Channel* add_pchannel();
  inline const ::google::protobuf::RepeatedPtrField< ::BVCU::NRUConfig::Storage_Channel >&
      pchannel() const;
  inline ::google::protobuf::RepeatedPtrField< ::BVCU::NRUConfig::Storage_Channel >*
      mutable_pchannel();
  
  // @@protoc_insertion_point(class_scope:BVCU.NRUConfig.Storage_PU)
 private:
  inline void set_has_szid();
  inline void clear_has_szid();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* szid_;
  ::google::protobuf::RepeatedPtrField< ::BVCU::NRUConfig::Storage_Channel > pchannel_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_NRUConfig_2eproto();
  friend void protobuf_AssignDesc_NRUConfig_2eproto();
  friend void protobuf_ShutdownFile_NRUConfig_2eproto();
  
  void InitAsDefaultInstance();
  static Storage_PU* default_instance_;
};
// -------------------------------------------------------------------

class Storage_Schedule : public ::google::protobuf::Message {
 public:
  Storage_Schedule();
  virtual ~Storage_Schedule();
  
  Storage_Schedule(const Storage_Schedule& from);
  
  inline Storage_Schedule& operator=(const Storage_Schedule& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Storage_Schedule& default_instance();
  
  void Swap(Storage_Schedule* other);
  
  // implements Message ----------------------------------------------
  
  Storage_Schedule* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Storage_Schedule& from);
  void MergeFrom(const Storage_Schedule& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string szName = 1;
  inline bool has_szname() const;
  inline void clear_szname();
  static const int kSzNameFieldNumber = 1;
  inline const ::std::string& szname() const;
  inline void set_szname(const ::std::string& value);
  inline void set_szname(const char* value);
  inline void set_szname(const char* value, size_t size);
  inline ::std::string* mutable_szname();
  inline ::std::string* release_szname();
  
  // optional .BVCU.PUConfig.WeekTimeSlice stWeek = 2;
  inline bool has_stweek() const;
  inline void clear_stweek();
  static const int kStWeekFieldNumber = 2;
  inline const ::BVCU::PUConfig::WeekTimeSlice& stweek() const;
  inline ::BVCU::PUConfig::WeekTimeSlice* mutable_stweek();
  inline ::BVCU::PUConfig::WeekTimeSlice* release_stweek();
  
  // optional .BVCU.PUConfig.WallTime stBegin = 3;
  inline bool has_stbegin() const;
  inline void clear_stbegin();
  static const int kStBeginFieldNumber = 3;
  inline const ::BVCU::PUConfig::WallTime& stbegin() const;
  inline ::BVCU::PUConfig::WallTime* mutable_stbegin();
  inline ::BVCU::PUConfig::WallTime* release_stbegin();
  
  // optional .BVCU.PUConfig.WallTime stEnd = 4;
  inline bool has_stend() const;
  inline void clear_stend();
  static const int kStEndFieldNumber = 4;
  inline const ::BVCU::PUConfig::WallTime& stend() const;
  inline ::BVCU::PUConfig::WallTime* mutable_stend();
  inline ::BVCU::PUConfig::WallTime* release_stend();
  
  // repeated .BVCU.NRUConfig.Storage_PU pStoragePU = 6;
  inline int pstoragepu_size() const;
  inline void clear_pstoragepu();
  static const int kPStoragePUFieldNumber = 6;
  inline const ::BVCU::NRUConfig::Storage_PU& pstoragepu(int index) const;
  inline ::BVCU::NRUConfig::Storage_PU* mutable_pstoragepu(int index);
  inline ::BVCU::NRUConfig::Storage_PU* add_pstoragepu();
  inline const ::google::protobuf::RepeatedPtrField< ::BVCU::NRUConfig::Storage_PU >&
      pstoragepu() const;
  inline ::google::protobuf::RepeatedPtrField< ::BVCU::NRUConfig::Storage_PU >*
      mutable_pstoragepu();
  
  // @@protoc_insertion_point(class_scope:BVCU.NRUConfig.Storage_Schedule)
 private:
  inline void set_has_szname();
  inline void clear_has_szname();
  inline void set_has_stweek();
  inline void clear_has_stweek();
  inline void set_has_stbegin();
  inline void clear_has_stbegin();
  inline void set_has_stend();
  inline void clear_has_stend();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* szname_;
  ::BVCU::PUConfig::WeekTimeSlice* stweek_;
  ::BVCU::PUConfig::WallTime* stbegin_;
  ::BVCU::PUConfig::WallTime* stend_;
  ::google::protobuf::RepeatedPtrField< ::BVCU::NRUConfig::Storage_PU > pstoragepu_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_NRUConfig_2eproto();
  friend void protobuf_AssignDesc_NRUConfig_2eproto();
  friend void protobuf_ShutdownFile_NRUConfig_2eproto();
  
  void InitAsDefaultInstance();
  static Storage_Schedule* default_instance_;
};
// ===================================================================


// ===================================================================

// StorageMedia

// optional string szName = 1;
inline bool StorageMedia::has_szname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StorageMedia::set_has_szname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StorageMedia::clear_has_szname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StorageMedia::clear_szname() {
  if (szname_ != &::google::protobuf::internal::kEmptyString) {
    szname_->clear();
  }
  clear_has_szname();
}
inline const ::std::string& StorageMedia::szname() const {
  return *szname_;
}
inline void StorageMedia::set_szname(const ::std::string& value) {
  set_has_szname();
  if (szname_ == &::google::protobuf::internal::kEmptyString) {
    szname_ = new ::std::string;
  }
  szname_->assign(value);
}
inline void StorageMedia::set_szname(const char* value) {
  set_has_szname();
  if (szname_ == &::google::protobuf::internal::kEmptyString) {
    szname_ = new ::std::string;
  }
  szname_->assign(value);
}
inline void StorageMedia::set_szname(const char* value, size_t size) {
  set_has_szname();
  if (szname_ == &::google::protobuf::internal::kEmptyString) {
    szname_ = new ::std::string;
  }
  szname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StorageMedia::mutable_szname() {
  set_has_szname();
  if (szname_ == &::google::protobuf::internal::kEmptyString) {
    szname_ = new ::std::string;
  }
  return szname_;
}
inline ::std::string* StorageMedia::release_szname() {
  clear_has_szname();
  if (szname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = szname_;
    szname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional uint32 iTotalSpace = 2;
inline bool StorageMedia::has_itotalspace() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StorageMedia::set_has_itotalspace() {
  _has_bits_[0] |= 0x00000002u;
}
inline void StorageMedia::clear_has_itotalspace() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void StorageMedia::clear_itotalspace() {
  itotalspace_ = 0u;
  clear_has_itotalspace();
}
inline ::google::protobuf::uint32 StorageMedia::itotalspace() const {
  return itotalspace_;
}
inline void StorageMedia::set_itotalspace(::google::protobuf::uint32 value) {
  set_has_itotalspace();
  itotalspace_ = value;
}

// optional uint32 iFreeSpace = 3;
inline bool StorageMedia::has_ifreespace() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void StorageMedia::set_has_ifreespace() {
  _has_bits_[0] |= 0x00000004u;
}
inline void StorageMedia::clear_has_ifreespace() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void StorageMedia::clear_ifreespace() {
  ifreespace_ = 0u;
  clear_has_ifreespace();
}
inline ::google::protobuf::uint32 StorageMedia::ifreespace() const {
  return ifreespace_;
}
inline void StorageMedia::set_ifreespace(::google::protobuf::uint32 value) {
  set_has_ifreespace();
  ifreespace_ = value;
}

// optional uint32 bInUse = 4;
inline bool StorageMedia::has_binuse() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void StorageMedia::set_has_binuse() {
  _has_bits_[0] |= 0x00000008u;
}
inline void StorageMedia::clear_has_binuse() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void StorageMedia::clear_binuse() {
  binuse_ = 0u;
  clear_has_binuse();
}
inline ::google::protobuf::uint32 StorageMedia::binuse() const {
  return binuse_;
}
inline void StorageMedia::set_binuse(::google::protobuf::uint32 value) {
  set_has_binuse();
  binuse_ = value;
}

// -------------------------------------------------------------------

// NRUItem

// optional string szID = 1;
inline bool NRUItem::has_szid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NRUItem::set_has_szid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NRUItem::clear_has_szid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NRUItem::clear_szid() {
  if (szid_ != &::google::protobuf::internal::kEmptyString) {
    szid_->clear();
  }
  clear_has_szid();
}
inline const ::std::string& NRUItem::szid() const {
  return *szid_;
}
inline void NRUItem::set_szid(const ::std::string& value) {
  set_has_szid();
  if (szid_ == &::google::protobuf::internal::kEmptyString) {
    szid_ = new ::std::string;
  }
  szid_->assign(value);
}
inline void NRUItem::set_szid(const char* value) {
  set_has_szid();
  if (szid_ == &::google::protobuf::internal::kEmptyString) {
    szid_ = new ::std::string;
  }
  szid_->assign(value);
}
inline void NRUItem::set_szid(const char* value, size_t size) {
  set_has_szid();
  if (szid_ == &::google::protobuf::internal::kEmptyString) {
    szid_ = new ::std::string;
  }
  szid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NRUItem::mutable_szid() {
  set_has_szid();
  if (szid_ == &::google::protobuf::internal::kEmptyString) {
    szid_ = new ::std::string;
  }
  return szid_;
}
inline ::std::string* NRUItem::release_szid() {
  clear_has_szid();
  if (szid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = szid_;
    szid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string szName = 2;
inline bool NRUItem::has_szname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NRUItem::set_has_szname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NRUItem::clear_has_szname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NRUItem::clear_szname() {
  if (szname_ != &::google::protobuf::internal::kEmptyString) {
    szname_->clear();
  }
  clear_has_szname();
}
inline const ::std::string& NRUItem::szname() const {
  return *szname_;
}
inline void NRUItem::set_szname(const ::std::string& value) {
  set_has_szname();
  if (szname_ == &::google::protobuf::internal::kEmptyString) {
    szname_ = new ::std::string;
  }
  szname_->assign(value);
}
inline void NRUItem::set_szname(const char* value) {
  set_has_szname();
  if (szname_ == &::google::protobuf::internal::kEmptyString) {
    szname_ = new ::std::string;
  }
  szname_->assign(value);
}
inline void NRUItem::set_szname(const char* value, size_t size) {
  set_has_szname();
  if (szname_ == &::google::protobuf::internal::kEmptyString) {
    szname_ = new ::std::string;
  }
  szname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NRUItem::mutable_szname() {
  set_has_szname();
  if (szname_ == &::google::protobuf::internal::kEmptyString) {
    szname_ = new ::std::string;
  }
  return szname_;
}
inline ::std::string* NRUItem::release_szname() {
  clear_has_szname();
  if (szname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = szname_;
    szname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional uint32 iStorageMediaCount = 3;
inline bool NRUItem::has_istoragemediacount() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void NRUItem::set_has_istoragemediacount() {
  _has_bits_[0] |= 0x00000004u;
}
inline void NRUItem::clear_has_istoragemediacount() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void NRUItem::clear_istoragemediacount() {
  istoragemediacount_ = 0u;
  clear_has_istoragemediacount();
}
inline ::google::protobuf::uint32 NRUItem::istoragemediacount() const {
  return istoragemediacount_;
}
inline void NRUItem::set_istoragemediacount(::google::protobuf::uint32 value) {
  set_has_istoragemediacount();
  istoragemediacount_ = value;
}

// optional uint32 iOnlineStatus = 4;
inline bool NRUItem::has_ionlinestatus() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void NRUItem::set_has_ionlinestatus() {
  _has_bits_[0] |= 0x00000008u;
}
inline void NRUItem::clear_has_ionlinestatus() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void NRUItem::clear_ionlinestatus() {
  ionlinestatus_ = 0u;
  clear_has_ionlinestatus();
}
inline ::google::protobuf::uint32 NRUItem::ionlinestatus() const {
  return ionlinestatus_;
}
inline void NRUItem::set_ionlinestatus(::google::protobuf::uint32 value) {
  set_has_ionlinestatus();
  ionlinestatus_ = value;
}

// -------------------------------------------------------------------

// NRUInfo

// optional string szID = 1;
inline bool NRUInfo::has_szid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NRUInfo::set_has_szid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NRUInfo::clear_has_szid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NRUInfo::clear_szid() {
  if (szid_ != &::google::protobuf::internal::kEmptyString) {
    szid_->clear();
  }
  clear_has_szid();
}
inline const ::std::string& NRUInfo::szid() const {
  return *szid_;
}
inline void NRUInfo::set_szid(const ::std::string& value) {
  set_has_szid();
  if (szid_ == &::google::protobuf::internal::kEmptyString) {
    szid_ = new ::std::string;
  }
  szid_->assign(value);
}
inline void NRUInfo::set_szid(const char* value) {
  set_has_szid();
  if (szid_ == &::google::protobuf::internal::kEmptyString) {
    szid_ = new ::std::string;
  }
  szid_->assign(value);
}
inline void NRUInfo::set_szid(const char* value, size_t size) {
  set_has_szid();
  if (szid_ == &::google::protobuf::internal::kEmptyString) {
    szid_ = new ::std::string;
  }
  szid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NRUInfo::mutable_szid() {
  set_has_szid();
  if (szid_ == &::google::protobuf::internal::kEmptyString) {
    szid_ = new ::std::string;
  }
  return szid_;
}
inline ::std::string* NRUInfo::release_szid() {
  clear_has_szid();
  if (szid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = szid_;
    szid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string szManufacturer = 2;
inline bool NRUInfo::has_szmanufacturer() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NRUInfo::set_has_szmanufacturer() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NRUInfo::clear_has_szmanufacturer() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NRUInfo::clear_szmanufacturer() {
  if (szmanufacturer_ != &::google::protobuf::internal::kEmptyString) {
    szmanufacturer_->clear();
  }
  clear_has_szmanufacturer();
}
inline const ::std::string& NRUInfo::szmanufacturer() const {
  return *szmanufacturer_;
}
inline void NRUInfo::set_szmanufacturer(const ::std::string& value) {
  set_has_szmanufacturer();
  if (szmanufacturer_ == &::google::protobuf::internal::kEmptyString) {
    szmanufacturer_ = new ::std::string;
  }
  szmanufacturer_->assign(value);
}
inline void NRUInfo::set_szmanufacturer(const char* value) {
  set_has_szmanufacturer();
  if (szmanufacturer_ == &::google::protobuf::internal::kEmptyString) {
    szmanufacturer_ = new ::std::string;
  }
  szmanufacturer_->assign(value);
}
inline void NRUInfo::set_szmanufacturer(const char* value, size_t size) {
  set_has_szmanufacturer();
  if (szmanufacturer_ == &::google::protobuf::internal::kEmptyString) {
    szmanufacturer_ = new ::std::string;
  }
  szmanufacturer_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NRUInfo::mutable_szmanufacturer() {
  set_has_szmanufacturer();
  if (szmanufacturer_ == &::google::protobuf::internal::kEmptyString) {
    szmanufacturer_ = new ::std::string;
  }
  return szmanufacturer_;
}
inline ::std::string* NRUInfo::release_szmanufacturer() {
  clear_has_szmanufacturer();
  if (szmanufacturer_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = szmanufacturer_;
    szmanufacturer_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string szSoftwareVersion = 3;
inline bool NRUInfo::has_szsoftwareversion() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void NRUInfo::set_has_szsoftwareversion() {
  _has_bits_[0] |= 0x00000004u;
}
inline void NRUInfo::clear_has_szsoftwareversion() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void NRUInfo::clear_szsoftwareversion() {
  if (szsoftwareversion_ != &::google::protobuf::internal::kEmptyString) {
    szsoftwareversion_->clear();
  }
  clear_has_szsoftwareversion();
}
inline const ::std::string& NRUInfo::szsoftwareversion() const {
  return *szsoftwareversion_;
}
inline void NRUInfo::set_szsoftwareversion(const ::std::string& value) {
  set_has_szsoftwareversion();
  if (szsoftwareversion_ == &::google::protobuf::internal::kEmptyString) {
    szsoftwareversion_ = new ::std::string;
  }
  szsoftwareversion_->assign(value);
}
inline void NRUInfo::set_szsoftwareversion(const char* value) {
  set_has_szsoftwareversion();
  if (szsoftwareversion_ == &::google::protobuf::internal::kEmptyString) {
    szsoftwareversion_ = new ::std::string;
  }
  szsoftwareversion_->assign(value);
}
inline void NRUInfo::set_szsoftwareversion(const char* value, size_t size) {
  set_has_szsoftwareversion();
  if (szsoftwareversion_ == &::google::protobuf::internal::kEmptyString) {
    szsoftwareversion_ = new ::std::string;
  }
  szsoftwareversion_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NRUInfo::mutable_szsoftwareversion() {
  set_has_szsoftwareversion();
  if (szsoftwareversion_ == &::google::protobuf::internal::kEmptyString) {
    szsoftwareversion_ = new ::std::string;
  }
  return szsoftwareversion_;
}
inline ::std::string* NRUInfo::release_szsoftwareversion() {
  clear_has_szsoftwareversion();
  if (szsoftwareversion_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = szsoftwareversion_;
    szsoftwareversion_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string szHardwareVersion = 4;
inline bool NRUInfo::has_szhardwareversion() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void NRUInfo::set_has_szhardwareversion() {
  _has_bits_[0] |= 0x00000008u;
}
inline void NRUInfo::clear_has_szhardwareversion() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void NRUInfo::clear_szhardwareversion() {
  if (szhardwareversion_ != &::google::protobuf::internal::kEmptyString) {
    szhardwareversion_->clear();
  }
  clear_has_szhardwareversion();
}
inline const ::std::string& NRUInfo::szhardwareversion() const {
  return *szhardwareversion_;
}
inline void NRUInfo::set_szhardwareversion(const ::std::string& value) {
  set_has_szhardwareversion();
  if (szhardwareversion_ == &::google::protobuf::internal::kEmptyString) {
    szhardwareversion_ = new ::std::string;
  }
  szhardwareversion_->assign(value);
}
inline void NRUInfo::set_szhardwareversion(const char* value) {
  set_has_szhardwareversion();
  if (szhardwareversion_ == &::google::protobuf::internal::kEmptyString) {
    szhardwareversion_ = new ::std::string;
  }
  szhardwareversion_->assign(value);
}
inline void NRUInfo::set_szhardwareversion(const char* value, size_t size) {
  set_has_szhardwareversion();
  if (szhardwareversion_ == &::google::protobuf::internal::kEmptyString) {
    szhardwareversion_ = new ::std::string;
  }
  szhardwareversion_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NRUInfo::mutable_szhardwareversion() {
  set_has_szhardwareversion();
  if (szhardwareversion_ == &::google::protobuf::internal::kEmptyString) {
    szhardwareversion_ = new ::std::string;
  }
  return szhardwareversion_;
}
inline ::std::string* NRUInfo::release_szhardwareversion() {
  clear_has_szhardwareversion();
  if (szhardwareversion_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = szhardwareversion_;
    szhardwareversion_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string szName = 5;
inline bool NRUInfo::has_szname() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void NRUInfo::set_has_szname() {
  _has_bits_[0] |= 0x00000010u;
}
inline void NRUInfo::clear_has_szname() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void NRUInfo::clear_szname() {
  if (szname_ != &::google::protobuf::internal::kEmptyString) {
    szname_->clear();
  }
  clear_has_szname();
}
inline const ::std::string& NRUInfo::szname() const {
  return *szname_;
}
inline void NRUInfo::set_szname(const ::std::string& value) {
  set_has_szname();
  if (szname_ == &::google::protobuf::internal::kEmptyString) {
    szname_ = new ::std::string;
  }
  szname_->assign(value);
}
inline void NRUInfo::set_szname(const char* value) {
  set_has_szname();
  if (szname_ == &::google::protobuf::internal::kEmptyString) {
    szname_ = new ::std::string;
  }
  szname_->assign(value);
}
inline void NRUInfo::set_szname(const char* value, size_t size) {
  set_has_szname();
  if (szname_ == &::google::protobuf::internal::kEmptyString) {
    szname_ = new ::std::string;
  }
  szname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NRUInfo::mutable_szname() {
  set_has_szname();
  if (szname_ == &::google::protobuf::internal::kEmptyString) {
    szname_ = new ::std::string;
  }
  return szname_;
}
inline ::std::string* NRUInfo::release_szname() {
  clear_has_szname();
  if (szname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = szname_;
    szname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional uint32 iNoSpaceRule = 6;
inline bool NRUInfo::has_inospacerule() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void NRUInfo::set_has_inospacerule() {
  _has_bits_[0] |= 0x00000020u;
}
inline void NRUInfo::clear_has_inospacerule() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void NRUInfo::clear_inospacerule() {
  inospacerule_ = 0u;
  clear_has_inospacerule();
}
inline ::google::protobuf::uint32 NRUInfo::inospacerule() const {
  return inospacerule_;
}
inline void NRUInfo::set_inospacerule(::google::protobuf::uint32 value) {
  set_has_inospacerule();
  inospacerule_ = value;
}

// optional uint32 iReserveRecordDays = 7;
inline bool NRUInfo::has_ireserverecorddays() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void NRUInfo::set_has_ireserverecorddays() {
  _has_bits_[0] |= 0x00000040u;
}
inline void NRUInfo::clear_has_ireserverecorddays() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void NRUInfo::clear_ireserverecorddays() {
  ireserverecorddays_ = 0u;
  clear_has_ireserverecorddays();
}
inline ::google::protobuf::uint32 NRUInfo::ireserverecorddays() const {
  return ireserverecorddays_;
}
inline void NRUInfo::set_ireserverecorddays(::google::protobuf::uint32 value) {
  set_has_ireserverecorddays();
  ireserverecorddays_ = value;
}

// optional uint32 iRecordFileLength = 8;
inline bool NRUInfo::has_irecordfilelength() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void NRUInfo::set_has_irecordfilelength() {
  _has_bits_[0] |= 0x00000080u;
}
inline void NRUInfo::clear_has_irecordfilelength() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void NRUInfo::clear_irecordfilelength() {
  irecordfilelength_ = 0u;
  clear_has_irecordfilelength();
}
inline ::google::protobuf::uint32 NRUInfo::irecordfilelength() const {
  return irecordfilelength_;
}
inline void NRUInfo::set_irecordfilelength(::google::protobuf::uint32 value) {
  set_has_irecordfilelength();
  irecordfilelength_ = value;
}

// optional uint32 iReservePicDays = 9;
inline bool NRUInfo::has_ireservepicdays() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void NRUInfo::set_has_ireservepicdays() {
  _has_bits_[0] |= 0x00000100u;
}
inline void NRUInfo::clear_has_ireservepicdays() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void NRUInfo::clear_ireservepicdays() {
  ireservepicdays_ = 0u;
  clear_has_ireservepicdays();
}
inline ::google::protobuf::uint32 NRUInfo::ireservepicdays() const {
  return ireservepicdays_;
}
inline void NRUInfo::set_ireservepicdays(::google::protobuf::uint32 value) {
  set_has_ireservepicdays();
  ireservepicdays_ = value;
}

// optional uint32 iReserveGPSDays = 10;
inline bool NRUInfo::has_ireservegpsdays() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void NRUInfo::set_has_ireservegpsdays() {
  _has_bits_[0] |= 0x00000200u;
}
inline void NRUInfo::clear_has_ireservegpsdays() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void NRUInfo::clear_ireservegpsdays() {
  ireservegpsdays_ = 0u;
  clear_has_ireservegpsdays();
}
inline ::google::protobuf::uint32 NRUInfo::ireservegpsdays() const {
  return ireservegpsdays_;
}
inline void NRUInfo::set_ireservegpsdays(::google::protobuf::uint32 value) {
  set_has_ireservegpsdays();
  ireservegpsdays_ = value;
}

// optional uint32 iOnlineStatus = 11;
inline bool NRUInfo::has_ionlinestatus() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void NRUInfo::set_has_ionlinestatus() {
  _has_bits_[0] |= 0x00000400u;
}
inline void NRUInfo::clear_has_ionlinestatus() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void NRUInfo::clear_ionlinestatus() {
  ionlinestatus_ = 0u;
  clear_has_ionlinestatus();
}
inline ::google::protobuf::uint32 NRUInfo::ionlinestatus() const {
  return ionlinestatus_;
}
inline void NRUInfo::set_ionlinestatus(::google::protobuf::uint32 value) {
  set_has_ionlinestatus();
  ionlinestatus_ = value;
}

// repeated .BVCU.NRUConfig.StorageMedia pStorageMedia = 12;
inline int NRUInfo::pstoragemedia_size() const {
  return pstoragemedia_.size();
}
inline void NRUInfo::clear_pstoragemedia() {
  pstoragemedia_.Clear();
}
inline const ::BVCU::NRUConfig::StorageMedia& NRUInfo::pstoragemedia(int index) const {
  return pstoragemedia_.Get(index);
}
inline ::BVCU::NRUConfig::StorageMedia* NRUInfo::mutable_pstoragemedia(int index) {
  return pstoragemedia_.Mutable(index);
}
inline ::BVCU::NRUConfig::StorageMedia* NRUInfo::add_pstoragemedia() {
  return pstoragemedia_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::BVCU::NRUConfig::StorageMedia >&
NRUInfo::pstoragemedia() const {
  return pstoragemedia_;
}
inline ::google::protobuf::RepeatedPtrField< ::BVCU::NRUConfig::StorageMedia >*
NRUInfo::mutable_pstoragemedia() {
  return &pstoragemedia_;
}

// -------------------------------------------------------------------

// Storage_Schedule_ListItem

// optional string szName = 1;
inline bool Storage_Schedule_ListItem::has_szname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Storage_Schedule_ListItem::set_has_szname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Storage_Schedule_ListItem::clear_has_szname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Storage_Schedule_ListItem::clear_szname() {
  if (szname_ != &::google::protobuf::internal::kEmptyString) {
    szname_->clear();
  }
  clear_has_szname();
}
inline const ::std::string& Storage_Schedule_ListItem::szname() const {
  return *szname_;
}
inline void Storage_Schedule_ListItem::set_szname(const ::std::string& value) {
  set_has_szname();
  if (szname_ == &::google::protobuf::internal::kEmptyString) {
    szname_ = new ::std::string;
  }
  szname_->assign(value);
}
inline void Storage_Schedule_ListItem::set_szname(const char* value) {
  set_has_szname();
  if (szname_ == &::google::protobuf::internal::kEmptyString) {
    szname_ = new ::std::string;
  }
  szname_->assign(value);
}
inline void Storage_Schedule_ListItem::set_szname(const char* value, size_t size) {
  set_has_szname();
  if (szname_ == &::google::protobuf::internal::kEmptyString) {
    szname_ = new ::std::string;
  }
  szname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Storage_Schedule_ListItem::mutable_szname() {
  set_has_szname();
  if (szname_ == &::google::protobuf::internal::kEmptyString) {
    szname_ = new ::std::string;
  }
  return szname_;
}
inline ::std::string* Storage_Schedule_ListItem::release_szname() {
  clear_has_szname();
  if (szname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = szname_;
    szname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional .BVCU.PUConfig.WallTime stBegin = 2;
inline bool Storage_Schedule_ListItem::has_stbegin() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Storage_Schedule_ListItem::set_has_stbegin() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Storage_Schedule_ListItem::clear_has_stbegin() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Storage_Schedule_ListItem::clear_stbegin() {
  if (stbegin_ != NULL) stbegin_->::BVCU::PUConfig::WallTime::Clear();
  clear_has_stbegin();
}
inline const ::BVCU::PUConfig::WallTime& Storage_Schedule_ListItem::stbegin() const {
  return stbegin_ != NULL ? *stbegin_ : *default_instance_->stbegin_;
}
inline ::BVCU::PUConfig::WallTime* Storage_Schedule_ListItem::mutable_stbegin() {
  set_has_stbegin();
  if (stbegin_ == NULL) stbegin_ = new ::BVCU::PUConfig::WallTime;
  return stbegin_;
}
inline ::BVCU::PUConfig::WallTime* Storage_Schedule_ListItem::release_stbegin() {
  clear_has_stbegin();
  ::BVCU::PUConfig::WallTime* temp = stbegin_;
  stbegin_ = NULL;
  return temp;
}

// optional .BVCU.PUConfig.WallTime stEnd = 3;
inline bool Storage_Schedule_ListItem::has_stend() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Storage_Schedule_ListItem::set_has_stend() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Storage_Schedule_ListItem::clear_has_stend() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Storage_Schedule_ListItem::clear_stend() {
  if (stend_ != NULL) stend_->::BVCU::PUConfig::WallTime::Clear();
  clear_has_stend();
}
inline const ::BVCU::PUConfig::WallTime& Storage_Schedule_ListItem::stend() const {
  return stend_ != NULL ? *stend_ : *default_instance_->stend_;
}
inline ::BVCU::PUConfig::WallTime* Storage_Schedule_ListItem::mutable_stend() {
  set_has_stend();
  if (stend_ == NULL) stend_ = new ::BVCU::PUConfig::WallTime;
  return stend_;
}
inline ::BVCU::PUConfig::WallTime* Storage_Schedule_ListItem::release_stend() {
  clear_has_stend();
  ::BVCU::PUConfig::WallTime* temp = stend_;
  stend_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// Storage_Channel

// optional uint32 iChannelIndex = 1;
inline bool Storage_Channel::has_ichannelindex() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Storage_Channel::set_has_ichannelindex() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Storage_Channel::clear_has_ichannelindex() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Storage_Channel::clear_ichannelindex() {
  ichannelindex_ = 0u;
  clear_has_ichannelindex();
}
inline ::google::protobuf::uint32 Storage_Channel::ichannelindex() const {
  return ichannelindex_;
}
inline void Storage_Channel::set_ichannelindex(::google::protobuf::uint32 value) {
  set_has_ichannelindex();
  ichannelindex_ = value;
}

// optional uint32 bRecordAudio = 2;
inline bool Storage_Channel::has_brecordaudio() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Storage_Channel::set_has_brecordaudio() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Storage_Channel::clear_has_brecordaudio() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Storage_Channel::clear_brecordaudio() {
  brecordaudio_ = 0u;
  clear_has_brecordaudio();
}
inline ::google::protobuf::uint32 Storage_Channel::brecordaudio() const {
  return brecordaudio_;
}
inline void Storage_Channel::set_brecordaudio(::google::protobuf::uint32 value) {
  set_has_brecordaudio();
  brecordaudio_ = value;
}

// -------------------------------------------------------------------

// Storage_PU

// optional string szID = 1;
inline bool Storage_PU::has_szid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Storage_PU::set_has_szid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Storage_PU::clear_has_szid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Storage_PU::clear_szid() {
  if (szid_ != &::google::protobuf::internal::kEmptyString) {
    szid_->clear();
  }
  clear_has_szid();
}
inline const ::std::string& Storage_PU::szid() const {
  return *szid_;
}
inline void Storage_PU::set_szid(const ::std::string& value) {
  set_has_szid();
  if (szid_ == &::google::protobuf::internal::kEmptyString) {
    szid_ = new ::std::string;
  }
  szid_->assign(value);
}
inline void Storage_PU::set_szid(const char* value) {
  set_has_szid();
  if (szid_ == &::google::protobuf::internal::kEmptyString) {
    szid_ = new ::std::string;
  }
  szid_->assign(value);
}
inline void Storage_PU::set_szid(const char* value, size_t size) {
  set_has_szid();
  if (szid_ == &::google::protobuf::internal::kEmptyString) {
    szid_ = new ::std::string;
  }
  szid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Storage_PU::mutable_szid() {
  set_has_szid();
  if (szid_ == &::google::protobuf::internal::kEmptyString) {
    szid_ = new ::std::string;
  }
  return szid_;
}
inline ::std::string* Storage_PU::release_szid() {
  clear_has_szid();
  if (szid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = szid_;
    szid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated .BVCU.NRUConfig.Storage_Channel pChannel = 2;
inline int Storage_PU::pchannel_size() const {
  return pchannel_.size();
}
inline void Storage_PU::clear_pchannel() {
  pchannel_.Clear();
}
inline const ::BVCU::NRUConfig::Storage_Channel& Storage_PU::pchannel(int index) const {
  return pchannel_.Get(index);
}
inline ::BVCU::NRUConfig::Storage_Channel* Storage_PU::mutable_pchannel(int index) {
  return pchannel_.Mutable(index);
}
inline ::BVCU::NRUConfig::Storage_Channel* Storage_PU::add_pchannel() {
  return pchannel_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::BVCU::NRUConfig::Storage_Channel >&
Storage_PU::pchannel() const {
  return pchannel_;
}
inline ::google::protobuf::RepeatedPtrField< ::BVCU::NRUConfig::Storage_Channel >*
Storage_PU::mutable_pchannel() {
  return &pchannel_;
}

// -------------------------------------------------------------------

// Storage_Schedule

// optional string szName = 1;
inline bool Storage_Schedule::has_szname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Storage_Schedule::set_has_szname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Storage_Schedule::clear_has_szname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Storage_Schedule::clear_szname() {
  if (szname_ != &::google::protobuf::internal::kEmptyString) {
    szname_->clear();
  }
  clear_has_szname();
}
inline const ::std::string& Storage_Schedule::szname() const {
  return *szname_;
}
inline void Storage_Schedule::set_szname(const ::std::string& value) {
  set_has_szname();
  if (szname_ == &::google::protobuf::internal::kEmptyString) {
    szname_ = new ::std::string;
  }
  szname_->assign(value);
}
inline void Storage_Schedule::set_szname(const char* value) {
  set_has_szname();
  if (szname_ == &::google::protobuf::internal::kEmptyString) {
    szname_ = new ::std::string;
  }
  szname_->assign(value);
}
inline void Storage_Schedule::set_szname(const char* value, size_t size) {
  set_has_szname();
  if (szname_ == &::google::protobuf::internal::kEmptyString) {
    szname_ = new ::std::string;
  }
  szname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Storage_Schedule::mutable_szname() {
  set_has_szname();
  if (szname_ == &::google::protobuf::internal::kEmptyString) {
    szname_ = new ::std::string;
  }
  return szname_;
}
inline ::std::string* Storage_Schedule::release_szname() {
  clear_has_szname();
  if (szname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = szname_;
    szname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional .BVCU.PUConfig.WeekTimeSlice stWeek = 2;
inline bool Storage_Schedule::has_stweek() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Storage_Schedule::set_has_stweek() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Storage_Schedule::clear_has_stweek() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Storage_Schedule::clear_stweek() {
  if (stweek_ != NULL) stweek_->::BVCU::PUConfig::WeekTimeSlice::Clear();
  clear_has_stweek();
}
inline const ::BVCU::PUConfig::WeekTimeSlice& Storage_Schedule::stweek() const {
  return stweek_ != NULL ? *stweek_ : *default_instance_->stweek_;
}
inline ::BVCU::PUConfig::WeekTimeSlice* Storage_Schedule::mutable_stweek() {
  set_has_stweek();
  if (stweek_ == NULL) stweek_ = new ::BVCU::PUConfig::WeekTimeSlice;
  return stweek_;
}
inline ::BVCU::PUConfig::WeekTimeSlice* Storage_Schedule::release_stweek() {
  clear_has_stweek();
  ::BVCU::PUConfig::WeekTimeSlice* temp = stweek_;
  stweek_ = NULL;
  return temp;
}

// optional .BVCU.PUConfig.WallTime stBegin = 3;
inline bool Storage_Schedule::has_stbegin() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Storage_Schedule::set_has_stbegin() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Storage_Schedule::clear_has_stbegin() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Storage_Schedule::clear_stbegin() {
  if (stbegin_ != NULL) stbegin_->::BVCU::PUConfig::WallTime::Clear();
  clear_has_stbegin();
}
inline const ::BVCU::PUConfig::WallTime& Storage_Schedule::stbegin() const {
  return stbegin_ != NULL ? *stbegin_ : *default_instance_->stbegin_;
}
inline ::BVCU::PUConfig::WallTime* Storage_Schedule::mutable_stbegin() {
  set_has_stbegin();
  if (stbegin_ == NULL) stbegin_ = new ::BVCU::PUConfig::WallTime;
  return stbegin_;
}
inline ::BVCU::PUConfig::WallTime* Storage_Schedule::release_stbegin() {
  clear_has_stbegin();
  ::BVCU::PUConfig::WallTime* temp = stbegin_;
  stbegin_ = NULL;
  return temp;
}

// optional .BVCU.PUConfig.WallTime stEnd = 4;
inline bool Storage_Schedule::has_stend() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Storage_Schedule::set_has_stend() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Storage_Schedule::clear_has_stend() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Storage_Schedule::clear_stend() {
  if (stend_ != NULL) stend_->::BVCU::PUConfig::WallTime::Clear();
  clear_has_stend();
}
inline const ::BVCU::PUConfig::WallTime& Storage_Schedule::stend() const {
  return stend_ != NULL ? *stend_ : *default_instance_->stend_;
}
inline ::BVCU::PUConfig::WallTime* Storage_Schedule::mutable_stend() {
  set_has_stend();
  if (stend_ == NULL) stend_ = new ::BVCU::PUConfig::WallTime;
  return stend_;
}
inline ::BVCU::PUConfig::WallTime* Storage_Schedule::release_stend() {
  clear_has_stend();
  ::BVCU::PUConfig::WallTime* temp = stend_;
  stend_ = NULL;
  return temp;
}

// repeated .BVCU.NRUConfig.Storage_PU pStoragePU = 6;
inline int Storage_Schedule::pstoragepu_size() const {
  return pstoragepu_.size();
}
inline void Storage_Schedule::clear_pstoragepu() {
  pstoragepu_.Clear();
}
inline const ::BVCU::NRUConfig::Storage_PU& Storage_Schedule::pstoragepu(int index) const {
  return pstoragepu_.Get(index);
}
inline ::BVCU::NRUConfig::Storage_PU* Storage_Schedule::mutable_pstoragepu(int index) {
  return pstoragepu_.Mutable(index);
}
inline ::BVCU::NRUConfig::Storage_PU* Storage_Schedule::add_pstoragepu() {
  return pstoragepu_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::BVCU::NRUConfig::Storage_PU >&
Storage_Schedule::pstoragepu() const {
  return pstoragepu_;
}
inline ::google::protobuf::RepeatedPtrField< ::BVCU::NRUConfig::Storage_PU >*
Storage_Schedule::mutable_pstoragepu() {
  return &pstoragepu_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace NRUConfig
}  // namespace BVCU

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_NRUConfig_2eproto__INCLUDED
